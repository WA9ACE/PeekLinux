!<arch>
_bufread.c/     1202506625  0     0     0       3584      `
/*****************************************************************************/
/*  _BUFREAD.C v2.70                                                         */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/
 
/*****************************************************************************/
/* Functions:                                                                */
/*    _BUFF_READ  -  Fill a stream's buffer from its file                    */
/*****************************************************************************/
#include <stdio.h>
#include <_lock.h>
#include "file.h"

extern _DATA_ACCESS int  _ft_end;
extern int  _doflush(FILE *_fp);
extern void _buff_read(FILE *_fp);


/*****************************************************************************/
/* _BUFF_READ  -   Fill a stream's buffer from its file                      */
/*                                                                           */
/*    This function fills stream _FP's buffer with the contents of the file  */
/*    it is associated with.  It returns nothing, but sets flags in the      */
/*    stream if any I/O errors occur.                                        */
/*                                                                           */
/*****************************************************************************/
void _buff_read(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   errchk,
         j,
         buffer_size    = _fp->bufend - _fp->buf;

   /*------------------------------------------------------------------------*/
   /* If this is a line buffered stream, flush all line buffered streams.    */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IOLBF)
   {
       /*--------------------------------------------------------------------*/
       /* This is a critical section because it depends on the global	     */
       /* variable _ft_end.						     */
       /*--------------------------------------------------------------------*/
       _lock();
       for(j=0; j < _ft_end; j++)
	   if(_BUFFMODE(&_ftable[j]) == _IOLBF)
	       _doflush(&_ftable[j]);
       _unlock();
   }

   /*------------------------------------------------------------------------*/
   /* Read in the next characters from the file.                             */
   /*------------------------------------------------------------------------*/
   errchk = read(_fp->fd, (char *)_fp->buf, buffer_size);

   /*------------------------------------------------------------------------*/
   /* Adjust the buffer pointers.                                            */
   /*------------------------------------------------------------------------*/
   _fp->buff_stop = _fp->buf + errchk;
   _fp->pos = _fp->buf;

   /*------------------------------------------------------------------------*/
   /* Set any error flags if necessary.                                      */
   /*------------------------------------------------------------------------*/
   switch(errchk)
   {
      case -1 : _SET(_fp, _STATERR);
                break;
 
      case 0  : _SET(_fp, _STATEOF);
                break;
   }

   return;
 
}
 
_io_perm.c/     1202506625  0     0     0       5956      `
/*****************************************************************************/
/*  _IO_PERM.C v2.70                                                         */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    _RD_OK   -  Check to make sure that the stream is readable             */
/*    _WRT_OK  -  Check to make sure that the stream is writeable            */
/*****************************************************************************/
#include <stdio.h>

extern int _rd_ok(FILE *_fp);
extern int _wrt_ok(FILE *_fp);


/*****************************************************************************/
/* _RD_OK   -  Check to make sure that the stream is readable.               */
/*                                                                           */
/*    This function checks to make sure that the stream _FP has been opened  */
/*    for reading, and allocates a buffer for the stream if one hasn't been  */
/*    already.  The function returns a 1 if it is alright to write to this   */
/*    stream, otherwise it returns a 0.                                      */
/*                                                                           */
/*****************************************************************************/
int _rd_ok(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   result   =  0;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (0);

   /*------------------------------------------------------------------------*/
   /* If this stream is currently being written to, return a 0.              */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEW)) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If this stream was opened in update mode, and is able to either read   */
   /* or write currently, put it in read mode.                               */
   /*------------------------------------------------------------------------*/
   if(!_STCHK(_fp, _MODER) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODER);
 
   /*------------------------------------------------------------------------*/
   /* Allocate a buffer for the stream if needed, and none exist.            */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);
 
   return (! result);
 
}


/*****************************************************************************/
/* _WRT_OK()   -  Check to make sure that a stream is writeable              */
/*                                                                           */
/*    This function takes the FILE pointer _FP, and makes sure that it is ok */
/*    to write to it.  It also allocates a buffer if one is needed.  The     */
/*    function returns a 1 if it is ok to write to this stream, otherwise it */
/*    returns a 0.                                                           */
/*                                                                           */
/*****************************************************************************/
int _wrt_ok(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   result   = 0;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (0);

   /*------------------------------------------------------------------------*/
   /* If this stream is currently being read return a 0.                     */
   /*------------------------------------------------------------------------*/
   if (_STCHK(_fp, _MODER)) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If the stream is in append mode, move the file pointer to the end of   */
   /* the file.                                                              */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEA)) fseek(_fp, 0L, SEEK_END);
 
   /*------------------------------------------------------------------------*/
   /* If this stream was opened in update mode, and is able to either read   */
   /* or write currently, put it in write mode.                              */
   /*------------------------------------------------------------------------*/
   if(!_STCHK(_fp, _MODEW) && _STCHK(_fp, _MODERW)) _SET(_fp, _MODEW);
 
   /*------------------------------------------------------------------------*/
   /* Allocate a buffer for the stream if needed, and none exist.            */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      result |= setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ);
 
   return (! result);
}

_lock.c/        1202506625  0     0     0       639       `
/****************************************************************************/
/*  _lock v2.70                                                             */
/*  Copyright (c) 2000-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <_lock.h>

_CODE_ACCESS void _nop()
{
  /* Do nothing. */
}

_DATA_ACCESS void (*  _lock)() = _nop;
_DATA_ACCESS void (*_unlock)() = _nop;

_CODE_ACCESS void _register_lock(void (*lock)())
{
    _lock = lock;
}

_CODE_ACCESS void _register_unlock(void (*unlock)())
{
    _unlock = unlock;
}

_lock.h/        1202506625  0     0     0       756       `
/*****************************************************************************/
/*  _lock.h v2.70                                                            */
/*  Copyright (c) 2000-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

#ifndef __LOCK_H
#define __LOCK_H

#include <linkage.h>

#ifdef __cplusplus
extern "C" namespace std {
#endif

_CODE_ACCESS void _nop();

extern _DATA_ACCESS void (  *_lock)();
extern _DATA_ACCESS void (*_unlock)();

_CODE_ACCESS void _register_lock  (void (  *lock)());
_CODE_ACCESS void _register_unlock(void (*unlock)());

#ifdef __cplusplus
} /* extern "C" namespace std */
#endif

#endif /* __LOCK_H */
_log.c/         1202506625  0     0     0       3252      `
/****************************************************************************/
/*  _log    v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  _LOG() - natural log (w/o error checking)				    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 5.              */
/*									    */
/*  N = exponent x							    */
/*  f = mantissa x, 0.5 <= f < 1					    */
/*  if f < sqrt(0.5), znum = f - 0.5, zden = znum * 0.5 + 0.5		    */
/*  if f > sqrt(0.5), znum = f - 1, zden = f * 0.5 + 0.5		    */
/*  z = znum / zden							    */
/*  w = z * z								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = R + N * ln(2)						    */
/****************************************************************************/
double _log(double x)
{
    double a, b, f, r, w, z, znum;
    int n;

    /************************************************************************/
    /* f = mantissa(x), n = exponent(x)            			    */
    /************************************************************************/
    f = frexp(x, &n);

    /************************************************************************/
    /* for numbers <= sqrt(0.5)                                             */
    /************************************************************************/
    if (f <= SQRTHALF)
    {
        --n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /************************************************************************/
    /* for numbers > sqrt(0.5)                                              */
    /************************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /************************************************************************/
    /* determine polynomial expression                                      */
    /************************************************************************/
    w = z * z;

#if BITS<=24
    a = A0;
    b = w + B0;
#elif BITS>=25 && BITS<=32
    a = A1 * w + A0;
    b = w + B0;
#elif BITS>=33 && BITS<=48
    a = (A2 * w + A1) * w + A0;
    b = (w + B1) * w + B0;
#else
    a = (A2 * w + A1) * w + A0;
    b = ((w + B2) * w + B1) * w + B0;
#endif

    /************************************************************************/
    /* calculate the natural log of (mant x) / 2                            */
    /************************************************************************/
    r = z + z * w * (a / b);

    /************************************************************************/
    /* ln(x) = ln (mant x) + 2 * (exp x) (but more mathematically stable)   */
    /************************************************************************/
    return ((n * C4 + r) + n * C3);
}
_printfi.c/     1202506625  0     0     0       51510     `
/*****************************************************************************/
/*  _PRINTFI.C v2.70                                                         */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the main routines that all six variations of the    */
/*    printf function use.  The main function in the file is _printfi,       */
/*    and the other functions here are called by it.                         */
/*                                                                           */
/* FUNCTIONS:                                                                */
/*    _printfi       -  Perform the main printf routine                      */
/*    _pproc_fflags  -  Process the format flags for a conversion            */
/*    _pproc_fwp     -  Convert field width and precision into numbers       */
/*    _pproc_str     -  Process the string (%s) conversion                   */
/*    _setfield      -  Performs conversions when the '%' is encountered     */
/*    _pproc_fge     -  Process the conversion for f, g, G, e, and E         */
/*    _pconv_f       -  Perform the %f conversion                            */
/*    _pconv_e       -  Perform the %e conversion                            */
/*    _pconv_g       -  Perform the %g conversion                            */
/*    _fcpy          -  Copy the fraction part of a float to a string        */
/*    _ecpy          -  Copy the "E+xx" part of a float to a string          */
/*    _mcpy          -  Copy the whole number part of a float to a string    */
/*    _pproc_diouxp  -  Process the conversion for d, i, o, u, x, and p      */
/*    _getarg_diouxp -  Get the argument for d, i, o, u, x, or p conversion  */
/*    _ltostr        -  Convert an integer to a string of up to base 16      */
/*    _div           -  Divide two integers                                  */
/*                                                                           */
/* Note:  If NOFLOAT is defined at compile time, this file will be compiled  */
/*        without floating point support.                                    */
/*****************************************************************************/
#include <stdio.h>
#include <format.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <limits.h>
#include <math.h>
#include <_lock.h>

#define SIGNED_CONV (pfield->conv != 'u' && pfield->conv != 'o' && \
                     pfield->conv != 'x' && pfield->conv != 'X')

extern _CODE_ACCESS char *fcvt(long double value, register int ndigit, 
			       int *decpt, int *sign);
extern _CODE_ACCESS char *ecvt(long double value, register int ndigit, 
			       int *decpt, int *sign);
extern _CODE_ACCESS char *memccpy(char *dest, const char *src, int ch,
				  int count);

extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

static void _pproc_fflags(_PFIELD *pfield, char **it);
static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap);
static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,
                       int (*_outs)(char *, void *));
static char *_setfield(_PFIELD *pfield, va_list *_ap);
static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it,
                       va_list *_ap);
static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it);
static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it);
static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it);
static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision,
                   char **a_it);
static char *_ecpy(int exp, char letter, char **a_it);
static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it);
static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it,
                         va_list *_ap);
static uintmax_t _getarg_diouxp(_PFIELD *pfield, va_list *_ap);
static int _ltostr(uintmax_t cvt, int base, char conv, char **a_it);
static uintmax_t _div(uintmax_t cvt, int base);

/*****************************************************************************/
/* _PRINTFI -  Perform the main printf routine                               */
/*                                                                           */
/*    This function processes the format string.  It copies the format       */
/*    string into the result string until a '%' is encountered, where any    */
/*    flags, the field width, the precision, and the type of conversion are  */
/*    read in, stored in a structure called PFIELD, and passed to _SETFIELD, */
/*    where the actual conversion is processed.  This function returns       */
/*    the number of characters output.                                       */
/*                                                                           */
/*****************************************************************************/
int _printfi(char **_format, va_list _ap, void *_op, 
             int (*_outc)(char, void *), int (*_outs)(char *, void *))
{
   /*------------------------------------------------------------------------*/
   /* Local Variables                                                        */
   /*                                                                        */
   /*    *end     -  A pointer to the end of the format string               */
   /*    *pfield  -  A pointer to a structure _PFIELD, which stores all of   */
   /*                flags and parameters needed to perform a conversion.    */
   /*------------------------------------------------------------------------*/
   char     *end           =  *_format + strlen(*_format);
   int      count          =  0;
   _PFIELD  pfield;

   /*------------------------------------------------------------------------*/
   /* Iterate through the format string until the end of it is reached.      */
   /*------------------------------------------------------------------------*/
   while(*_format < end)
   {
      /*---------------------------------------------------------------------*/
      /* Initialize PFIELD.                                                  */
      /*---------------------------------------------------------------------*/
      pfield.flags     = 0;
      pfield.fwidth    = 0;
      pfield.precision = -1;
      pfield.conv      = 0;

      /*---------------------------------------------------------------------*/
      /* Copy the format string directly to the target string until a '%'    */
      /* is encountered.                                                     */
      /*---------------------------------------------------------------------*/
      for(; **_format != '%' && **_format != '\0'; 
          _outc(*((*_format)++), _op), count++);

      /*---------------------------------------------------------------------*/
      /* If the end of the format string has been reached, break out of the  */
      /* while loop.                                                         */
      /*---------------------------------------------------------------------*/
      if(! (**_format)) break;

      (*_format)++;                   /* Skip to the character after the '%' */

      /*---------------------------------------------------------------------*/
      /* Process the flags immediately after the '%'.                        */
      /*---------------------------------------------------------------------*/
      _pproc_fflags(&pfield, _format);

      /*---------------------------------------------------------------------*/
      /* Convert the field width and precision into numbers.                 */
      /*---------------------------------------------------------------------*/
      _pproc_fwp(&pfield, _format, &_ap);
 
      /*---------------------------------------------------------------------*/
      /* If the h, l, or L flag was specified, set the corresponding flag    */
      /* in pfield.                                                          */
      /*---------------------------------------------------------------------*/
      switch (**_format)
      {
	  case 'L': _SET(&pfield, _MFLD); (*_format)++; break;
	  case 'h': _SET(&pfield, _MFH);  (*_format)++; break;
	  case 'l':
	  {
	      (*_format)++; 
	      if (**_format == 'l') { _SET(&pfield, _MFLL); (*_format)++; }
	      else _SET(&pfield, _MFL);
	  }
      }

      /*---------------------------------------------------------------------*/
      /* Set the conversion character in pfield.                             */
      /*---------------------------------------------------------------------*/
      pfield.conv = *((*_format)++);

      /*---------------------------------------------------------------------*/
      /* If 'n' is the conversion specifier, process it in this function,    */
      /* since it is the only one that makes no conversions.  It just stores */
      /* the number of characters printed so far into the next argument.     */
      /* Otherwise, call _SETFIELD which performs the conversion.            */
      /*---------------------------------------------------------------------*/
      if(pfield.conv == 'n')
         switch (pfield.flags & (_MFLL | _MFL | _MFH))
         {
#ifdef LLONG_MAX
                           /* The 'll' flag was specified */
            case _MFLL  :  *(va_arg(_ap, long long*)) = (long long)count;
                           break;
#endif
                           /* The 'l' flag was specified */
            case _MFL   :  *(va_arg(_ap, long*)) = (long)count;
                           break;

                           /* The 'h' flag was specified */
            case _MFH   :  *(va_arg(_ap, short*)) = (short)count;
                           break;

            default     :  *(va_arg(_ap, int*)) = (int)count;
                           break;

         }
      else if(pfield.conv == 's') 
         _pproc_str(&pfield, _op, &_ap, &count, _outs);   
      else
      {
         /*------------------------------------------------------------------*/
         /* Append the converted string to the result string, and reposition */
         /* its iterator, it2.                                               */
         /*------------------------------------------------------------------*/
	 /* Must hold the system lock to call _setfield() because it returns
	    a static buffer. */
	 _lock();
         count += _outs(_setfield(&pfield, &_ap), _op);
	 _unlock();
      }
   }

   return (count);
}


/*****************************************************************************/
/* _PPROC_FFLAGS   -  Process the format flags for a conversion              */
/*                                                                           */
/*    This function takes the flags directly after the '%' and stores them   */
/*    in the _PFIELD structure PFIELD for later reference.                   */
/*                                                                           */
/*****************************************************************************/
static void _pproc_fflags(_PFIELD *pfield, char **it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int flags_done = 0;

   /*---------------------------------------------------------------------*/
   /* Read in all of the flags associated with this conversion, and set   */
   /* the corresponding flags in the PFIELD structure.                    */
   /*---------------------------------------------------------------------*/
   while(! flags_done)
      switch (**it)
      {
         case '-' :  _SET(pfield, _PFMINUS);
                     (*it)++;
                     break;   

         case '+' :  _SET(pfield, _PFPLUS);
                     (*it)++;
                     break;

         case ' ' :  _SET(pfield, _PFSPACE);
                     (*it)++;
                     break;

         case '#' :  _SET(pfield, _PFPOUND);
                     (*it)++;
                     break;

         case '0' :  _SET(pfield, _PFZERO);
                     (*it)++;
                     break;

         default  :  flags_done = 1;
      }

   return;
}


/*****************************************************************************/
/* _PPROC_FWP   -  Convert the field width and precision from the format     */
/*                 string into numbers.                                      */
/*                                                                           */
/*    This function reads the field and precision out of the format string   */
/*    and converts them into numbers that will be stored in the _PFIELD      */
/*    structure pointed to by PFIELD.  They will be needed for future        */
/*    reference.                                                             */
/*                                                                           */
/*****************************************************************************/
static void _pproc_fwp(_PFIELD *pfield, char **it, va_list *_ap)
{
   char tmpstr[10];
   char *tmpptr;

   /*------------------------------------------------------------------------*/
   /* If a '*' was given for the field width, use the next argument as       */
   /* the field width for the conversion.  Otherwise, copy the following     */
   /* numerical characters into a temporary string, and convert that         */
   /* string into an integer, which will be used for the field width.        */
   /*------------------------------------------------------------------------*/
   if(**it == '*')
   {
      pfield->fwidth = va_arg(*_ap, int);

      /*---------------------------------------------------------------------*/
      /* If the argument given for the field width is negative, treat it as  */
      /* if the '-' flag was used, and the field width was positive.         */
      /*---------------------------------------------------------------------*/
      if(pfield->fwidth < 0) 
      {
         pfield->fwidth = -(pfield->fwidth);
         _SET(pfield, _PFMINUS);
      }

      (*it)++;
   }
   else
   {
      /*---------------------------------------------------------------------*/
      /* Initialize the temporary string and iterator that will hold the     */
      /* field width temporarily.                                            */
      /*---------------------------------------------------------------------*/
      tmpptr = tmpstr;
      memset(tmpptr, '\0', 10);

      while((**it >= '0') && (**it <= '9')) *(tmpptr++) = *((*it)++);

      if(*tmpstr != '\0') pfield->fwidth = atoi(tmpstr);
   }

   /*------------------------------------------------------------------------*/
   /* If a '.' appears as the next character, process the following          */
   /* characters as a precision.                                             */
   /*------------------------------------------------------------------------*/
   if(**it == '.')
   {
      (*it)++;

      /*---------------------------------------------------------------------*/
      /* If a '*' was given for the precision, use the next argument as      */
      /* the precision for the conversion.  Otherwise, copy the following    */
      /* numerical characters into a temporary string, and convert that      */
      /* string into an integer, which will be used for the precision.       */
      /*---------------------------------------------------------------------*/
      if(**it == '*')
      {
         pfield->precision = va_arg(*_ap, int);
         (*it)++;
      }
      else
      {
         /*------------------------------------------------------------------*/
         /* Initialize the temporary string and iterator that will hold      */
         /* the field width temporarily.                                     */
         /*------------------------------------------------------------------*/
         tmpptr = tmpstr;
         memset(tmpptr, '\0', 10);

         while((**it >= '0') && (**it <= '9'))  *(tmpptr++) = *((*it)++);

         if(*tmpstr != '\0') pfield->precision = atoi(tmpstr);
         else                pfield->precision = 0;
      }
   }
   return;
}


/*****************************************************************************/
/* _PPROC_STR  -  Processes the string conversion (%s)                       */
/*                                                                           */
/*    This function places all or a portion of the input string into the     */
/*    the temporary string.  It returns a zero, unless the input string had  */
/*    a length of zero.  In this case, a one is returned.                    */
/*                                                                           */
/*****************************************************************************/
static void _pproc_str(_PFIELD *pfield, void *_op, va_list *_ap, int *count,
                       int (*_outs)(char *, void *))
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  *strbuf;
   char  *tmpstr;
   char  *tmpptr;
   int   len, buflen;

   /*------------------------------------------------------------------------*/
   /* Get the next argument.                                                 */
   /*------------------------------------------------------------------------*/
   strbuf = va_arg(*_ap, char*);

   /*------------------------------------------------------------------------*/
   /* Handle NULL strings.                                                   */
   /*------------------------------------------------------------------------*/
   if(strbuf == NULL)
   {
      _outs("(null)", _op);
      return;
   }

   buflen = (pfield->precision >= 0 && pfield->precision < strlen(strbuf)) ?
            pfield->precision : strlen(strbuf);
   len = (pfield->fwidth > buflen) ? pfield->fwidth : buflen;
   *count += len;

   if(!(tmpstr = (char *)malloc(len + 1))) return;
   tmpptr = tmpstr;

   if(buflen < len && !_STCHK(pfield, _PFMINUS))
   {
      memset(tmpptr, ' ', (len - buflen));
      tmpptr += (len - buflen);  
   }

   strncpy(tmpptr, strbuf, buflen);
   tmpptr += buflen;

   if(buflen < len && _STCHK(pfield, _PFMINUS))
   {
      memset(tmpptr, ' ', (len - buflen));
      tmpptr += (len - buflen);
   }

   *(tmpstr + len) = '\0';

   _outs(tmpstr, _op);

   free(tmpstr);

   return;
}


/*****************************************************************************/
/* _SETFIELD   -  Performs conversions when the '%' is encountered           */
/*                                                                           */
/*    This function takes pfield, and calls the appropriate processing       */
/*    function for the conversion required in the _PFIELD structure.  It     */
/*    returns a pointer to the result string.                                */
/*                                                                           */
/*****************************************************************************/
static char *_setfield(_PFIELD *pfield, va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variable declarations, and a description of their use            */
   /*                                                                        */
   /*    FLD is a temporary string that will hold the conversion.  F_START   */
   /*    will be a pointer to the beginning of the field, and if a           */
   /*    field width was specified, F_END will be a pointer to the end of    */
   /*    the field.  This designated field is located at the beginning of    */
   /*    the string FLD.   A_END is a pointer to the end of the string FLD,  */
   /*    and this is where the primary conversion will take place.  Using    */
   /*    A_IT, an iterator beginning at the end of FLD, the number will be   */
   /*    written one digit at a time starting with the rightmost digit.      */
   /*    Using the pointer WHERE, the number in string form will be moved    */
   /*    to its appropriate place within the field after making adjustments  */
   /*    called for by various flags in the format specification (a minus    */
   /*    sign, leading zeros, etc.).  The string FLD will then be returned.  */
   /*                                                                        */
   /*    MINUS_FLAG is exactly what it says ( = 1 if number is negative).    */
   /*                                                                        */
   /*------------------------------------------------------------------------*/
   static _DATA_ACCESS char fld[_ARSIZE];

   char *f_start   =  (char *)fld;
   char *f_end     =  f_start + pfield->fwidth;
   char *a_end     =  f_start + _ARSIZE -1; 
   char *a_it      =  a_end;
   char *where;
   int  minus_flag = 0;
   int  plus_flag  = 0;

   /*------------------------------------------------------------------------*/
   /* Initialize the temporary string.  Then, since we are working from      */
   /* right to left, begin with the NULL character.                          */
   /*------------------------------------------------------------------------*/
   memset(fld, ' ', _ARSIZE);
   *(a_it--) = '\0'; 

   /*------------------------------------------------------------------------*/
   /* Call the appropriate processing function.                              */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'd' :
      case 'i' :
      case 'o' :
      case 'u' :
      case 'x' :
      case 'X' :  
      case 'p' :  _pproc_diouxp(pfield, &minus_flag, &a_it, _ap);
                  break;  

#ifndef NOFLOAT
      case 'g' :  
      case 'G' : 
      case 'e' :
      case 'E' :
      case 'f' :  _pproc_fge(pfield, &minus_flag, &a_it, _ap);
                  break;
#endif
  
      case 'c' :  *(a_it--) = va_arg(*_ap, int);
                  _UNSET(pfield, _PFPLUS);
                  break;

      case '%' :  strcpy(f_start, "%"); return((char *)fld);


   }

   plus_flag = (_STCHK(pfield, _PFPLUS) && SIGNED_CONV);

   /*------------------------------------------------------------------------*/
   /* If the number was negative, or the '+' flag was used, insert the sign. */
   /* Make sure unsigned conversions don't get a '+' sign.                   */
   /*------------------------------------------------------------------------*/
   if (minus_flag) *(a_it--) = '-';
   else if (plus_flag) *(a_it--) = '+';

   /*------------------------------------------------------------------------*/
   /* If the number was positive, the '+' flag was not used, and the ' '     */
   /* flag was used, insert a space.                                         */
   /*------------------------------------------------------------------------*/
   if(! minus_flag && ! plus_flag && _STCHK(pfield, _PFSPACE)) *(a_it--) = ' ';

   /*------------------------------------------------------------------------*/
   /* If the '-' flag was used or the resulting string is larger than the    */
   /* field, left justify the result in the array.  Otherwise right-justify  */
   /* it.                                                                    */
   /*------------------------------------------------------------------------*/
   where = (_STCHK(pfield, _PFMINUS) ||
           ((a_end - a_it) > pfield->fwidth)) ? f_start :
           (f_end - (a_end - a_it)+1);

   a_it = (char *)memccpy(where, a_it+1, '\0', _ARSIZE);

   /*------------------------------------------------------------------------*/
   /* If a resulting left-justified string is smaller than the field width,  */
   /* move the terminating NULL character to the end of the field.           */
   /*------------------------------------------------------------------------*/
   if(a_it <= f_end)
   {
      memset(a_it - 1, ' ', f_end - a_it + 1);
      *f_end = '\0';
   }

   /*------------------------------------------------------------------------*/
   /* If the '0' flag was used, and the resulting string is right-justified, */
   /* fill in the leading zeros.                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(pfield, _PFZERO))
   {
      memset(f_start, '0', (where - f_start));

      /*---------------------------------------------------------------------*/
      /* Make sure any sign or leading space is moved to the left side of    */
      /* any leading zeros.                                                  */
      /*---------------------------------------------------------------------*/
      if((minus_flag || plus_flag || _STCHK(pfield, _PFSPACE)) &&
          where != f_start)
      {
         *f_start = *where;
         *where = '0';
      }
   }
   else
      memset(f_start, ' ', (where - f_start));

   /*------------------------------------------------------------------------*/
   /* Return the result string.                                              */
   /*------------------------------------------------------------------------*/
   return ((char *)fld);                     
}


#ifndef NOFLOAT
/*****************************************************************************/
/* _PPPROC_FGE   -  Process the conversion for f, g, G, e, and E             */
/*                                                                           */
/*    This function takes the structure PFIELD, which contains all of the    */
/*    flags and parameters to process the conversion, and it does this       */
/*    conversion, and stores the result in the string pointed to by          */
/*    *A_IT.                                                                 */
/*****************************************************************************/
static void _pproc_fge(_PFIELD *pfield, int *minus_flag, char **a_it, 
                       va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   long double cvt =  0;

   /*------------------------------------------------------------------------*/
   /* Determine what kind of argument is coming next, and read it into CVT.  */
   /*------------------------------------------------------------------------*/
   switch(_STCHK(pfield, _MFLD))
   {
      case  0  :  cvt = (double)va_arg((*_ap), double);
                  break;

      default  :  cvt = va_arg((*_ap), long double);

   }

   /*------------------------------------------------------------------------*/
   /* If CVT is negative, set the MINUS_FLAG and reverse the sign of CVT.    */
   /*------------------------------------------------------------------------*/
   if((*minus_flag = (cvt < 0)) != 0) cvt = -cvt;

   /*------------------------------------------------------------------------*/
   /* Call the proper conversion function                                    */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'f' :  _pconv_f(cvt, pfield, a_it);
                  break;
      case 'e' :
      case 'E' :  _pconv_e(cvt, pfield, a_it);
                  break;
      case 'g' :
      case 'G' :  _pconv_g(cvt, pfield, a_it);
   }
}


/*****************************************************************************/
/* _PCONV_F -  Perform the %f conversion                                     */
/*****************************************************************************/
static void _pconv_f(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[400];
   int   dpt, 
         sign, 
         putdec;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   /*------------------------------------------------------------------------*/
   /* Call the FCVT float to string function, then copy the fractional part, */
   /* determine whether or not a decimal point should be placed, and copy    */
   /* whole number part.                                                     */
   /*------------------------------------------------------------------------*/
   strcpy(tmpbuf, fcvt(cvt, pfield->precision, &dpt, &sign));
   _fcpy(tmpbuf, dpt, 1, pfield->precision, a_it);
   putdec = (dpt != (int)strlen(tmpbuf) || _STCHK(pfield, _PFPOUND)) ? 1 : 0;
   _mcpy(tmpbuf, dpt, putdec, a_it);
}


/*****************************************************************************/
/* _PCONV_E -  Perform the %e conversion                                     */
/*****************************************************************************/
static void _pconv_e(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   int   dpt, 
         sign, 
         putdec, 
         exp      = 0;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   /*------------------------------------------------------------------------*/
   /* Check if CVT is within legal range -HUGE_VALL <= CVT <= HUGE_VALL      */
   /*------------------------------------------------------------------------*/
   if (cvt >= HUGE_VALL) cvt = HUGE_VALL;
   else if (cvt <= -HUGE_VALL) cvt = -HUGE_VALL;

   /*------------------------------------------------------------------------*/
   /* Convert CVT to x.xxxe+xx form, keeping the exponent in EXP.            */
   /*------------------------------------------------------------------------*/
   if(cvt)
   {
      for(;cvt < 1; cvt *= 10, exp--);
      for(;cvt >= 10; cvt /= 10, exp++);
   }

   /*------------------------------------------------------------------------*/
   /* Call the FCVT float to string function, copy the exponent part, the    */
   /* fractional part, then determine whether or not a decimal point should  */
   /* be placed, and copy the whole number part.                             */
   /*------------------------------------------------------------------------*/
   strcpy(tmpbuf, fcvt(cvt, pfield->precision, &dpt, &sign));
   if(dpt==2) /* fcvt() might have rounded the number */
   {
       dpt--; exp++; tmpbuf[strlen(tmpbuf)-1] = 0;
   }
   _ecpy(exp, pfield->conv, a_it);
   _fcpy(tmpbuf, dpt, 1, pfield->precision, a_it);
   putdec = (dpt != (int)strlen(tmpbuf) || _STCHK(pfield, _PFPOUND)) ? 1 : 0;
   _mcpy(tmpbuf, dpt, putdec, a_it);
}


/*****************************************************************************/
/* _PCONV_G -  Perform the %g conversion                                     */
/*****************************************************************************/
static void _pconv_g(long double cvt, _PFIELD *pfield, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[100];
   char  *check;
   int   dpt, 
         sign, 
         putdec, 
         exp         = 0, 
         change_test = 0;

   /*------------------------------------------------------------------------*/
   /* If the precision was given as 0, set it to one.                        */
   /*------------------------------------------------------------------------*/
   if(pfield->precision == 0) pfield->precision = 1;

   /*------------------------------------------------------------------------*/
   /* If no precision was specified, set it to 6.                            */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 6;

   strcpy(tmpbuf, ecvt(cvt, pfield->precision, &dpt, &sign));

   /*------------------------------------------------------------------------*/
   /* If the exponent is less than -4, or greater than or equal to the       */
   /* precision, convert the number as a %e conversion.  Otherwise convert   */
   /* it as a %f conversion.                                                 */
   /*------------------------------------------------------------------------*/
   if(dpt < -3 || dpt > pfield->precision)
   {
      for(;dpt > 1; dpt--, exp++);
      for(;dpt < 1; dpt++, exp--);

      _ecpy(exp, pfield->conv-2, a_it);
   }

   /*------------------------------------------------------------------------*/
   /* Copy the fractional part of the number.  CHANGE_TEST will be set if    */
   /* there was a fractional part, otherwise it will remain a zero.          */
   /*------------------------------------------------------------------------*/
   check = *a_it;
   _fcpy(tmpbuf, dpt, (_STCHK(pfield, _PFPOUND)) ? 1 : 0, pfield->precision,
         a_it);
   change_test = (check != *a_it);

   /*------------------------------------------------------------------------*/
   /* If the '#' flag was used, or there was a fractional part to the number */
   /* a decimal point will be placed.                                        */
   /*------------------------------------------------------------------------*/
   putdec = (_STCHK(pfield, _PFPOUND) || change_test) ? 1 : 0;

   _mcpy(tmpbuf, dpt, putdec, a_it);

}


/*****************************************************************************/
/* _FCPY -  Copy the fraction part of a float to a string                    */
/*****************************************************************************/
static char *_fcpy(const char *tmpbuf, int dpt, int trail, int precision, 
                   char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   i;
   char  *tmpptr = (char *)tmpbuf + strlen(tmpbuf) -1;

   /*------------------------------------------------------------------------*/
   /* Fill all unused precision spaces with zeros.                           */
   /*------------------------------------------------------------------------*/
   for(i = 0; i < precision && dpt > (int)strlen(tmpbuf) && trail; i++)
      *((*a_it)--) = '0';
 
   /*------------------------------------------------------------------------*/
   /* Copy the fractional part of the float into the string.                 */
   /*------------------------------------------------------------------------*/
   if(dpt < (int)strlen(tmpbuf) && dpt >= 0)
   {
      i = (int)strlen(tmpbuf) - dpt;

      /*---------------------------------------------------------------------*/
      /* Skip trailing zeros if TRAIL is not set.                            */
      /*---------------------------------------------------------------------*/
      if(! trail) for(; i > 0 && *tmpptr == '0'; tmpptr--, i--);

      for(; i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;

   }

 
   /*------------------------------------------------------------------------*/
   /* Place any leading fractional zeros if necessary.                       */
   /*------------------------------------------------------------------------*/
   if(dpt < 0)
   {
      if (-dpt < precision)
          for(i = strlen(tmpbuf); i > 0; tmpptr--, i--) *((*a_it)--) = *tmpptr;
      if (-dpt > precision) dpt = -precision;
      for(i = -dpt; i > 0; i--) *((*a_it)--) = '0';
   }

   return (*a_it);
}


/*****************************************************************************/
/* _ECPY -  Copy the "e+xx" part of a float to a string                      */
/*****************************************************************************/
static char *_ecpy(int exp, char letter, char **a_it)
{
   _ltostr((exp > 0) ? exp : -exp, 10, 'd', a_it);
   if(exp < 10 && exp > -10) *((*a_it)--) = '0';
   *((*a_it)--) = (exp < 0) ? '-' : '+';
   *((*a_it)--) = letter;

   return (*a_it);
}


/*****************************************************************************/
/* _MCPY -  Copy the whole number part of a float to a string                */
/*****************************************************************************/
static char *_mcpy(const char *tmpbuf, int dpt, int putdec, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int   i;
   char  *tmpptr = NULL;

   /*------------------------------------------------------------------------*/
   /* If the number has both a whole number part and a fractional part,      */
   /* position TMPPTR to the last character of the whole number.             */
   /*------------------------------------------------------------------------*/
   if(dpt > 0 && dpt <= (int)strlen(tmpbuf)) tmpptr = (char *)tmpbuf + dpt -1;

   /*------------------------------------------------------------------------*/
   /* Place a decimal point if PUTDEC is set.                                */
   /*------------------------------------------------------------------------*/
   if(putdec) *((*a_it)--) = '.';

   /*------------------------------------------------------------------------*/
   /* Place any whole number trailing zeros.                                 */
   /*------------------------------------------------------------------------*/
   for(i = dpt; i > (int)strlen(tmpbuf); i--) *((*a_it)--) = '0';

   /*------------------------------------------------------------------------*/
   /* Copy the rest of the whole number.                                     */
   /*------------------------------------------------------------------------*/
   if(i > 0) for(; tmpptr >= tmpbuf; tmpptr--) *((*a_it)--) = *tmpptr;
   else *((*a_it)--) = '0';

   return (*a_it);
}
#endif


/*****************************************************************************/
/* _PPROC_DIOUXP   -  Process the conversion for d, i, o, u, x, and p        */
/*                                                                           */
/*    This function takes the structure PFIELD, which contains all of the    */
/*    flags and parameters to process the conversion, and it does this       */
/*    conversion, and stores the result in the string pointed to by          */
/*    *A_IT.                                                                 */
/*                                                                           */
/*****************************************************************************/
static int _pproc_diouxp(_PFIELD *pfield, int *minus_flag, char **a_it, 
                         va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int digits =  0;
   int base   = 10;
   uintmax_t cvt;

   /*------------------------------------------------------------------------*/
   /* If no precision was given, set it to 1.                                */
   /*------------------------------------------------------------------------*/
   if(pfield->precision < 0) pfield->precision = 1; 
   else                      _UNSET(pfield, _PFZERO);

   /*------------------------------------------------------------------------*/
   /* Set the base of the number by the type of conversion specified.        */
   /*------------------------------------------------------------------------*/
   switch(pfield->conv)
   {
      case 'p' :
      case 'x' :
      case 'X' :  base = 16;
                  break;

      case 'o' :  base = 8;
                  break;

      default  :
      case 'u' :
      case 'd' :
      case 'i' :  base = 10;
  	          break;
   }  

   /*------------------------------------------------------------------------*/
   /* Get the next argument.                                                 */
   /*------------------------------------------------------------------------*/
   cvt = _getarg_diouxp(pfield, _ap);

   /*------------------------------------------------------------------------*/
   /* If the precision is 0, and the number is 0, do nothing and return 1.   */
   /*------------------------------------------------------------------------*/
   if(pfield->precision == 0 && cvt == 0) return 1;

   /*------------------------------------------------------------------------*/
   /* If the number is signed and negative, set the minus sign flag, and     */
   /* negate the number.                                                     */
   /*------------------------------------------------------------------------*/
   if((pfield->conv == 'd' || pfield->conv == 'i')
      && ((intmax_t)cvt < 0))
   {
      *minus_flag = 1;
      cvt = -(intmax_t)cvt;
   }

   /*------------------------------------------------------------------------*/
   /* Call the function to convert the number to a string, and add the       */
   /* total number of digits assigned into DIGITS.                           */
   /*------------------------------------------------------------------------*/
   digits += _ltostr(cvt, base, pfield->conv, a_it);

   /*------------------------------------------------------------------------*/
   /* Fill in the remainder of the precision with zeros.                     */
   /*------------------------------------------------------------------------*/
   while(digits++ < pfield->precision) *((*a_it)--) = '0';


   /*------------------------------------------------------------------------*/
   /* If the "#" flag was used in the X or x conversion, prefix a "0x" or    */
   /* "0X" to the hexadecimal number.                                        */
   /*------------------------------------------------------------------------*/
   if((pfield->conv == 'x' || pfield->conv == 'X') && _STCHK(pfield, _PFPOUND))
   {
      *((*a_it)--) = pfield->conv;
      *((*a_it)--) = '0';
   }

   /*------------------------------------------------------------------------*/
   /* If the "#' flag was used in the o conversion, prefix a "0" to the      */
   /* octal number.                                                          */
   /*------------------------------------------------------------------------*/
   if(pfield->conv == 'o' && _STCHK(pfield, _PFPOUND)) *((*a_it)--) = '0';

   return (0);

}


/*****************************************************************************/
/* _GETARG_DIOUXP -  Get the argument for a d, i, o, u, x, or p conversion   */
/*                                                                           */
/*    This function takes the next argument off the argument list, after     */
/*    determining what kind of argument it is.  It decides this by checking  */
/*    to see if the 'h' or the 'l' flag was used.  It returns the next       */
/*    argument.                                                              */
/*****************************************************************************/
static uintmax_t _getarg_diouxp(_PFIELD *pfield, va_list *_ap)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   uintmax_t cvt = 0;

   if (pfield->conv == 'p') cvt = (uintmax_t)va_arg(*_ap, void *);
   else
   /*------------------------------------------------------------------------*/
   /* Get the number from the next argument.  Determine what kind of         */
   /* argument by checking for the h or l flag in the format specification.  */
   /*------------------------------------------------------------------------*/
   switch(_STCHK(pfield, (_MFH | _MFL | _MFLL)))
   {
      case _MFH   :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : 
			    cvt = va_arg(*_ap, int);
			    break;
			    
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : 
			    cvt = (unsigned short) va_arg(*_ap, unsigned int);
                     }
                     break;

      case _MFL   :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : 
			    cvt = va_arg(*_ap, long int);
			    break;

                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : 
			    cvt = va_arg(*_ap, unsigned long int);
                     }
                     break;
#ifdef LLONG_MAX
      case _MFLL  :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : 
			    cvt = va_arg(*_ap, long long int);
			    break;

                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' : 
			    cvt = va_arg(*_ap, unsigned long long int);
                     }
                     break;
#endif   
      default     :  switch(pfield->conv)
                     {
                        case 'd' :
                        case 'i' : 
			    cvt = va_arg(*_ap, int);
			    break;
 
                        case 'o' :
                        case 'u' :
                        case 'x' :
                        case 'X' :
			    cvt = va_arg(*_ap, unsigned int);
                     }
   }

   return (cvt);
}


/*****************************************************************************/
/* _LTOSTR  -  Convert an integer to a string of up to base 16               */
/*                                                                           */
/*    This function takes an uintmax_t integer, converts it to a string      */
/*    which is pointed to by *A_IT.  The result will also be converted to    */
/*    a base corresponding to the variable base.                             */
/*                                                                           */
/*****************************************************************************/
static int _ltostr(uintmax_t cvt, int base, char conv, char **a_it)
{
   /*------------------------------------------------------------------------*/
   /* Local Variables                                                        */
   /*------------------------------------------------------------------------*/
   uintmax_t  quot,
              rem;
       char  *bnum = "0123456789abcdef0123456789ABCDEF";

   /*------------------------------------------------------------------------*/
   /* The number CVT will be converted to a string by taking the remainder   */
   /* of a division of it by its base, and converting it to a character.     */
   /* The number CVT is then set equal to itself divided by its base, and    */
   /* this continues until CVT is 0.                                         */
   /*------------------------------------------------------------------------*/

   if(! cvt) *((*a_it)--) = '0';

   while(cvt)
   {
      quot = _div(cvt, base);
      rem = cvt - (quot * base);

      if(conv == 'X') rem += 16;

      *((*a_it)--) = bnum[rem];
      cvt = quot;
   }

   return (strlen(*a_it) - 1);
}


/*****************************************************************************/
/* _DIV  -  Divide two integers                                              */
/*                                                                           */
/*    This function takes a uintmax_t, and divides it by an integer.         */
/*    Division must take place in unsigned arithmetic, because signed '/'    */
/*    can overflow.  This function is used by _LTOSTR when it is converting  */
/*    an unsigned int to a string.                                           */
/*                                                                           */
/*****************************************************************************/
static uintmax_t _div(uintmax_t cvt, int base)
{
    /*-----------------------------------------------------------------------*/
    /* Use shifts to optimize power-of-two bases                             */
    /*-----------------------------------------------------------------------*/
    switch(base)
    {
	case  8: return cvt >> 3;
	case 16: return cvt >> 4;
    }

    /*-----------------------------------------------------------------------*/
    /* Perform divide in narrowest arithmetic possible, for speed.	     */
    /*-----------------------------------------------------------------------*/
         if (cvt < UINT_MAX)  return (unsigned int)cvt / base;
    else if (cvt < ULONG_MAX) return (unsigned long)cvt / base;
    else return cvt / base;
}

_scanfi.c/      1202506625  0     0     0       35155     `
/*****************************************************************************/
/*  _SCANFI.C v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the main routines that all three variations of the  */
/*    scanf function use.  The main function in the file is _scanfi, and     */
/*    the other functions here are called by it.                             */
/*                                                                           */
/* FUNCTIONS:                                                                */
/*    _scanfi        -  The main scanf handling routine                      */
/*    _sget_conv     -  Read the format flags into the _SFIELD pointer sfield*/
/*    _sget_scanset  -  Read in the scanset from the format statement        */
/*    _sproc_int     -  Read an integer string into a temporary string       */
/*    _sproc_float   -  Read a float string into a temporary string          */
/*    _sproc_str     -  Copy a string from the input source to a temporary   */
/*                      string                                               */
/*    _sproc_lb      -  Process the %[ conversion                            */
/*    _sset_arg      -  Assign the converted value to the next argument      */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#ifdef LLONG_MAX
_CODE_ACCESS long long strtoll(const char *_st, char **_endptr, int _base);
_CODE_ACCESS unsigned long long strtoull(const char *_st, char **_endptr,
					 int _base);
#endif

_CODE_ACCESS long double strtold(const char *st, char **endptr);

static int _sget_conv(char **_format, _SFIELD *sfield);
static int _sget_scanset(_SFIELD *sfield, char **_format);
static int _sproc_int(int w_counter, int (*_inpchar)(void **inp),
                       void (*_uninpchar)(void **inp, int outchar),
                       char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_float(int w_counter, int (*_inpchar)(void **inp),
                         void (*_uninpchar)(void **inp, int outchar),
                         char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_str(int w_counter, int (*_inpchar)(void **inp),
                       void (*_uninpchar)(void **inp, int outchar),
                       char *tmpptr, char conv, void **inp, int *num_read);
static int _sproc_lb(int (*_inpchar)(void **inp),
                      void (*_uninpchar)(void **inp, int outchar),
                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read);
static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf);

/*****************************************************************************/
/* _SCANFI  -  The main scanf handling routine                               */
/*                                                                           */
/*    This function parses all non-conversion characters in the format       */
/*    string, passes control to the appropriate function when a '%' is       */
/*    encountered, then calls _SSET_ARG, which assignes the result to the    */
/*    next argument.                                                         */
/*                                                                           */
/*****************************************************************************/
int _scanfi(void *inp, const char *_format, va_list _ap, 
            int (*_chkmbc)(void **inp, char **_format, int *num_read),
            int (*_inpchar)(void **inp), 
            void (*_uninpchar)(void **inp, int outchar))
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   _SFIELD  sfield;
   char     tmpbuf[256],
           *tmpptr,
           *f_ptr        = (char *)_format;
   int      num_assigned =  0,
            inchar,
            num_read     =  0,
            stat         =  0;

   /*------------------------------------------------------------------------*/
   /* If the first character in the format string is a white space character */
   /* parse the format string until a non-white space character is found.    */
   /* Do the same for the input, but put the first non-white space character */
   /* back onto the input stream when finished.                              */
   /*------------------------------------------------------------------------*/
   if (isspace(*f_ptr))
   {
      for(;isspace(*f_ptr);f_ptr++);

      inchar = _inpchar(&inp);
      if(inchar == EOF) return EOF;
      num_read++;

      for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);

      _uninpchar(&inp, inchar);
      num_read--;

      if(inchar == EOF) return EOF;
   }

   while(1)
   {
      /*---------------------------------------------------------------------*/
      /* Initialize sfield                                                   */
      /*---------------------------------------------------------------------*/
      memset(&sfield, 0, sizeof(_SFIELD));
      sfield.fwidth = -1;

      /*---------------------------------------------------------------------*/
      /* Call _chkmbc to compare the format string to the input.  If a       */
      /* mismatch occurs, return an EOF, if the end of the format string     */
      /* is reached, return the number of arguments assigned.  Otherwise     */
      /* a '%' has been encountered, so call _sget_conv to process it.       */
      /*---------------------------------------------------------------------*/
      switch(_chkmbc(&inp, &f_ptr, &num_read))
      {
         case  EOF   : return (EOF);
   
         case  0     : return (num_assigned);
   
         case  1     :  _sget_conv(&f_ptr, &sfield);
   
      }
   
      tmpptr = tmpbuf;

      /*---------------------------------------------------------------------*/
      /* Unless the conversion specifier is a [, c, or n, skip to the next   */
      /* non-white space character in the input.                             */
      /*---------------------------------------------------------------------*/
      if (sfield.conv != '[' && sfield.conv != 'c' && sfield.conv != 'n')
      {
         inchar = _inpchar(&inp);
         num_read++;
    
         for(;isspace(inchar); inchar = _inpchar(&inp), num_read++);
    
         _uninpchar(&inp, inchar);
         num_read--;

         /*---------------------------------------------------------------*/
         /* If we've encountered the end of the stream AND we haven't     */
         /* matched anything yet, return EOF.                             */
         /*---------------------------------------------------------------*/
         if(inchar == EOF && num_read == 0) return EOF;
      }
      else
      {
         /*---------------------------------------------------------------*/
         /* If we've encountered the end of the stream AND we haven't     */
         /* matched anything yet, return EOF.                             */
         /*---------------------------------------------------------------*/
         inchar = _inpchar(&inp);
         _uninpchar(&inp, inchar);
         if(inchar == EOF && num_read == 0) return EOF;
      }

      /*---------------------------------------------------------------------*/
      /* The flags have been set in sfield, so process the conversion by     */
      /* calling the appropriate function.                                   */
      /*---------------------------------------------------------------------*/
      switch(sfield.conv)
      {
         case  'X'   :  sfield.conv = 'x';
         case  'i'   :
         case  'p'   :  
         case  'x'   :
         case  'u'   :
         case  'o'   :
         case  'd'   :  stat = _sproc_int(sfield.fwidth, _inpchar, _uninpchar, 
                                         tmpptr, sfield.conv, &inp, &num_read); 
                        break;
         case  'f'   :
         case  'e'   :
         case  'E'   :
         case  'g'   :
         case  'G'   :  stat = _sproc_float(sfield.fwidth, _inpchar, _uninpchar,
                                     tmpptr, sfield.conv, &inp, &num_read);
                        break;

         case  'c'   :  
         case  's'   : {
                          char *stptr = (sfield.flags & _SFSTAR) ?
                                         NULL : va_arg(_ap, char*);

                          stat = _sproc_str(sfield.fwidth, _inpchar, _uninpchar,
                                     stptr, sfield.conv, &inp, &num_read);
                       }
                       stat = (stat != EOF);
                       if (!(sfield.flags & _SFSTAR) && stat) num_assigned++;
                       break;

         case  '['   :  stat = _sproc_lb(_inpchar, _uninpchar, tmpptr, &sfield,
                                         &inp, &num_read);

      }

      stat = (stat != EOF);

      /*---------------------------------------------------------------------*/
      /* Now, call the function to handle the actual assignment, or if there */
      /* is no assignment to take place, process it here.                    */
      /*---------------------------------------------------------------------*/
      switch(sfield.conv)
      {
         case  'i'   :
         case  'd'   :  
         case  'x'   :
         case  'u'   :
         case  'o'   :  
         case  'p'   : 
         case  'e'   :
         case  'f'   :
         case  'g'   :
         case  'E'   :
         case  'G'   :  _sset_arg(&sfield, &_ap, tmpbuf);
                        if ((!(sfield.flags & _SFSTAR)) && stat) num_assigned++;
                        break;
 
         case  'n'   :  if (!(sfield.flags & _SFSTAR))
                           switch(sfield.flags & (_MFH | _MFL | _MFLL))
                           {
                              case  _MFH  :  *(va_arg(_ap, short int*)) =
                                             (short int)num_read;
                                             break;
 
                              case _MFL   :  *(va_arg(_ap, long int*)) =
                                             (long int)num_read;
                                             break;
#ifdef LLONG_MAX
                              case _MFLL  :  *(va_arg(_ap, long long int*)) =
                                             (long long int)num_read;
                                             break;
#endif
                              default     :  *(va_arg(_ap, int*)) =
                                             num_read;
                                             break;
                           }
                        break;

         case  '%'   :  inchar = _inpchar(&inp);
                        if (inchar != '%') return (EOF);
                        else num_read++;
                        break;
                              
         case  '['   :  if ((!(sfield.flags & _SFSTAR)) && stat)
                        {
                           strcpy(va_arg(_ap, char *), tmpbuf);
                           num_assigned++;
                        }
      }
   }

}

/*****************************************************************************/
/* _SGET_CONV  -  Read the format flags into the _SFIELD pointer sfield      */
/*                                                                           */
/*    This function reads the characters directly after the '%' character,   */
/*    and stores them as flags in sfield, a pointer to a _SFIELD structure.  */
/*    These flags will later be used to process the conversion.              */
/*                                                                           */
/*****************************************************************************/
static int _sget_conv(char **_format, _SFIELD *sfield)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  tmpbuf[8],
         *tmpptr     =  tmpbuf,
         *strend     =  (*_format) + strlen(*_format);

   (*_format)++;                        /* Go to the character after the '%' */

   /*------------------------------------------------------------------------*/
   /* If the next character in the format statement is a '*', set the        */
   /* _SFSTAR flag in sfield                                                 */
   /*------------------------------------------------------------------------*/
   if (**_format == '*')
   {
      _SET(sfield, _SFSTAR);
      (*_format)++;
   }
 
   /*------------------------------------------------------------------------*/
   /* If numerical characters follow, read them into a temporary string,     */
   /* convert it into a number, and store it as the field width in sfield    */
   /*------------------------------------------------------------------------*/
   for(;**_format >= '0' && **_format <= '9'; *(tmpptr++) = *((*_format)++));
   *tmpptr = '\0';
 
   if (strlen(tmpbuf)) sfield->fwidth = atoi(tmpbuf);
 
   /*------------------------------------------------------------------------*/
   /* Set the h, l, or L flags if they were specified                        */
   /*------------------------------------------------------------------------*/
   switch(**_format)
   {
       case 'L': _SET(sfield, _MFLD); (*_format)++; break;
       case 'h': _SET(sfield, _MFH);  (*_format)++; break;
       case 'l': 
       {
	   (*_format)++;
	   if (**_format == 'l') { _SET(sfield, _MFLL); (*_format)++; }
	   else _SET(sfield, _MFL);
       }
   }

   /*------------------------------------------------------------------------*/
   /* Read in the last character as the conversion specifier                 */
   /*------------------------------------------------------------------------*/
   sfield->conv = *((*_format)++);

   /*------------------------------------------------------------------------*/
   /* For the '[' conversion, read in the scanset.  Return an EOF if         */
   /* _SGET_SCANSET fails.                                                   */
   /*------------------------------------------------------------------------*/
   if ((sfield->conv == '[') && _sget_scanset(sfield, _format)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If we read past the end of the format string, return an error          */
   /*------------------------------------------------------------------------*/
   if (*_format > strend) return (EOF);
   else return (0);
}

/*****************************************************************************/
/* _SGET_SCANSET  -  Read in the scanset from the format statement           */
/*                                                                           */
/*    This function is called when the '[' conversion specifier has been     */
/*    encountered.  It reads in the scanset from the format statement,       */
/*    and stores it in sfield for later reference during the conversion.     */
/*                                                                           */
/*****************************************************************************/
static int _sget_scanset(_SFIELD *sfield, char **_format)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char  *tmpptr  =  sfield->scanset;

   if (**_format == '^')
   {
      _SET(sfield, _SFCIRC);
      (*_format)++;
   }

   if (**_format == ']') *(tmpptr++) = *((*_format)++);

   while(**_format != ']' && **_format != '\0') *(tmpptr++) = *((*_format)++);

   *tmpptr = '\0';
   if (**_format == ']') (*_format)++;
   if (**_format == '\0') return (EOF);

   return(0);
}

/*****************************************************************************/
/* _SPROC_INT  -  Read an integer string into a temporary string             */
/*                                                                           */
/*    This function takes the next integer in character form from the        */
/*    current input source, and copies it into a temporary string, where     */
/*    it can later be converted into a numerical value.                      */
/*                                                                           */
/*****************************************************************************/
static int _sproc_int(int w_counter, int (*_inpchar)(void **inp), 
                       void (*_uninpchar)(void **inp, int outchar), 
                       char *tmpptr, char conv, void **inp, int *num_read) 
{
   /*------------------------------------------------------------------------*/
   /* Note: w_counter is a parameter that holds the field width.  When       */
   /*       the number of digits specified by w_counter has been read from   */
   /*       input, the function finishes.  w_counter is checked before each  */
   /*       read to make sure that it is not equal to zero, and it is        */
   /*       decremented after each read.  If no field width was specified,   */
   /*       w_counter will be equal to -1, in which case it will never       */
   /*       equal zero, and the function will read from input until it       */
   /*       encounters the first invalid character.                          */
   /*------------------------------------------------------------------------*/

   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char inchar;
   int bnum_read = *num_read;

   /*------------------------------------------------------------------------*/
   /* Read in the next character                                             */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a sign for the number               */
   /*------------------------------------------------------------------------*/
   if ((inchar == '+' || inchar == '-') && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }


   /*------------------------------------------------------------------------*/
   /* Accept a leading '0' for an octal number, or a '0x' or '0X' for a      */
   /* hexadecimal number.                                                    */
   /*------------------------------------------------------------------------*/
   if ((conv == 'o' || conv == 'i' || conv =='x' || conv == 'p') && 
      w_counter != 0 && inchar == '0')
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   if ((conv == 'x' || conv == 'p' || conv == 'i') && w_counter != 0 &&
     (inchar == 'x' || inchar == 'X'))
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   /*------------------------------------------------------------------------*/
   /* Accept digits 0-9 for decimal numbers, or 0-F for hexadecimal numbers  */
   /*------------------------------------------------------------------------*/
   while(((inchar >= '0' && inchar <= '9') || 
          ((conv == 'x' || conv == 'p' || conv == 'i') &&
          ((inchar >= 'A' && inchar <= 'F') ||
          (inchar >= 'a' && inchar <= 'f')))) && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }

   _uninpchar(inp, inchar);
   (*num_read)--;

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}

/*****************************************************************************/
/* _SPROC_FLOAT   -  Read a float string into a temporary string             */
/*                                                                           */
/*    This function takes the next float in character form from the          */
/*    current input source, and copies it into a temporary string, where     */
/*    it can later be converted into a numerical value.                      */
/*                                                                           */
/*****************************************************************************/
static int _sproc_float(int w_counter, int (*_inpchar)(void **inp), 
                         void (*_uninpchar)(void **inp, int outchar), 
                         char *tmpptr, char conv, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Note: w_counter is a parameter that holds the field width.  When       */
   /*       the number of digits specified by w_counter has been read from   */
   /*       input, the function finishes.  w_counter is checked before each  */
   /*       read to make sure that it is not equal to zero, and it is        */
   /*       decremented after each read.  If no field width was specified,   */
   /*       w_counter will be equal to -1, in which case it will never       */
   /*       equal zero, and the function will read from input until it       */
   /*       encounters the first invalid character.                          */
   /*------------------------------------------------------------------------*/
 
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char  inchar;
   int          invalid   = 0;
   int          bnum_read = *num_read;
   int          dec_flag  =  0;
   int          e_flag    =  0;

   /*------------------------------------------------------------------------*/
   /* Read in the next character                                             */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a sign                              */
   /*------------------------------------------------------------------------*/
   if ((inchar == '+' || inchar == '-') && w_counter != 0)
   {
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
      w_counter--;
   }
 
   /*------------------------------------------------------------------------*/
   /* Accept the next character if it is a numerical digit.                  */
   /* The characters '.', 'e', 'E', '+', and '-' are accepted under the      */
   /* following conditions:                                                  */
   /*                                                                        */
   /* '.'         :  a '.', an 'e', or an 'E' has not yet been encountered   */
   /* 'e' or 'E'  :  neither of these characters have been encounterd yet    */
   /* '+' or '-'  :  If the last character read was an 'E' or an 'e'         */
   /*------------------------------------------------------------------------*/
   while((inchar >= '0' && inchar <= '9') || inchar == '.' || inchar == 'e'
          || inchar == 'E' || inchar == '+' || inchar == '-')
   {

      switch(inchar)
      {
         case  '.'   :  if (dec_flag || e_flag) { invalid = 1; break; } 
                        else dec_flag = 1;
                        break;

         case  'e'   :
         case  'E'   :  if (e_flag) { invalid = 1; break; }
                        else e_flag = 1;
                        break;

         case  '+'   :  
         case  '-'   :  if (*(tmpptr-1) != 'E' && *(tmpptr-1) != 'e')
                        { invalid = 1; break; }
      }

      if (invalid) break;
      *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      if (inchar != EOF) (*num_read)++;
      w_counter--;
   }

   _uninpchar(inp, inchar);
   if (inchar != EOF) (*num_read)--;

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}

/*****************************************************************************/
/* _SPROC_STR  -  Copy a string from the input source to a temporary string  */
/*                                                                           */
/*    This function takes a string from the input source, and copies it      */
/*    into a temporary string, to be later assigned to a scanf argument.     */
/*                                                                           */
/*****************************************************************************/
static int _sproc_str(int w_counter, int (*_inpchar)(void **inp), 
                       void (*_uninpchar)(void **inp, int outchar), 
                       char *tmpptr, char conv, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char inchar;
   int bnum_read = *num_read;

   /*------------------------------------------------------------------------*/
   /*	If no precision was given for the %c conversion, set it to one.        */
   /*------------------------------------------------------------------------*/
   if ((conv == 'c') && (w_counter < 0)) w_counter = 1;

   /*------------------------------------------------------------------------*/
   /* Read in the next character, then while that character is not a white   */
   /* space character, a null terminator, an EOF character, and the field    */
   /* width has not been exceeded, copy it to the temporary string, and      */
   /* get another character.                                                 */
   /*------------------------------------------------------------------------*/
   inchar = _inpchar(inp);
   (*num_read)++;

   while((conv == 'c' || !isspace(inchar)) && inchar != '\0' &&
         inchar != EOF && w_counter--)
   { 
      if (tmpptr) *(tmpptr++) = inchar;
      inchar = _inpchar(inp);
      (*num_read)++;
   }
   
   /*------------------------------------------------------------------------*/
   /* The %s conversion specifies that a null terminator be placed at the    */
   /* end of the conversion.                                                 */
   /*------------------------------------------------------------------------*/
   if (conv == 's' && tmpptr) *tmpptr = '\0';

   _uninpchar(inp, inchar);
   (*num_read)--;

   if (bnum_read == *num_read) return(EOF);
   return(1);
}

/*****************************************************************************/
/* _SPROC_LB   -  Process the %[ conversion                                  */
/*                                                                           */
/*    This function copies characters from the input stream into a           */
/*    temporary string until it satisfies the field width, or encounters a   */
/*    character that is not in the scanset.  The scanset is defined as the   */
/*    characters passed between the left and right brackets.  If a '^' is    */
/*    first character after the left bracket, then the scanset is every      */
/*    character that is not listed between the two brackets.                 */
/*                                                                           */
/*****************************************************************************/
static int _sproc_lb(int (*_inpchar)(void **inp), 
                      void (*_uninpchar)(void **inp, int outchar),
                      char *tmpptr, _SFIELD *sfield, void **inp, int *num_read)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   signed char  inchar;
   int          bnum_read = *num_read;
   int          w_counter =  sfield->fwidth;
   int          test;

   inchar = _inpchar(inp);
   (*num_read)++;

   for (; w_counter != 0 && inchar != EOF; w_counter--)
   {
      test = (strrchr(sfield->scanset, inchar) != NULL);
      if (_STCHK(sfield, _SFCIRC)) test = !test;
             
      if (test)
      {
         *(tmpptr++) = inchar;
         inchar = _inpchar(inp);
         (*num_read)++;
      }
      else
      {
         _uninpchar(inp, inchar);
         (*num_read)--;
         break;
      }
   }

   *tmpptr = '\0';

   if (bnum_read == *num_read) return(EOF);
   return(1);
}

/*****************************************************************************/
/* _SSET_ARG   -  Assign the converted value to the next argument            */
/*                                                                           */
/*    This function takes a pointer to the result conversion string, and     */
/*    assigns it to the next argument.  The type of argument to be assigned  */
/*    is determined by the conversion specifier, and the h, l, or L flags    */
/*    if they were used.                                                     */
/*                                                                           */
/*****************************************************************************/
static void _sset_arg(_SFIELD *sfield, va_list *_ap, char *tmpbuf)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int base;

   /*------------------------------------------------------------------------*/
   /* Do the assignment only if the result string has a length greater than  */
   /* zero, and the '*' flag was not used                                    */
   /*------------------------------------------------------------------------*/
   if (tmpbuf[0] != '\0' && !_STCHK(sfield, _SFSTAR))
      switch(sfield->conv)
      {
         case  'i'   :
         case  'd'   :  base = (sfield->conv == 'd') ? 10 : 0;
	      
	                switch(_STCHK(sfield, (_MFH | _MFL | _MFLL)))        
                        {
                           case  _MFH  :  *(va_arg(*_ap, short int*)) =
                                          (short int)strtol(tmpbuf, NULL,
                                          base);
                                          break;

                           case _MFL   :  *(va_arg(*_ap, long int*)) =
                                          strtol(tmpbuf, NULL, base);
                                          break;
#ifdef LLONG_MAX
                           case _MFLL  :  *(va_arg(*_ap, long long int*)) =
                                          strtoll(tmpbuf, NULL, base);
                                          break;
#endif
                           default     :  *(va_arg(*_ap, int*)) =
                                          (int)strtol(tmpbuf, NULL, base);
                                          break;
                        }
                        break;

      /*---------------------------------------------------------------------*/
      /* Suppress "conversion from integer to smaller pointer" warning for   */
      /* the %p case.                                                        */
      /*---------------------------------------------------------------------*/
#pragma DIAGNOSTIC_SUPPRESS(1107)
      case  'p'   :  *(va_arg(*_ap, void **))=(void *)strtoul(tmpbuf, NULL, 16);
		     break;
#pragma DIAGNOSTIC_RESET(1107)

      case  'x'   :
      case  'u'   :
      case  'o'   :  base = (sfield->conv == 'u') ? 10 :
                            (sfield->conv == 'x') ? 16 : 8;

                      switch(_STCHK(sfield, (_MFH | _MFL | _MFLL)))
                     {
                        case _MFH : *(va_arg(*_ap, unsigned short int*))=
                                    (unsigned short int)strtoul(tmpbuf,
                                    NULL, base);
                                    break;

                        case _MFL : *(va_arg(*_ap, unsigned long int*)) =
                                    strtoul(tmpbuf, NULL, base);
                                    break;
#ifdef LLONG_MAX
                        case _MFLL: *(va_arg(*_ap, unsigned long long int*)) =
                                    strtoull(tmpbuf, NULL, base);
                                    break;
#endif
                        default   : *(va_arg(*_ap, unsigned int*)) =
                                    (unsigned int)strtoul(tmpbuf, NULL,
                                    base);
                                    break;
                     }
                     break;

      case  'e'   :
      case  'f'   :
      case  'g'   :
      case  'E'   :
      case  'G'   :  switch(_STCHK(sfield, (_MFL | _MFLD)))
                     {
                        case _MFL : *(va_arg(*_ap, double*))=
                                    strtod(tmpbuf, NULL);
                                    break;

                        case _MFLD: *(va_arg(*_ap, long double*)) =
                                    strtold(tmpbuf, NULL);
                                    break;

                        default   : *(va_arg(*_ap, float*)) =
                                    (float)strtod(tmpbuf, NULL);
                                    break;
                     }
                     break;

   }
}

abs.c/          1202506626  0     0     0       562       `
/*****************************************************************************/
/* abs     v2.70                                                             */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include "stdlib.h"

/* NOTE: ABS(), LABS(), and LLABS() ARE BUILTIN FUNCTIONS  */
int  	  abs (int i)        { return abs(i);  }  
long 	  labs(long i)       { return labs(i); }  
long long llabs(long long i) { return llabs(i); } 
access.h/       1202506626  0     0     0       34        `
/* access.h: Empty by default */
acos.c/         1202506626  0     0     0       2851      `
/****************************************************************************/
/*  acos   v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ACOS() - Arccosine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 10.             */
/*									    */
/*  Y = abs(x)								    */
/*  if Y > 0.5, g = (1 - Y) / 2, Y = - 2 * sqrt(g), i = 1		    */
/*  if Y < 0.5, g = Y * Y, i = 0					    */
/*  R = polynomial expression			 			    */
/*									    */
/*  result = Y + Y * R							    */
/*									    */
/*  if x < 0, result = bi - result + bi 				    */
/*  if x > 0, result = ci + result + ci 				    */
/****************************************************************************/
double acos(double x)
{
  double p, q, g, y;
  static const _DATA_ACCESS double b[2] = {1.57079632679489661923, 
					   0.78539816339744830962};
  static const _DATA_ACCESS double c[2] = {0.0, 0.78539816339744830962};
  int i = 1;

  /*************************************************************************/
  /* acos(x) = acos(-x)                                                    */  
  /*************************************************************************/
  if ((y = fabs(x)) > 0.5)
  {
     /**********************************************************************/
     /* check if x is out of domain                                        */
     /**********************************************************************/
     if (y > 1.0) { errno = EDOM; return (0.0); }

     i = 0;
     g = (1.0 - y) * 0.5;
     y = -2.0 * sqrt(g);
  }
  else g = y * y;

  /*************************************************************************/
  /* determine polynomial expansion                                        */
  /*************************************************************************/
#if BITS<=24
  p = (ASP2 * g + ASP1) * g;
  q = (g + ASQ1) * g + ASQ0;
#elif BITS>=25 && BITS<=36
  p = ((ASP3 * g + ASP2) * g + ASP1) * g;
  q = ((g + ASQ2) * g + ASQ1) * g + ASQ0;
#elif BITS>=37 && BITS<=48
  p = (((ASP4 * g + ASP3) * g + ASP2) * g + ASP1) * g;
  q = (((g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#else
  p = ((((ASP5 * g + ASP4) * g + ASP3) * g + ASP2) * g + ASP1) * g;
  q = ((((g + ASQ4) * g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#endif

  return (x < 0) ? ((b[i] + y + y * p / q) + b[i])
		 : ((c[i] - y - y * p / q) + c[i]);
}

array.cpp/      1202506626  0     0     0       8631      `
/****************************************************************************/
/*  array     v2.70                                                         */
/*  Copyright (c) 1996-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
/* NOTE THAT THIS IS A TEMPORARY IMPLEMENTATION.  THIS WILL BE MERGED INTO  */
/* MEMORY.C AT A LATER TIME.                                                */
/****************************************************************************/
#include <cstdlib>

typedef void  (*CTOR)  (void *);
typedef void  (*CCTOR) (void *, void *);
typedef void  (*DTOR)  (void *, int);
typedef void *(MYNEW)  (std::size_t);
typedef void  (*MYDEL) (void *);
typedef void  (*MYDEL2)(void *, std::size_t);

extern "C" 
{
   void *__canew   (std::size_t nelem, std::size_t selem, CTOR ctor, 
		    DTOR dtor, MYNEW mynew, MYDEL mydel);
   void *__pcanew  (void *array, std::size_t nelem, std::size_t selem, 
                    CTOR ctor, DTOR dtor);
   void *__anew    (void *array, std::size_t nelem, std::size_t selem, 
		    CTOR ctor);
   void  __acctor  (void *dst_array, std::size_t nelem, std::size_t selem,
                    CCTOR cctor, void *src_array);
   void  __cadelete(void *array, std::size_t nelem, std::size_t selem, 
		    DTOR dtor, MYDEL mydel, bool is_2_arg);
   void  __adelete (void *array, std::size_t nelem, std::size_t selem, 
		    DTOR dtor, int dealloc, int);
}

#define LARGE_TYPE_MASK (sizeof(long double) - 1)

namespace
{
   struct array_prefix
   {
      std::size_t nelem;
   };

   extern "C" std::size_t __array_new_prefix_size = 
                    (sizeof(array_prefix) + LARGE_TYPE_MASK) & ~LARGE_TYPE_MASK;

   /*************************************************************************/
   /* ALLOC_ARRAY() - ALLOCATE MEMORY FOR AN ARRAY, INCLUDING ITS HEADER.   */
   /*************************************************************************/
   void *alloc_array(std::size_t nelem, std::size_t selem, MYNEW mynew)
   {
      void *array;

      std::size_t size     = nelem*selem + __array_new_prefix_size;

      if (mynew)  array = mynew(size);
      else        array = operator new[](size);

      if (array)
      {
	 ((array_prefix *)array)->nelem = nelem;
	 array = (char *)array + __array_new_prefix_size;
      }

      return array;
   }

   /*************************************************************************/
   /* DEALLOC_ARRAY() - DEALLOCATE MEMORY FOR AN ARRAY, INCLUDING ITS HEADER*/
   /*************************************************************************/
   void dealloc_array(void *array, std::size_t nelem, std::size_t selem, 
		      MYDEL mydel, bool is_2_arg)
   {
      std::size_t size = nelem * selem + __array_new_prefix_size;
      array = (char *)array - __array_new_prefix_size;

      if      (!mydel)    operator delete[](array);
      else if (is_2_arg)  ((MYDEL2)mydel)(array, size);
      else                mydel(array);
   }

   /*************************************************************************/
   /* ARRAY_NEW() - ALLOCATES AND INITIALIZES ARRAYS.                       */
   /*************************************************************************/
   void *array_new(void *array, std::size_t nelem, std::size_t selem, 
		   CTOR ctor, MYNEW mynew)
   {
      /*--------------------------------------------------------------------*/
      /* IF SPACE FOR THE ARRAY ISN'T ALLOCATED YET, ALLOCATE IT            */
      /*--------------------------------------------------------------------*/
      if (!array && !(array = alloc_array(nelem, selem, mynew)))  return NULL;
      
      /*--------------------------------------------------------------------*/
      /* CALL THE CONTRUCTOR FOR EACH ELEMENT OF THE ARRAY.                 */
      /*--------------------------------------------------------------------*/
      if (ctor)
      {
	 char *p = (char *)array;
	 for (int i = 0; i < nelem; i++, p += selem)  ctor(p);
      }

      return array;
   }

   /*************************************************************************/
   /* ARRAY_DEL() - DEALLOCATES AN DE-INITIALIZES ARRAYS.                   */
   /*************************************************************************/
   void array_del(void *array, std::size_t nelem, std::size_t selem, 
		  DTOR dtor, bool dealloc, MYDEL mydel, bool is_2_arg)
   {
      if (!array) return;

      /*--------------------------------------------------------------------*/
      /* FOR VARIABLE LENGTH ARRAYS, THE NUMBER OF ELEMENTS IS -1.          */
      /* SO LOOK IT UP IN THE PREFIX.                                       */
      /*--------------------------------------------------------------------*/
      if (nelem == (std::size_t)-1)  
      {
	 nelem = 
	      ((array_prefix *)((char *)array-__array_new_prefix_size))->nelem;
      }

      /*--------------------------------------------------------------------*/
      /* CALL THE DESTRUCTOR FOR EACH ELEMENT OF THE ARRAY.                 */
      /*--------------------------------------------------------------------*/
      if (dtor)
      {
	 char *p = (char *)array + ((nelem - 1) * selem);
	 for (int i = 0; i < nelem; i++, p -= selem) 
	    dtor(p, 2); // 2 INDICATES DESTRUCT WHOLE OBJECT, BUT DO NOT DELETE
      }

      /*--------------------------------------------------------------------*/
      /* DEALLOCATE THE SPACE USED BY THE ARRAY, IF REQUESTED.              */
      /*--------------------------------------------------------------------*/
      if (dealloc)  dealloc_array(array, nelem, selem, mydel, is_2_arg);
   }
}

/****************************************************************************/
/* __CANEW() - RTS ROUTINE FOR CLASS ARRAY NEW.                             */
/****************************************************************************/
void *__canew(std::size_t nelem, std::size_t selem, CTOR ctor, DTOR dtor,
	      MYNEW mynew, MYDEL mydel)
{
   return array_new(NULL, nelem, selem, ctor, mynew);
}

/****************************************************************************/
/* __PCANEW() - RTS ROUTINE FOR PLACEMENT CLASS ARRAY NEW.                  */
/****************************************************************************/
void *__pcanew(void *array, std::size_t nelem, std::size_t selem, 
	       CTOR ctor, DTOR dtor)
{
   return array_new(array, nelem, selem, ctor, NULL);
}

/****************************************************************************/
/* __ANEW() - RTS ROUTINE FOR ARRAY NEW.                                    */
/****************************************************************************/
void *__anew(void *array, std::size_t nelem, std::size_t selem, CTOR ctor)
{
   return array_new(array, nelem, selem, ctor, NULL);
}

/****************************************************************************/
/* __ACCTOR() - ARRAY COPY CONSTRUCTOR.  CALLS ctor() COPY CONSTRUCTOR ON   */
/*              EACH ELEMENT OF dst, WITH THE CORRESPONDING ELEMENT IN src  */
/*              BEING THE ARGUMENT TO THE CONSTRUCTOR.  dst AND src ARE     */
/*              ARRAYS OF nelem ELEMENTS OF SIZE selem.                     */
/****************************************************************************/
void __acctor(void *dst_array, std::size_t nelem, std::size_t selem,
	      CCTOR cctor, void *src_array)
{
   char *dst = (char *)dst_array;
   char *src = (char *)src_array;

   if (cctor)
      for (int i = 0; i < nelem; i++, dst += selem, src += selem)
	 cctor((void *)dst, (void *)src);
}

/****************************************************************************/
/* __CADELETE() - RTS ROUTINE FOR CLASS ARRAY DELETE.                       */
/****************************************************************************/
void __cadelete(void *array, std::size_t nelem, std::size_t selem, DTOR dtor,
		MYDEL mydel, bool is_2_arg)
{
   array_del(array, nelem, selem, dtor, true, mydel, is_2_arg);
}

/****************************************************************************/
/* __ADELETE() - RTS ROUTINE FOR ARRAY DELETE.                              */
/****************************************************************************/
void __adelete(void *array, std::size_t nelem, std::size_t selem, DTOR dtor,
	       int dealloc, int)
{
   array_del(array, nelem, selem, dtor, dealloc, NULL, false);
}


asctime.c/      1202506626  0     0     0       1094      `
/****************************************************************************/
/*  asctime v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h> 

extern _CODE_ACCESS int sprintf(char *_string, const char *_format, ...);

static _DATA_ACCESS const char *const day[7]  = {
		      "Sun","Mon","Tue","Wed","Thu","Fri","Sat" };
static _DATA_ACCESS const char *const mon[12] = {
		     "Jan","Feb","Mar","Apr","May","Jun", 
                     "Jul","Aug","Sep","Oct","Nov","Dec" };

_CODE_ACCESS char *asctime(const struct tm *timeptr)
{
    struct tm   tptr = *timeptr;
    static _DATA_ACCESS char result[26];

    mktime(&tptr);      /* MAKE SURE THIS A SANE TIME */

    sprintf(result, "%s %s%3d %02d:%02d:%02d %d\n",
		    day[tptr.tm_wday], mon[tptr.tm_mon], tptr.tm_mday, 
		    tptr.tm_hour, tptr.tm_min, tptr.tm_sec,
		    tptr.tm_year + 1900);

    return (result);
}
asin.c/         1202506626  0     0     0       2553      `
/****************************************************************************/
/*  asin   v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ASIN() - Arcsine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 10.             */
/*									    */
/*  Y = abs(x)								    */
/*  if Y > 0.5, g = (1 - Y) / 2, Y = - 2 * sqrt(g), i = 1		    */
/*  if Y < 0.5, g = Y * Y, i = 0					    */
/*  R = polynomial expression			 			    */
/*									    */
/*  result = Y + Y * R							    */
/*									    */
/*  if x < 0, result = -ci - result - ci 				    */
/*  if x > 0, result = ci + result + ci		  			    */
/****************************************************************************/
double asin(double x)
{
    double p, q, g, y;
    static const _DATA_ACCESS double c[2] = {0.0, 0.78539816339744830962};
    int i = 0;

    if ((y = fabs(x)) > 0.5)
    {
       /*******************************************************************/
       /* check if input is out of the domain of the function             */
       /*******************************************************************/
       if (y > 1.0) { errno = EDOM; return (0.0); }

       i = 1;	
       g = (1.0 - y) * 0.5;	
       y = -2.0 * sqrt(g);
    }
    else g = y * y;		

  /************************************************************************/
  /* determine polynomial expression                                      */
  /************************************************************************/
#if BITS<=24
    p = (ASP2 * g + ASP1) * g;
    q = (g + ASQ1) * g + ASQ0;
#elif BITS>=25 && BITS<=36
    p = ((ASP3 * g + ASP2) * g + ASP1) * g;
    q = ((g + ASQ2) * g + ASQ1) * g + ASQ0;
#elif BITS>=37 && BITS<=48
    p = (((ASP4 * g + ASP3) * g + ASP2) * g + ASP1) * g;
    q = (((g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#else
    p = ((((ASP5 * g + ASP4) * g + ASP3) * g + ASP2) * g + ASP1) * g;
    q = ((((g + ASQ4) * g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#endif

    return (x < 0) ? (-((c[i] + y + y * p / q) + c[i]))
		   : ((c[i] + y + y * p / q) + c[i]);
}

assert.c/       1202506626  0     0     0       1561      `
/****************************************************************************/
/*  assert   v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

/****************************************************************************/
/* _ABORT_MSG() - Write out a string and never return.  Abort function for  */
/*                false assertions.                                         */
/****************************************************************************/
void _abort_msg(const char *string)
{
   fputs(string, stderr);
   fflush(stderr);
   abort();
}

/****************************************************************************/
/* _ASSERT() - Implements the assert macro. Checks the argument. Aborts     */
/*             with a message if not true.                                  */
/****************************************************************************/
void _assert(int expr, const char *string)  { if (!expr) _abort_msg(string); }

/****************************************************************************/
/* _NASSERT() - Special version of assert, which assumes the expression is  */
/*              true.                                                       */
/****************************************************************************/
void _nassert(int expr)  { }

assert.h/       1202506626  0     0     0       2011      `
/*****************************************************************************/
/* assert.h   v2.70                                                          */
/* Copyright (c) 1993-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _ASSERT
#define _ASSERT

#include <linkage.h>

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cassert> IS RECOMMENDED OVER <assert.h>.  <assert.h> IS PROVIDED FOR
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------

#define _NAMESPACE_PREFIX std::

extern "C" namespace std
{
#else
#define _NAMESPACE_PREFIX
#endif

/* this #ifndef can go away when C2000 uses extern C builtins */
extern _CODE_ACCESS void _nassert(int);
extern _CODE_ACCESS void _assert(int, const char *);
extern _CODE_ACCESS void _abort_msg(const char *);

#define _STR(x)  __STR(x)
#define __STR(x) #x

#if defined(NDEBUG)
#define assert(_ignore) ((void)0)
#elif defined(NASSERT)
#define assert(_expr)   _NAMESPACE_PREFIX _nassert(_expr)
#else
#define assert(_expr)   _NAMESPACE_PREFIX _assert((_expr) != 0,          \
                   "Assertion failed, (" _STR(_expr) "), file " __FILE__ \
                   ", line " _STR(__LINE__) "\n")
#endif /* NDEBUG, NASSERT */

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::_nassert;
#endif /* _CPP_STYLE_HEADER */

#if 0
extern _CODE_ACCESS void std::_nassert(int), _assert(int, const char *);
extern _CODE_ACCESS void std::_abort_msg(const char *);
#endif /* 0 */

#ifndef _CPP_STYLE_HEADER
using std::_nassert;
#endif  /* !_CPP_STYLE_HEADER */

#endif /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::_nassert;
#endif /* _CPP_STYLE_HEADER */

#endif

#endif /* _ASSERT */

atan.c/         1202506626  0     0     0       3276      `
/****************************************************************************/
/*  atan   v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  ATAN() - Arctangent							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 11.             */
/*									    */
/*  if x > 1, x = 1 / x 						    */
/*  if x > 2 - sqrt(3), x = (x * sqrt(3) - 1) / (sqrt(3) + x)		    */
/*  g = x * x								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = (t * (x + x * R) + an) * s					    */
/****************************************************************************/
double atan(double x)
{
    double g, p, q;
    int    sign = x < 0.0;       /* REMEMBER SIGN (1 == negative) */
    int    t = 0;                /* PARTIAL RESULT SIGN FLAG      */
    int    n = 0;
    double result; 

    static const _DATA_ACCESS double a[4] = {0.0, 0.52359877559829887308, 
		     	     		        1.57079632679489661923,
		                     		1.04719755119659774615};

    if ((x = fabs(x)) > 1.0)
    {
	x = 1.0 / x;	
	n = 2;	

	/******************************************************************/
	/* the partial result needs to be negated                         */
	/******************************************************************/
	t = 1;    
    }

    /**********************************************************************/
    /* for x > (2 - sqrt(3)  )                                            */
    /**********************************************************************/
    if (x > TWO_SQRT3)			
    {
	/******************************************************************/
	/* x = (x * sqrt(3) -1)	/ (sqroot(3) + x)                         */
	/******************************************************************/
	x = (x * SQRTTHREE - 1.0) / (SQRTTHREE + x);
	++n; 			
    }

    /*********************************************************************/
    /* determine polynomial expression                                   */
    /*********************************************************************/
    g = x * x;	

#if BITS<=24
    p = (ATP1 * g + ATP0) * g;
    q = g + ATQ0;
#elif BITS>=25 && BITS<=32
    p = (ATP1 * g + ATP0) * g;
    q = (g + ATQ1) * g + ATQ0;
#elif BITS>=33 && BITS<=50
    p = ((ATP2 * g + ATP1) * g + ATP0) * g;
    q = ((g + ATQ2) * g + ATQ1) * g + ATQ0;
#else
    p = (((ATP3 * g + ATP2) * g + ATP1) * g + ATP0) * g;
    q = (((g + ATQ3) * g + ATQ2) * g + ATQ1) * g + ATQ0;
#endif

    /**********************************************************************/
    /* calculate the result multiplied by the correct sign                */
    /**********************************************************************/
    result = ((p / q) * x + x); 
    result = (t ? -result : result) + a[n];
    return sign ? -result : result; 
}
atan2.c/        1202506626  0     0     0       3739      `
/****************************************************************************/
/*  atan2  v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ATAN2() - Arctangent2						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 11.             */
/*									    */
/*  if x >= 0, result = atan(y / x)		  			    */
/*  if x < 0 & y >= 0, result = pi + atan(y / x)			    */
/*  if x < 0 & y < 0, result = atan (y / x) - pi			    */
/*									    */
/****************************************************************************/
double atan2(double y, double x)
{
    double g, p, q, r;
    int    sign;
    int    t = 0;
    int   ys = (y >= 0);
    int   xs = (x >= 0);
    int    n = 0;

    static const _DATA_ACCESS double a[4] = {0.0, 0.52359877559829887308, 
			             		1.57079632679489661923,
		                     		1.04719755119659774615};

    /*********************************************************************/
    /* check for error in domain                                         */
    /*********************************************************************/
    if (x == 0)
    {
       if (y == 0) { errno = EDOM; return (0.0); }
       else          return (ys ? HALFPI : -HALFPI);
    }

    /*********************************************************************/
    /* check for negative                                                */
    /*********************************************************************/
    sign = ((x = y / x) < 0.0);

    if ((x = fabs(x)) > 1.0)
    {
       x = 1.0 / x;	
       n = 2;	
       t = 1;	                         /* negate partial result */
    }

    /**********************************************************************/
    /* if (x > (2 - sqrt(3)) x = (x * sqrt(3) -1) / (sqrt(3) + x)         */
    /**********************************************************************/
    if (x > TWO_SQRT3)
    {
       x = (x * SQRTTHREE - 1.0) / (SQRTTHREE + x); 
       ++n;
    }

    /**********************************************************************/
    /* determine polynomial expression                                    */
    /**********************************************************************/
    g = x * x;

#if BITS<=24
    p = (ATP1 * g + ATP0) * g;
    q = g + ATQ0;
#elif BITS>=25 && BITS<=32
    p = (ATP1 * g + ATP0) * g;
    q = (g + ATQ1) * g + ATQ0;
#elif BITS>=33 && BITS<=50
    p = ((ATP2 * g + ATP1) * g + ATP0) * g;
    q = ((g + ATQ2) * g + ATQ1) * g + ATQ0;
#else
    p = (((ATP3 * g + ATP2) * g + ATP1) * g + ATP0) * g;
    q = (((g + ATQ3) * g + ATQ2) * g + ATQ1) * g + ATQ0;
#endif

    /*********************************************************************/
    /* calculate the result multiplied by the correct sign               */
    /*********************************************************************/
    r = ((p / q) * x + x);
    r = (t ? -r : r) + a[n];
    r = (sign ? -r : r); 

    /*********************************************************************/
    /* adjust result to be in correct quadrant                           */
    /*********************************************************************/
    if (!xs && ys)  r = (PI + r);
    if (!xs && !ys) r = (r - PI);

    return (r);
}

atof.c/         1202506626  0     0     0       472       `
/****************************************************************************/
/*  atof v2.70                                                              */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#ifndef _STDLIB
#undef _INLINE
#endif

#include <stdlib.h>

_CODE_ACCESS double atof(const char *st)
{
    return strtod(st, (char **)0);
}
atoi.c/         1202506626  0     0     0       787       `
/****************************************************************************/
/*  atoi v2.70                                                              */
/*  Copyright (c) 1993-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>

_CODE_ACCESS int atoi(const char *st)
{
    int  result = 0;
    char cp;
    int  sign;

    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *st) == '-')) cp = *++st;
    else if (cp == '+')             cp = *++st;

    while (_isdigit(cp))
    {
        result *= 10;
        result += cp - '0';
        cp = *++st;
    }

    if (sign) result *= -1;
    return result;
}


atol.c/         1202506626  0     0     0       788       `
/****************************************************************************/
/*  atol v2.70                                                              */
/*  Copyright (c) 1993-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>

_CODE_ACCESS long atol(const char *st)
{
    long result = 0;
    char cp;
    int  sign;

    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *st) == '-')) cp = *++st;
    else if (cp == '+')             cp = *++st;

    while (_isdigit(cp))
    {
        result *= 10;
        result += cp - '0';
        cp = *++st;
    }

    if (sign) result *= -1;
    return result;
}

atoll.c/        1202506626  0     0     0       799       `
/****************************************************************************/
/*  atoll v2.70                                                             */
/*  Copyright (c) 2002-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>

_CODE_ACCESS long long atoll(const char *st)
{
    long long result = 0;
    char cp;
    int  sign;

    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *st) == '-')) cp = *++st;
    else if (cp == '+')             cp = *++st;

    while (_isdigit(cp))
    {
        result *= 10;
        result += cp - '0';
        cp = *++st;
    }

    if (sign) result *= -1;
    return result;
}


boot.asm/       1202506626  0     0     0       13214     `
;******************************************************************************
;* BOOT  v2.70                                                                *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* BOOT.ASM
;*
;* THIS IS THE INITAL BOOT ROUTINE FOR TMS470 C++ PROGRAMS.
;* IT MUST BE LINKED AND LOADED WITH ALL C++ PROGRAMS.
;* 
;* THIS MODULE PERFORMS THE FOLLOWING ACTIONS:
;*   1) ALLOCATES THE STACK AND INITIALIZES THE STACK POINTER
;*   2) PERFORMS AUTO-INITIALIZATION
;*   3) CALLS INITALIZATION ROUTINES FOR FILE SCOPE CONSTRUCTION
;*   4) CALLS THE FUNCTION MAIN TO START THE C++ PROGRAM
;*   5) CALLS THE STANDARD EXIT ROUTINE
;*
;* THIS MODULE DEFINES THE FOLLOWING GLOBAL SYMBOLS:
;*   1) __stack     STACK MEMORY AREA
;*   2) _c_int00    BOOT ROUTINE
;*
;****************************************************************************

	.if .TMS470_16BIS

;****************************************************************************
;*  16 BIT STATE BOOT ROUTINE                                               *
;****************************************************************************

	.state32
	.global	__stack
;***************************************************************
;* DEFINE THE USER MODE STACK (DEFAULT SIZE IS 512)               
;***************************************************************
__stack:.usect	".stack", 0, 4


	.global	_c_int00
;***************************************************************
;* FUNCTION DEF: _c_int00                                      
;***************************************************************
_c_int00: .asmfunc

        ;*------------------------------------------------------
	;* SET TO USER MODE
        ;*------------------------------------------------------
        MRS     r0, cpsr
        BIC     r0, r0, #0x1F  ; CLEAR MODES
        ORR     r0, r0, #0x10  ; SET USER MODE
        MSR     cpsr, r0

        ;*------------------------------------------------------
	;* CHANGE TO 16 BIT STATE
        ;*------------------------------------------------------
	ADD	r0, pc, #1
	BX	r0

	.state16
        ;*------------------------------------------------------
        ;* INITIALIZE THE USER MODE STACK                      
        ;*------------------------------------------------------
	LDR     r0, c_stack
	MOV	sp, r0
        LDR     r0, c_STACK_SIZE
	ADD	sp, r0

	;*-----------------------------------------------------
	;* SAVE CURRENT STACK POINTER FOR SDP ANALYSIS
	;*-----------------------------------------------------
	LDR	r0, c_mf_sp
	MOV	r7, sp
	STR	r7, [r0]

        ;*------------------------------------------------------
        ;* PERFORM AUTO-INITIALIZATION.  IF CINIT IS -1, THEN
	;* THERE IS NONE.
        ;*------------------------------------------------------
	LDR	r0, c_cinit
	MOV	r7, #1 
	CMN	r0, r7
	BEQ	_c1_
        BL      auto_init


        ;*------------------------------------------------------
	;* CALL INITIALIZATION ROUTINES FOR CONSTRUCTORS. IF
	;* PINIT IS -1, THEN THERE ARE NONE.
	;* NOTE THAT r7 IS PRESERVED ACROSS AUTO-INITIALIZATION.
        ;*------------------------------------------------------
_c1_:	LDR	r5, c_pinit
	CMN	r5, r7
	BEQ	_c3_
	B	_c2_
_loop_:	BL	IND$CALL
_c2_:	LDMIA	r5!, {r4}
	CMP	r4, #0
	BNE	_loop_

        ;*------------------------------------------------------
	;* CALL APPLICATION                                     
        ;*------------------------------------------------------
_c3_:	BL      $main


        ;*------------------------------------------------------
	;* IF APPLICATION DIDN'T CALL EXIT, CALL EXIT(1)
        ;*------------------------------------------------------
        MOV     r0, #1
        BL      $exit

        ;*------------------------------------------------------
	;* DONE, LOOP FOREVER
        ;*------------------------------------------------------
L1:     B	L1
	.endasmfunc


;***************************************************************************
;*  PROCESS INITIALIZATION TABLE.
;*
;*  THE TABLE CONSISTS OF A SEQUENCE OF RECORDS OF THE FOLLOWING FORMAT:
;*                                                                          
;*       .word  <length of data (bytes)>
;*       .word  <address of variable to initialize>                         
;*       .word  <data>
;*                                                                          
;*  THE INITIALIZATION TABLE IS TERMINATED WITH A ZERO LENGTH RECORD.
;*                                                                          
;***************************************************************************

tbl_addr  .set    r0
var_addr  .set    r1
tmp	  .set    r2
length:   .set    r3
data:     .set    r4
three:    .set    r5

auto_init: .asmfunc
	MOV	three, #3		   ;
	B	rec_chk			   ;

        ;*------------------------------------------------------
	;* PROCESS AN INITIALIZATION RECORD
        ;*------------------------------------------------------
record:	LDR	var_addr, [tbl_addr, #4]   ;
	ADD	tbl_addr, #8		   ;

        ;*------------------------------------------------------
	;* COPY THE INITIALIZATION DATA
        ;*------------------------------------------------------
	MOV	tmp, var_addr		   ; DETERMINE ALIGNMENT
	AND	tmp, three		   ; AND COPY BYTE BY BYTE
	BNE	_bcopy			   ; IF NOT WORD ALIGNED

	MOV	tmp, length		   ; FOR WORD COPY, STRIP
	AND	tmp, three		   ; OUT THE NONWORD PART
	BIC	length, three		   ; OF THE LENGTH
	BEQ	_wcont			   ;		

_wcopy:	LDR	data, [tbl_addr]	   ;
	ADD	tbl_addr, #4		   ;
	STR	data, [var_addr]	   ; COPY A WORD OF DATA
	ADD	var_addr, #4		   ;
	SUB	length, #4		   ;
	BNE	_wcopy                     ;
_wcont:	MOV	length, tmp		   ;
	BEQ	_cont			   ;

_bcopy:	LDRB	data, [tbl_addr]	   ;
	ADD	tbl_addr, #1		   ;
	STRB	data, [var_addr]	   ; COPY A BYTE OF DATA
	ADD	var_addr, #1		   ;
	SUB	length, #1		   ;
	BNE	_bcopy                     ;

_cont:	MOV	tmp, tbl_addr	           ;
	AND	tmp, three	           ; MAKE SURE THE ADDRESS
	BEQ	rec_chk			   ; IS WORD ALIGNED
	BIC	tbl_addr, three		   ;
	ADD	tbl_addr, #0x4             ;

rec_chk:LDR	length, [tbl_addr]         ; PROCESS NEXT
	CMP	length, #0                 ; RECORD IF LENGTH IS
	BNE	record                     ; NONZERO 

	MOV	pc, lr
	.endasmfunc

;***************************************************************
;* CONSTANTS USED BY THIS MODULE
;***************************************************************
c_stack		.long    __stack
c_STACK_SIZE  	.long    __STACK_SIZE
c_cinit       	.long    cinit
c_pinit       	.long    pinit
c_mf_sp	        .long    _main_func_sp

        .sect   ".cinit"
        .align  4
        .field          4,32
        .field          _stkchk_called+0,32
        .field          0,32

        .bss    _stkchk_called,4,4

;******************************************************
;* UNDEFINED REFERENCES                               *
;******************************************************
	.global IND$CALL
	.global	$exit
	.global	$main
	.global	cinit
	.global	pinit
	.global	__STACK_SIZE
	.global _stkchk_called
	.global _main_func_sp

	.else

;****************************************************************************
;*  32 BIT STATE BOOT ROUTINE                                               *
;****************************************************************************

	.global	__stack
;***************************************************************
;* DEFINE THE USER MODE STACK (DEFAULT SIZE IS 512)            
;***************************************************************
__stack:.usect	".stack", 0, 4


	.global	_c_int00
;***************************************************************
;* FUNCTION DEF: _c_int00                                      
;***************************************************************
_c_int00: .asmfunc

        ;*------------------------------------------------------
	;* SET TO USER MODE
        ;*------------------------------------------------------
        MRS     r0, cpsr
        BIC     r0, r0, #0x1F  ; CLEAR MODES
        ORR     r0, r0, #0x10  ; SET USER MODE
        MSR     cpsr, r0

        ;*------------------------------------------------------
        ;* INITIALIZE THE USER MODE STACK                      
        ;*------------------------------------------------------
	LDR     sp, c_stack
        LDR     r0, c_STACK_SIZE
	ADD	sp, sp, r0

	;*-----------------------------------------------------
	;* SAVE CURRENT STACK POINTER FOR SDP ANALYSIS
	;*-----------------------------------------------------
	LDR	r0, c_mf_sp
	STR	sp, [r0]

        ;*------------------------------------------------------
        ;* PERFORM AUTO-INITIALIZATION.  IF CINIT IS -1, THEN
	;* THERE IS NONE.
        ;*------------------------------------------------------
	LDR	r0, c_cinit
	CMN	r0, #1
        BLNE    auto_init

        ;*------------------------------------------------------
	;* CALL INITIALIZATION ROUTINES FOR CONSTRUCTORS. IF
	;* PINIT IS -1, THEN THERE ARE NONE.
        ;*------------------------------------------------------
	LDR	r5, c_pinit
	CMN	r5, #1
	BEQ	_c2_
	B	_c1_
_loop_:	BL	IND_CALL
_c1_:	LDR	r4, [r5], #4
	CMP	r4, #0
	BNE	_loop_

        ;*------------------------------------------------------
	;* CALL APPLICATION                                     
        ;*------------------------------------------------------
_c2_:	BL      _main

        ;*------------------------------------------------------
	;* IF APPLICATION DIDN'T CALL EXIT, CALL EXIT(1)
        ;*------------------------------------------------------
        MOV     R0, #1
        BL      _exit

        ;*------------------------------------------------------
	;* DONE, LOOP FOREVER
        ;*------------------------------------------------------
L1:     B	L1
	.endasmfunc

;***************************************************************************
;*  PROCESS INITIALIZATION TABLE.
;*
;*  THE TABLE CONSISTS OF A SEQUENCE OF RECORDS OF THE FOLLOWING FORMAT:
;*                                                                          
;*       .word  <length of data (bytes)>
;*       .word  <address of variable to initialize>                         
;*       .word  <data>
;*                                                                          
;*  THE INITIALIZATION TABLE IS TERMINATED WITH A ZERO LENGTH RECORD.
;*                                                                          
;***************************************************************************

tbl_addr: .set    R0
var_addr: .set    R1
length:   .set    R2
data:     .set    R3

auto_init: .asmfunc
	B	rec_chk

        ;*------------------------------------------------------
	;* PROCESS AN INITIALIZATION RECORD
        ;*------------------------------------------------------
record:	LDR	var_addr, [tbl_addr], #4   ;

        ;*------------------------------------------------------
	;* COPY THE INITIALIZATION DATA
        ;*------------------------------------------------------
	TST	var_addr, #3		   ; SEE IF DEST IS ALIGNED
	BNE     _bcopy			   ; IF NOT, COPY BYTES
	SUBS	length, length, #4	   ; IF length <= 3, ALSO
	BMI     _bcont			   ; COPY BYTES

_wcopy:	LDR	data, [tbl_addr], #4  	   ;
	STR	data, [var_addr], #4	   ; COPY A WORD OF DATA
	SUBS	length, length, #4	   ;
	BPL	_wcopy			   ;
_bcont:	ADDS	length, length, #4	   ;
	BEQ	_cont			   ;

_bcopy:	LDRB	data, [tbl_addr], #1       ;
	STRB	data, [var_addr], #1       ; COPY A BYTE OF DATA
	SUBS	length, length, #1	   ;
	BNE	_bcopy                     ;

_cont:	ANDS	length, tbl_addr, #0x3     ; MAKE SURE THE ADDRESS
	RSBNE	length, length, #0x4       ; IS WORD ALIGNED
	ADDNE	tbl_addr, tbl_addr, length ;

rec_chk:LDR	length, [tbl_addr], #4     ; PROCESS NEXT
	CMP	length, #0                 ; RECORD IF LENGTH IS
	BNE	record                     ; NONZERO

	MOV	PC, LR
	.endasmfunc

;***************************************************************
;* CONSTANTS USED BY THIS MODULE
;***************************************************************
c_stack		.long    __stack
c_STACK_SIZE  	.long    __STACK_SIZE
c_cinit       	.long    cinit
c_pinit       	.long    pinit
c_mf_sp	        .long    _main_func_sp

        .sect   ".cinit"
        .align  4
        .field          4,32
        .field          _stkchk_called+0,32
        .field          0,32

        .bss    _stkchk_called,4,4



;******************************************************
;* UNDEFINED REFERENCES                               *
;******************************************************
	.global IND_CALL
	.global	_exit
	.global	_main
	.global	cinit
	.global	pinit
	.global	__STACK_SIZE
	.global _stkchk_called
	.global _main_func_sp
	.endif

	.end

bsearch.c/      1202506626  0     0     0       1250      `
/****************************************************************************/
/*  bsearch v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>

_CODE_ACCESS void *bsearch(
	      register const void *key,     /* ITEM TO SEARCH FOR           */
              register const void *base,    /* POINTER TO ARRAY OF ELEMENTS */
              size_t nmemb,                 /* NUMBER OF ELEMENTS TO SORT   */
              size_t size,                  /* SIZE IN BYTES OF EACH ITEM   */
              int (*compar)(const void *,const void *)) /* COMPARE FUNCTION */

{
   register int i       = 0;             /* left scan index  */
   register int j       = nmemb - 1;     /* right scan index */

   while( i <= j )
   {
      register int pivot = (j + i) / 2;            
      int result = (*compar) (key, (char *)base + (pivot * size));
      if (result == 0) return((char *)base + (pivot * size));
      if (result < 0) j = pivot - 1;
		 else i = pivot + 1;
   }

   return ((void *)0);   /* IF WE GET TO HERE, WE FAILED */
}


cassert/        1202506626  0     0     0       880       `
/*****************************************************************************/
/* cassert   v2.70                                                           */
/* Copyright (c) 1999-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CASSERT
#define _CASSERT

#include <linkage.h>

#define _CPP_STYLE_HEADER
#include <assert.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif /* #ifndef _CASSERT */
cctype/         1202506626  0     0     0       1461      `
/*****************************************************************************/
/* cctype    v2.70                                                           */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

/************************************************************************/
/*                                                                      */
/*  CHARACTER TYPING FUNCTIONS AND MACROS                               */
/*                                                                      */
/*  Note that in this implementation, either macros or functions may    */
/*  be used.  Macros are prefixed with an underscore.                   */
/*                                                                      */
/************************************************************************/
#ifndef _CCTYPE
#define _CCTYPE

#define _CPP_STYLE_HEADER
#include <ctype.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif  /* #ifndef _CCTYPE */

ceil.c/         1202506626  0     0     0       375       `
/****************************************************************************/
/*  CEIL   v2.70                                                            */
/*  Copyright (c) 1993-2008 Texas Instruments Incorporated                  */
/****************************************************************************/

#undef  _INLINE
#define _CEIL

#include <math.h>

cerrno/         1202506626  0     0     0       830       `
/*****************************************************************************/
/*  CERRNO  v2.70                                                            */
/*  Copyright (c) 1999-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

#ifndef _CERRNO
#define _CERRNO

#define _CPP_STYLE_HEADER
#include <errno.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif
cfloat/         1202506626  0     0     0       392       `
/*****************************************************************************/
/* cfloat    v2.70                                                           */
/* Copyright (c) 1999-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CFLOAT
#define _CFLOAT

#include <float.h>

#endif
ciso646/        1202506626  0     0     0       567       `
/*****************************************************************************/
/* CISO646   v2.70                                                           */
/* Copyright (c) 2002-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
/* The identifiers defined in iso646.h are keywords in C++.  That means this */
/* file must be empty.                                                       */
/*****************************************************************************/

clearerr.c/     1202506626  0     0     0       896       `
/*****************************************************************************/
/*  CLEARERR.C v2.70                                                         */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <stdio.h>


/*****************************************************************************/
/* CLEARERR -  Clear the I/O error flag (_STATERR)                           */
/*                                                                           */
/*    This function calls a macro defined in stdio.h                         */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS void clearerr(FILE *_fp) { _clearerr(_fp); }

climits/        1202506626  0     0     0       643       `
/*****************************************************************************/
/* limits.h   v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

//----------------------------------------------------------------------------
// <climits> IS RECOMMENDED OVER <limits.h>.  <limits.h> IS PROVIDED FOR 
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
#include <limits.h>

clock.c/        1202506626  0     0     0       1093      `
/****************************************************************************/
/*  clock v2.70                                                             */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

/****************************************************************************/
/* OBVIOUSLY, THIS IS SIMPLY A STUB, WHICH BY DEFINITION RETURNS -1         */
/* IF THE SYSTEM TIME IS UNAVAILABLE.                                       */ 
/*--------------------------------------------------------------------------*/
/* OBVIOUSLY, THIS IS NO LONGER A STUB.  THIS WILL RETURN THE CLK REGISTER  */
/* FROM THE EMULATOR OR SIMULATOR.  THIS IS A CYCLE ACURATE COUNT OF THE    */ 
/* NUMBER OF CYCLES THAT HAVE ELAPSED SINCE THE START OF THE PROGRAM.       */ 
/****************************************************************************/
#include <time.h> 
extern clock_t HOSTclock();

_CODE_ACCESS clock_t clock(void)   
{
    return (clock_t)HOSTclock();
}

cmath/          1202506626  0     0     0       4693      `
/****************************************************************************/
/*  cmath  v2.70                                                            */
/*  Copyright (c) 1999-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#ifndef __cmath__
#define __cmath__

#include <linkage.h>

#ifndef EDOM
#define EDOM   1
#endif

#ifndef ERANGE
#define ERANGE 2
#endif

#include <float.h>
#define HUGE_VAL DBL_MAX

#include <access.h>

#ifndef __EXTERN
#define __EXTERN
#endif

extern "C" namespace std
{
   __EXTERN double sqrt (double x);
   __EXTERN double exp  (double x);
   __EXTERN double log  (double x);
   __EXTERN double log10(double x);
   __EXTERN double pow  (double x, double y);
   __EXTERN double sin  (double x);
   __EXTERN double cos  (double x);
   __EXTERN double tan  (double x);
   __EXTERN double asin (double x);
   __EXTERN double acos (double x);
   __EXTERN double atan (double x);
   __EXTERN double atan2(double y, double x);
   __EXTERN double sinh (double x);
   __EXTERN double cosh (double x);
   __EXTERN double tanh (double x);

   __INLINE double ceil (double x);
   __INLINE double floor(double x);

   __EXTERN double fabs (double x);

   __EXTERN double ldexp(double x, int n);
   __EXTERN double frexp(double x, int *exp);
   __EXTERN double modf (double x, double *ip);
   __EXTERN double fmod (double x, double y);

   /* An inline version of fmod that works for limited domain only */
   /* See comments in implementation below */
   static inline double _FMOD(double x, double y);

   /* these present in many linked images, so we'll tell you about them. */
   __EXTERN double _nround(double x); /* round-to-nearest */
   __EXTERN double _trunc(double x); /* truncate towards 0 */
}

/* the ANSI-optional *f and *l routines */
#include <cmathf>
#include <cmathl>

#include <access.h>

#ifdef _TI_ENHANCED_MATH_H
#if 0
   /* ------------------------------------------------- */
   /* Routines below are an addition to ANSI math.h     */
   /* Some (noted with "9x" in comment) will become ANSI*/
   /* once C9x is approved.                             */
   /* ------------------------------------------------- */
#endif

extern "C" namespace std
{
   __EXTERN double rsqrt(double x); /*   == 1/sqrt(x) but *MUCH* faster      */
   __EXTERN double exp2 (double x); /*9x mathematically equiv to pow(2.0 ,x) */
   __EXTERN double exp10(double x); /*   mathematically equiv to pow(10.0,x) */
   __EXTERN double log2 (double x); /*9x mathematically equiv to log(x)/log(2.0)*/

   __EXTERN double powi(double x, int i); /* equiv to pow(x,(double)i) */

   __EXTERN double cot  (double x);
   __EXTERN double acot (double x);
   __EXTERN double acot2(double x, double y);

   __EXTERN double coth (double x);

   __EXTERN double asinh(double x); /* 9x */
   __EXTERN double acosh(double x); /* 9x */
   __EXTERN double atanh(double x); /* 9x */
   __EXTERN double acoth(double x);

#define round(x) _nround(x) /* 9x round-to-nearest   */
#define trunc(x) _trunc(x) /* 9x truncate towards 0 */

} /* namespace */

#endif  /* _TI_ENHANCED_MATH_H */


#ifdef _INLINE
/****************************************************************************/
/*  Inline versions of floor, ceil, fmod                                    */
/****************************************************************************/

static __inline double std::floor(double x) 
{
   double y; 
   return (std::modf(x, &y) < 0 ? y - 1 : y);
}

static __inline double std::ceil(double x)
{
   double y; 
   return (std::modf(x, &y) > 0 ? y + 1 : y);
}

/* 
   The implementation below does not work correctly for all cases.
   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).
   The correct result is one of 0,1, or 2.
   But the implementation below will *always* return 0 
   because the quotient is only an approximation.
*/
static __inline double _FMOD(double x, double y)
{
   double d = std::fabs(x); 
   if (d - std::fabs(y) == d) return (0);
   std::modf(x/y, &d);  
   return (x - d * y);
}

#endif

#include <unaccess.h>

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif /* __math__ */


cmathf/         1202506626  0     0     0       5210      `
/****************************************************************************/
/*  cmathf  v2.70                                                           */
/*  Copyright (c) 1999-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#ifndef __cmathf__
#define __cmathf__

#ifndef EDOM
   #define EDOM   1
#endif

#ifndef ERANGE
   #define ERANGE 2
#endif

#include <float.h>

#if (FLT_DIG == DBL_DIG) /* float is not different than double */

#include <cmath>

#define sqrtf    sqrt
#define expf     exp
#define logf     log
#define log10f   log10
#define powf     pow
#define sinf     sin
#define cosf     cos
#define tanf     tan
#define asinf    asin
#define acosf    acos
#define atanf    atan
#define atan2f   atan2
#define sinhf    sinh
#define coshf    cosh
#define tanhf    tanh

#define ceilf    ceil
#define floorf   floor

#define fabsf    fabs

#define ldexpf   ldexp
#define frexpf   frexp
#define modff    modf
#define fmodf    fmod

#ifdef _TI_ENHANCED_MATH_H

#define HUGE_VALF FLT_MAX

#define rsqrtf   rsqrt
#define exp2f    exp2
#define exp10f   exp10
#define log2f    log2
#define powif    powi
#define cotf     cot
#define acotf    acot
#define acot2f   acot2
#define cothf    coth
#define asinhf   asinh
#define acoshf   acosh
#define atanhf   atanh
#define acothf   acoth
#define truncf   _trunc
#define roundf   _nround

#endif

#else /* float is different than double */

#include <access.h>

extern "C" namespace std
{
   __EXTERN float sqrtf (float x);
   __EXTERN float expf  (float x);
   __EXTERN float logf  (float x);
   __EXTERN float log10f(float x);
   __EXTERN float powf  (float x, float y);
   __EXTERN float sinf  (float x);
   __EXTERN float cosf  (float x);
   __EXTERN float tanf  (float x);
   __EXTERN float asinf (float x);
   __EXTERN float acosf (float x);
   __EXTERN float atanf (float x);
   __EXTERN float atan2f(float y, float x);
   __EXTERN float sinhf (float x);
   __EXTERN float coshf (float x);
   __EXTERN float tanhf (float x);

   __INLINE float ceilf (float x);
   __INLINE float floorf(float x);

   __EXTERN float fabsf (float x);

   __EXTERN float ldexpf(float x, int n);
   __EXTERN float frexpf(float x, int *exp);
   __EXTERN float modff (float x, float *ip);
   __EXTERN float fmodf (float x, float y);

   /* An inline version of fmodf that works for limited domain only */
   /* See comments in implementation below */
   static inline float _FMODF(float x, float y);

   /* these present in many linked images, so we'll tell you about them. */
   __EXTERN float _roundf(float x); /* round-to-nearest */
   __EXTERN float _truncf(float x); /* truncate towards 0 */
}

#ifdef _TI_ENHANCED_MATH_H
#if 0
   /* ------------------------------------------------- */
   /* Routines below are an addition to ANSI math.h     */
   /* Some (noted with "9x" in comment) will become ANSI*/
   /* once C9x is approved.                             */
   /* ------------------------------------------------- */
#endif

#define HUGE_VALF FLT_MAX /* 9x */

extern "C" namespace std
{
   __EXTERN float rsqrtf(float x); /*   == 1/sqrtf(x) but *MUCH* faster      */
   __EXTERN float exp2f (float x); /*9x mathematically equiv to powf(2.0 ,x) */
   __EXTERN float exp10f(float x); /*   mathematically equiv to powf(10.0,x) */
   __EXTERN float log2f (float x); /*9x mathematically equiv to logf(x)/logf(2.)*/

   __EXTERN float powif (float x, int i); /* equiv to powf(x,(float)i) */

   __EXTERN float cotf  (float x);
   __EXTERN float acotf (float x);
   __EXTERN float acot2f(float x, float y);

   __EXTERN float cothf (float x);

   __EXTERN float asinhf(float x); /* 9x */
   __EXTERN float acoshf(float x); /* 9x */
   __EXTERN float atanhf(float x); /* 9x */
   __EXTERN float acothf(float x);

#define roundf(x) _roundf(x) /* 9x round-to-nearest   */
#define truncf(x) _truncf(x) /* 9x truncate towards 0 */

} /* namespace */

#endif



#ifdef _INLINE
/****************************************************************************/
/*  Inline versions of floorf, ceilf, fmodf                                 */
/****************************************************************************/

static inline float std::floorf(float x) 
{
   float y; 
   return (std::modff(x, &y) < 0 ? y - 1 : y);
}

static inline float std::ceilf(float x)
{
   float y; 
   return (std::modff(x, &y) > 0 ? y + 1 : y);
}

/* 
   The implementation below does not work correctly for all cases.
   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).
   The correct result is one of 0,1, or 2.
   But the implementation below will *always* return 0 
   because the quotient is only an approximation.
*/
static inline float _FMODF(float x, float y)
{
   float d = std::fabsf(x); 
   if (d - std::fabsf(y) == d) return (0);
   std::modff(x/y, &d);  
   return (x - d * y);
}

#endif

#include <unaccess.h>

#endif /* float is/isnot different than double */

#endif /* __cmathf__ */
cmathl/         1202506626  0     0     0       5611      `
/****************************************************************************/
/*  cmathl  v2.70                                                           */
/*  Copyright (c) 1999-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

/* This source automatically generated on Fri Feb 12 13:24:25 EST 1999 */

#ifndef __cmathl__
#define __cmathl__

#ifndef EDOM
   #define EDOM   1
#endif

#ifndef ERANGE
   #define ERANGE 2
#endif

#include <float.h>

#if (LDBL_DIG == DBL_DIG) /* long double is not different than double */

#include <cmath>

#define sqrtl    sqrt
#define expl     exp
#define logl     log
#define log10l   log10
#define powl     pow
#define sinl     sin
#define cosl     cos
#define tanl     tan
#define asinl    asin
#define acosl    acos
#define atanl    atan
#define atan2l   atan2
#define sinhl    sinh
#define coshl    cosh
#define tanhl    tanh

#define ceill    ceil
#define floorl   floor

#define fabsl    fabs

#define ldexpl   ldexp
#define frexpl   frexp
#define modfl    modf
#define fmodl    fmod

#ifdef _TI_ENHANCED_MATH_H

#define HUGE_VALL LDBL_MAX

#define rsqrtl   rsqrt
#define exp2l    exp2
#define exp10l   exp10
#define log2l    log2
#define powil    powi
#define cotl     cot
#define acotl    acot
#define acot2l   acot2
#define cothl    coth
#define asinhl   asinh
#define acoshl   acosh
#define atanhl   atanh
#define acothl   acoth
#define truncl   _trunc
#define roundl   _nround

#endif

#else /* long double is different than double */

#include <access.h>

extern "C" namespace std
{
__EXTERN long double sqrtl (long double x);
__EXTERN long double expl  (long double x);
__EXTERN long double logl  (long double x);
__EXTERN long double log10l(long double x);
__EXTERN long double powl  (long double x, long double y);
__EXTERN long double sinl  (long double x);
__EXTERN long double cosl  (long double x);
__EXTERN long double tanl  (long double x);
__EXTERN long double asinl (long double x);
__EXTERN long double acosl (long double x);
__EXTERN long double atanl (long double x);
__EXTERN long double atan2l(long double y, long double x);
__EXTERN long double sinhl (long double x);
__EXTERN long double coshl (long double x);
__EXTERN long double tanhl (long double x);

__INLINE long double ceill (long double x);
__INLINE long double floorl(long double x);

__EXTERN long double fabsl (long double x);

__EXTERN long double ldexpl(long double x, int n);
__EXTERN long double frexpl(long double x, int *exp);
__EXTERN long double modfl (long double x, long double *ip);
__EXTERN long double fmodl (long double x, long double y);

/* An inline version of fmod that works for limited domain only */
/* See comments in implementation below */
static inline long double _FMODL(long double x, long double y);

__EXTERN long double _roundl(long double x); /* round-to-nearest */
__EXTERN long double _truncl(long double x); /* truncate towards 0 */

}

#ifdef _TI_ENHANCED_MATH_H
#if 0
/* ------------------------------------------------- */
/* Routines below are an addition to ANSI math.h     */
/* Some (noted with "9x" in comment) will become ANSI*/
/* once C9x is approved.                             */
/* ------------------------------------------------- */
#endif

#define HUGE_VALL LDBL_MAX /* ## */

extern "C" namespace std
{
__EXTERN long double rsqrtl(long double x); /*   1/sqrtl(x) but *MUCH* faster*/
__EXTERN long double exp2l (long double x); /*9x math equiv to powl(2.0 ,x)  */
__EXTERN long double exp10l(long double x); /*   math equiv to powl(10.0,x)  */
__EXTERN long double log2l (long double x);/*9x math equiv to logl(x)/logl(2)*/

__EXTERN long double powil (long double x, int i); /* == powl(x,(long double)i)*/

__EXTERN long double cotl  (long double x);
__EXTERN long double acotl (long double x);
__EXTERN long double acot2l(long double x, long double y);

__EXTERN long double cothl (long double x);

__EXTERN long double asinhl(long double x); /* 9x */
__EXTERN long double acoshl(long double x); /* 9x */
__EXTERN long double atanhl(long double x); /* 9x */
__EXTERN long double acothl(long double x);

#define roundl(x) _roundl(x) /* 9x round-to-nearest   */
#define truncl(x) _truncl(x) /* 9x truncate towards 0 */

} /* namespace */

#endif


#ifdef _INLINE
/****************************************************************************/
/*  Inline versions of floorl, ceill, fmodl                                 */
/****************************************************************************/

static inline long double std::floorl(long double x) 
{
   long double y; 
   return (std::modfl(x, &y) < 0 ? y - 1 : y);
}

static inline long double std::ceill(long double x)
{
   long double y; 
   return (std::modfl(x, &y) > 0 ? y + 1 : y);
}

/* 
   The implementation below does not work correctly for all cases.
   Consider the case of fmod(Big, 3), for any Big > 2**(MANT_DIG+2).
   The correct result is one of 0,1, or 2.
   But the implementation below will *always* return 0 
   because the quotient is only an approximation.
*/
static inline long double std::_FMODL(long double x, long double y)
{
   long double d = std::fabsl(x); 
   if (d - std::fabsl(y) == d) return (0);
   std::modfl(x/y, &d);  
   return (x - d * y);
}

#endif

#include <unaccess.h>

#endif /* long double is/isnot different than double */

#endif /* __cmathl__ */

cos.c/          1202506626  0     0     0       3017      `
/****************************************************************************/
/*  cos    v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  COS() - Cosine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 8.              */
/*									    */
/*  N = round(x / PI + 1/2) - 0.5					    */
/*  f = x - N * PI							    */
/*  g = f * f								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = f + f * R							    */
/*  if N is even, result = - result					    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double cos(double x)
{
    int sign;           /* the sign of the result */
    double xn, f, g, rg, result;
    int n;

    /**************************************************************************/
    /* cos(x) = cos(-x)                                                       */
    /**************************************************************************/
    x = fabs(x);

    /**************************************************************************/
    /* n = round(x/PI + 1/2) (can be rounded this way, since positive number) */
    /**************************************************************************/
    n  = (int) (((x + HALFPI) * INVSPI) + 0.5);
    xn = (double) n - 0.5;

    /**************************************************************************/
    /* if n is odd, negate the sign                                           */
    /**************************************************************************/
    sign = n % 2;

    /**************************************************************************/
    /* f = x - xn * PI (but more mathematically stable)                       */
    /**************************************************************************/
    f = (x - xn * C1) - xn * C2;

    /**************************************************************************/
    /* determine polynomial expression                                        */
    /**************************************************************************/
    g = f * f;

#if BITS<=24
    rg = (((R4 * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=25 && BITS<=32
    rg = ((((R5 * g + R4) * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=33 && BITS<=50
    rg = ((((((R7*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#else
    rg = (((((((R8*g+R7)*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#endif

    result = f + f * rg; 
    return sign ? -result : result; 
}

cosh.c/         1202506626  0     0     0       3637      `
/****************************************************************************/
/*  cosh   v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  COSH() - Hyperbolic Cosine						    */
/*               							    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 6.              */
/*               							    */
/*  result = (exp(x) + 1 / exp(x)) / 2		  			    */
/****************************************************************************/
double cosh(double x)
{
  double g, z, q, p, r, a, b;
  int n;

  /****************************************************************************/
  /* cosh(x) = cosh(-x)                                                       */
  /****************************************************************************/
  x = fabs(x);

  /****************************************************************************/
  /* check to see if overflow would occur                                     */
  /****************************************************************************/
  if (x > MAXH) { errno = ERANGE; return (HUGE_VAL); }

  if (x < 0) n = (int) (x * INVLOGe2 - 0.5);       /* since (int) -1.5 = -1.0 */
  else       n = (int) (x * INVLOGe2 + 0.5);

  /****************************************************************************/
  /* g = x - n * ln(2) (but more mathematically stable)                       */
  /****************************************************************************/
  g  = (x - n * C3) - n * C4;

  /****************************************************************************/
  /* determine polynomial expression                                          */
  /****************************************************************************/
  z  = g * g;

#if BITS <=29
  p = (EXP1 * z + EXP0) * g;
  q = EXQ1 * z + EXQ0;
#elif BITS>=30 && BITS<=42
  p = (EXP1 * z + EXP0) * g;
  q = (EXQ2 * z + EXQ1) * z + EXQ0;
#elif BITS>=43 && BITS<=56
  p = ((EXP2 * z + EXP1) * z + EXP0) * g;
  q = (EXQ2 * z + EXQ1) * z + EXQ0;
#else
  p = ((EXP2 * z + EXP1) * z + EXP0) * g;
  q = ((EXQ3 * z + EXQ2) * z + EXQ1) * z + EXQ0;
#endif

  /****************************************************************************/
  /* calculate exp(g)                                                         */
  /****************************************************************************/
  r  = 0.5 + p / (q - p);

  /****************************************************************************/
  /* exp(x)/2 = exp(g) * 2 ^ (n)                                              */
  /****************************************************************************/
  a = ldexp(r, n);

  /****************************************************************************/
  /* exp(-x)*2 = 1 / (exp(x)/2)                                               */
  /****************************************************************************/
  b  = 1.0 / a;

  /****************************************************************************/
  /* cosh(x) = exp(x)/2 + exp(-x)*2 / 4                                       */
  /****************************************************************************/
  return (a + b * 0.25);
}

csetjmp/        1202506626  0     0     0       848       `
/*****************************************************************************/
/* csetjmp   v2.70                                                           */
/* Copyright (c) 1999-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CSETJMP
#define _CSETJMP

#define _CPP_STYLE_HEADER
#include <setjmp.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif /* _CSETJMP */
cstdarg/        1202506626  0     0     0       849       `
/*****************************************************************************/
/* cstdarg   v2.70                                                           */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CSTDARG
#define _CSTDARG

#define _CPP_STYLE_HEADER
#include <stdarg.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif  /* _CSTDARG */

cstddef/        1202506626  0     0     0       848       `
/*****************************************************************************/
/* cstddef   v2.70                                                           */
/* Copyright (c) 1999-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CSTDDEF
#define _CSTDDEF

#define _CPP_STYLE_HEADER
#include <stddef.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif /* _CSTDDEF */
cstdio/         1202506626  0     0     0       852       `
/*****************************************************************************/
/* CSTDIO v2.70                                                              */
/* Copyright (c) 1999-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _CSTDIO 
#define _CSTDIO

#define _CPP_STYLE_HEADER
#include <stdio.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif  /* #ifndef _CSTDIO */
cstdlib/        1202506626  0     0     0       850       `
/*****************************************************************************/
/* cstdlib   v2.70                                                           */
/* Copyright (c) 1999-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CSTDLIB
#define _CSTDLIB

#define _CPP_STYLE_HEADER
#include <stdlib.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif /* ! _CSTDLIB */
cstring/        1202506626  0     0     0       849       `
/*****************************************************************************/
/* cstring   v2.70                                                           */
/* Copyright (c) 1999-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CSTRING
#define _CSTRING

#define _CPP_STYLE_HEADER
#include <string.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif  /* _CSTRING */

ctime/          1202506626  0     0     0       849       `
/*****************************************************************************/
/* ctime     v2.70                                                           */
/* Copyright (c) 1999-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _CTIME
#define _CTIME

#define _CPP_STYLE_HEADER
#include <time.h>
#undef _CPP_STYLE_HEADER

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif  /* #ifndef _CTIME */

ctime_.c/       1202506626  0     0     0       377       `
/****************************************************************************/
/*  ctime   v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _CTIME_

#include <time.h>

ctype.c/        1202506627  0     0     0       7661      `
/****************************************************************************/
/*  ctype.c v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <ctype.h>

/****************************************************************************/
/*  DECLARATION OF CHARACTER TYPING LOOKUP TABLE                            */
/****************************************************************************/
_DATA_ACCESS const unsigned char _ctypes_[] = {
                     /*  -1   EOF   */      0,
                     /* 0x00  NUL   */     _C_,
                     /* 0x01  SOH   */     _C_,
                     /* 0x02  STX   */     _C_,
                     /* 0x03  ETX   */     _C_,
                     /* 0x04  EOT   */     _C_,
                     /* 0x05  ENQ   */     _C_,
                     /* 0x06  ACK   */     _C_,
                     /* 0x07  BEL   */     _C_,
                     /* 0x08  BS    */     _C_,
                     /* 0x09  HT    */     _C_ | _S_,
                     /* 0x0A  LF    */     _C_ | _S_,
                     /* 0x0B  VT    */     _C_ | _S_,
                     /* 0x0C  FF    */     _C_ | _S_,
                     /* 0x0D  CR    */     _C_ | _S_,
                     /* 0x0E  SO    */     _C_,
                     /* 0x0F  SI    */     _C_,

                     /* 0x10  DLE   */     _C_,
                     /* 0x11  DC1   */     _C_,
                     /* 0x12  DC2   */     _C_,
                     /* 0x13  DC3   */     _C_,
                     /* 0x14  DC4   */     _C_,
                     /* 0x15  NAK   */     _C_,
                     /* 0x16  SYN   */     _C_,
                     /* 0x17  ETB   */     _C_,
                     /* 0x18  CAN   */     _C_,
                     /* 0x19  EM    */     _C_,
                     /* 0x1A  SUB   */     _C_,
                     /* 0x1B  ESC   */     _C_,
                     /* 0x1C  FS    */     _C_,
                     /* 0x1D  GS    */     _C_,
                     /* 0x1E  RS    */     _C_,
                     /* 0x1F  US    */     _C_,

                     /* 0x20  ' '   */     _S_ | _B_,
                     /* 0x21  '!'   */     _P_,
                     /* 0x22  '"'   */     _P_,
                     /* 0x23  '#'   */     _P_,
                     /* 0x24  '$'   */     _P_,
                     /* 0x25  '%'   */     _P_,
                     /* 0x26  '&'   */     _P_,
                     /* 0x27  '''   */     _P_,
                     /* 0x28  '('   */     _P_,
                     /* 0x29  ')'   */     _P_,
                     /* 0x2A  '*'   */     _P_,
                     /* 0x2B  '+'   */     _P_,
                     /* 0x2C  ','   */     _P_,
                     /* 0x2D  '-'   */     _P_,
                     /* 0x2E  '.'   */     _P_,
                     /* 0x2F  '/'   */     _P_,

                     /* 0x30  '0'   */     _N_ | _H_,
                     /* 0x31  '1'   */     _N_ | _H_,
                     /* 0x32  '2'   */     _N_ | _H_,
                     /* 0x33  '3'   */     _N_ | _H_,
                     /* 0x34  '4'   */     _N_ | _H_,
                     /* 0x35  '5'   */     _N_ | _H_,
                     /* 0x36  '6'   */     _N_ | _H_,
                     /* 0x37  '7'   */     _N_ | _H_,
                     /* 0x38  '8'   */     _N_ | _H_,
                     /* 0x39  '9'   */     _N_ | _H_,
                     /* 0x3A  ':'   */     _P_,
                     /* 0x3B  ';'   */     _P_,
                     /* 0x3C  '<'   */     _P_,
                     /* 0x3D  '='   */     _P_,
                     /* 0x3E  '>'   */     _P_,
                     /* 0x3F  '?'   */     _P_,

                     /* 0x40  '@'   */     _P_,
                     /* 0x41  'A'   */     _U_ | _H_,
                     /* 0x42  'B'   */     _U_ | _H_,
                     /* 0x43  'C'   */     _U_ | _H_,
                     /* 0x44  'D'   */     _U_ | _H_,
                     /* 0x45  'E'   */     _U_ | _H_,
                     /* 0x46  'F'   */     _U_ | _H_,
                     /* 0x47  'G'   */     _U_,
                     /* 0x48  'H'   */     _U_,
                     /* 0x49  'I'   */     _U_,
                     /* 0x4A  'J'   */     _U_,
                     /* 0x4B  'K'   */     _U_,
                     /* 0x4C  'L'   */     _U_,
                     /* 0x4D  'M'   */     _U_,
                     /* 0x4E  'N'   */     _U_,
                     /* 0x4F  'O'   */     _U_,

                     /* 0x50  'P'   */     _U_,
                     /* 0x51  'Q'   */     _U_,
                     /* 0x52  'R'   */     _U_,
                     /* 0x53  'S'   */     _U_,
                     /* 0x54  'T'   */     _U_,
                     /* 0x55  'U'   */     _U_,
                     /* 0x56  'V'   */     _U_,
                     /* 0x57  'W'   */     _U_,
                     /* 0x58  'X'   */     _U_,
                     /* 0x59  'Y'   */     _U_,
                     /* 0x5A  'Z'   */     _U_,
                     /* 0x5B  '['   */     _P_,
                     /* 0x5C  '\'   */     _P_,
                     /* 0x5D  ']'   */     _P_,
                     /* 0x5E  '^'   */     _P_,
                     /* 0x5F  '_'   */     _P_,

                     /* 0x60  '`'   */     _P_,
                     /* 0x61  'a'   */     _L_ | _H_,
                     /* 0x62  'b'   */     _L_ | _H_,
                     /* 0x63  'c'   */     _L_ | _H_,
                     /* 0x64  'd'   */     _L_ | _H_,
                     /* 0x65  'e'   */     _L_ | _H_,
                     /* 0x66  'f'   */     _L_ | _H_,
                     /* 0x67  'g'   */     _L_,
                     /* 0x68  'h'   */     _L_,
                     /* 0x69  'i'   */     _L_,
                     /* 0x6A  'j'   */     _L_,
                     /* 0x6B  'k'   */     _L_,
                     /* 0x6C  'l'   */     _L_,
                     /* 0x6D  'm'   */     _L_,
                     /* 0x6E  'n'   */     _L_,
                     /* 0x6F  'o'   */     _L_,

                     /* 0x70  'p'   */     _L_,
                     /* 0x71  'q'   */     _L_,
                     /* 0x72  'r'   */     _L_,
                     /* 0x73  's'   */     _L_,
                     /* 0x74  't'   */     _L_,
                     /* 0x75  'u'   */     _L_,
                     /* 0x76  'v'   */     _L_,
                     /* 0x77  'w'   */     _L_,
                     /* 0x78  'x'   */     _L_,
                     /* 0x79  'y'   */     _L_,
                     /* 0x7A  'z'   */     _L_,
                     /* 0x7B  '{'   */     _P_,
                     /* 0x7C  '|'   */     _P_,
                     /* 0x7D  '}'   */     _P_,
                     /* 0x7E  '~'   */     _P_,
                     /* 0x7F  DEL   */     _C_,

		     /* 0x80-0x8F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0x90-0x9F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xA0-0xAF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xB0-0xBF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xC0-0xCF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xD0-0xDF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xE0-0xEF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xF0-0xFF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  };

ctype.h/        1202506627  0     0     0       6490      `
/*****************************************************************************/
/* ctype.h    v2.70                                                          */
/* Copyright (c) 1993-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

/************************************************************************/
/*                                                                      */
/*  CHARACTER TYPING FUNCTIONS AND MACROS                               */
/*                                                                      */
/*  Note that in this implementation, either macros or functions may    */
/*  be used.  Macros are prefixed with an underscore.                   */
/*                                                                      */
/************************************************************************/
#ifndef _CTYPE
#define _CTYPE

#include <linkage.h>

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cctype> IS RECOMMENDED OVER <ctype.h>.  <ctype.h> IS PROVIDED FOR
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
extern "C" namespace std
{
#endif /* __cplusplus */

extern _DATA_ACCESS const unsigned char _ctypes_[];

/************************************************************************/
/*   FUNCTION DECLARATIONS                                              */
/************************************************************************/
_IDECL int isalnum(int _c);
_IDECL int isalpha(int _c);
_IDECL int iscntrl(int _c);
_IDECL int isdigit(int _c);
_IDECL int isgraph(int _c);
_IDECL int islower(int _c);
_IDECL int isprint(int _c);
_IDECL int ispunct(int _c);
_IDECL int isspace(int _c);
_IDECL int isupper(int _c);
_IDECL int isxdigit(int _c);
_IDECL int isascii(int _c);

_IDECL int toupper(int _c);
_IDECL int tolower(int _c);
_IDECL int toascii(int _c);

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::_ctypes_;
using std::isalnum;
using std::isalpha;
using std::iscntrl;
using std::isdigit;
using std::isgraph;
using std::islower;
using std::isprint;
using std::ispunct;
using std::isspace;
using std::isupper;
using std::isxdigit;
using std::isascii;
using std::toupper;
using std::tolower;
using std::toascii;
#endif /* ! _CPP_STYLE_HEADER */

#endif /* __cplusplus */

/************************************************************************/
/*  MACRO DEFINITIONS                                                   */
/************************************************************************/
#define _U_   0x01
#define _L_   0x02
#define _N_   0x04
#define _S_   0x08
#define _P_   0x10
#define _C_   0x20
#define _H_   0x40
#define _B_   0x80

#define _isalnum(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_))
#define _isalpha(a)  (_ctypes_[(a)+1] & (_U_ | _L_))
#define _iscntrl(a)  (_ctypes_[(a)+1] & _C_)
#define _isdigit(a)  (_ctypes_[(a)+1] & _N_)
#define _isgraph(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_ | _P_))
#define _islower(a)  (_ctypes_[(a)+1] & _L_)
#define _isprint(a)  (_ctypes_[(a)+1] & (_B_ | _U_ | _L_ | _N_ | _P_))
#define _ispunct(a)  (_ctypes_[(a)+1] & _P_)
#define _isspace(a)  (_ctypes_[(a)+1] & _S_)
#define _isupper(a)  (_ctypes_[(a)+1] & _U_)
#define _isxdigit(a) (_ctypes_[(a)+1] & _H_)
#define _isascii(a)  (((a) & ~0x7F) == 0)

#define _toupper(b)  ((_islower(b)) ? (b) - ('a' - 'A') : (b))
#define _tolower(b)  ((_isupper(b)) ? (b) + ('a' - 'A') : (b))
#define _toascii(a)  ((a) & 0x7F)

#ifdef _INLINE

#ifdef __cplusplus
using std::_ctypes_;
namespace std {
#endif /* __cplusplus */

static __inline int isalnum(int c)  { return(_isalnum(c)); }
static __inline int isalpha(int c)  { return(_isalpha(c)); }
static __inline int isascii(int c)  { return(_isascii(c)); }
static __inline int iscntrl(int c)  { return(_iscntrl(c)); }
static __inline int isdigit(int c)  { return(_isdigit(c)); }
static __inline int isgraph(int c)  { return(_isgraph(c)); }
static __inline int islower(int c)  { return(_islower(c)); }
static __inline int isprint(int c)  { return(_isprint(c)); }
static __inline int ispunct(int c)  { return(_ispunct(c)); }
static __inline int isspace(int c)  { return(_isspace(c)); }
static __inline int isupper(int c)  { return(_isupper(c)); }
static __inline int isxdigit(int c) { return(_isxdigit(c));}
static __inline int toascii(int c)  { return(_toascii(c)); }

/****************************************************************************/
/*  tolower                                                                 */
/****************************************************************************/
static __inline int tolower(int ch)
{
   /*
    This code depends on two assumptions: (1) all of the letters of the
    alphabet of a given case are contiguous, and (2) the lower and upper
    case forms of each letter are displaced from each other by the same
    constant value.
   */

   if ( (unsigned int)(ch - 'A') <= (unsigned int)('Z' - 'A')) ch += 'a' - 'A';
   return ch;
}

/****************************************************************************/
/*  toupper                                                                 */
/****************************************************************************/
static __inline int toupper(int ch)
{
   /*
    This code depends on two assumptions: (1) all of the letters of the
    alphabet of a given case are contiguous, and (2) the lower and upper
    case forms of each letter are displaced from each other by the same
    constant value.
   */

   if ( (unsigned int)(ch - 'a') <= (unsigned int)('z' - 'a')) ch -= 'a' - 'A';
   return ch;
}

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _INLINE */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::_ctypes_;
using std::isalnum;
using std::isalpha;
using std::iscntrl;
using std::isdigit;
using std::isgraph;
using std::islower;
using std::isprint;
using std::ispunct;
using std::isspace;
using std::isupper;
using std::isxdigit;
using std::isascii;
using std::toupper;
using std::tolower;
using std::toascii;
#endif /* ! _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif /* ! _CTYPE */
defs.c/         1202506627  0     0     0       2875      `
/*****************************************************************************/
/*  DEFS.C v2.70                                                             */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file defines some data structures declared in stdio.h.            */
/*****************************************************************************/
#include <stdio.h>

/*---------------------------------------------------------------------------*/
/* Define the streams for stdin, stdout, and stderr, and assign them as the  */
/* first three streams in _FTABLE upon its initialization.                   */
/*---------------------------------------------------------------------------*/
_DATA_ACCESS
FILE _ftable[_NFILE] = {{  0, NULL, NULL, NULL, NULL, (_MODER | _IOLBF), 0},
                        {  1, NULL, NULL, NULL, NULL, (_MODEW | _IOLBF), 1},
                        {  2, NULL, NULL, NULL, NULL, (_MODEW | _IONBF), 2},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           3},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           4},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           5},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           6},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           7},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           8},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           9},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           10},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           11},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           12},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           13},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           14},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           15},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           16},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           17},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           18},
			{ -1, NULL, NULL, NULL, NULL,  _IONBF,           19} };

/*---------------------------------------------------------------------------*/
/* Allocate a table to store the filenames of temporary files, so they can   */
/* be deleted when they are closed.                                          */
/*---------------------------------------------------------------------------*/
_DATA_ACCESS char _tmpnams[_NFILE][L_tmpnam];

/*---------------------------------------------------------------------------*/
/* This global variable _FT_END is used to mark the end of used streams in   */
/* the file table.                                                           */
/*---------------------------------------------------------------------------*/
_DATA_ACCESS int _ft_end = 3; 

del_af.cpp/     1202506627  0     0     0       821       `
/*****************************************************************************/
/* del_af     v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <new>

/****************************************************************************/
/*                                                                          */
/* OPERATOR DELETE[]() - DEFAULT GLOBAL DEALLOCATION FUNCTION FOR ARRAYS.   */
/*                                                                          */
/****************************************************************************/
void  operator delete[](void *ptr) // throw()
{
   operator delete(ptr);
}

del_afn.cpp/    1202506627  0     0     0       939       `
/*****************************************************************************/
/* del_afn     v2.70                                                         */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <new>

/****************************************************************************/
/*                                                                          */
/* OPERATOR DELETE[]() - NO EXCEPTION VERSION OF THE DEFAULT GLOBAL         */
/*                       DEALLOCATION FUNCTION FOR ARRAYS.                  */
/*                                                                          */
/****************************************************************************/
void  operator delete[](void *ptr, const std::nothrow_t& nt_arg) // throw()
{
   operator delete(ptr, nt_arg);
}

del_afp.cpp/    1202506627  0     0     0       879       `
/*****************************************************************************/
/* del_af     v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <new>

/****************************************************************************/
/*                                                                          */
/* OPERATOR DELETE[]() - PLACEMENT VERSION OF THE DEFAULT GLOBAL            */
/*                       DEALLOCATION FUNCTION FOR ARRAYS.                  */
/*                                                                          */
/****************************************************************************/
void operator delete[](void *ptr, void*) // throw()
{}

del_sof.cpp/    1202506627  0     0     0       903       `
/*****************************************************************************/
/* del_sof  v2.70                                                            */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <new>

/****************************************************************************/
/*                                                                          */
/* OPERATOR DELETE() - DEFAULT GLOBAL DEALLOCATION FUNCTION FOR SINGLE      */
/*                     OBJECTS.                                             */
/*                                                                          */
/****************************************************************************/
void  operator delete(void *ptr) // throw()
{
   if (ptr)  std::free(ptr);
}

del_sofn.cpp/   1202506627  0     0     0       926       `
/*****************************************************************************/
/* del_sofn  v2.70                                                           */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <new>

/****************************************************************************/
/*                                                                          */
/* OPERATOR DELETE() - NO EXCEPTION VERSION OF THE DEFAULT GLOBAL           */
/*                     DEALLOCATION FUNCTION FOR SINGLE OBJECTS.            */
/*                                                                          */
/****************************************************************************/
void  operator delete(void *ptr, const std::nothrow_t&) // throw()
{
   if (ptr)  std::free(ptr);
}
del_sofp.cpp/   1202506627  0     0     0       879       `
/*****************************************************************************/
/* del_sofp  v2.70                                                           */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <new>

/****************************************************************************/
/*                                                                          */
/* OPERATOR DELETE() - PLACEMENT VERSION OF THE DEFAULT GLOBAL DEALLOCATION */
/*                     FUNCTION FOR OBJECTS.                                */
/*                                                                          */
/****************************************************************************/
void operator delete  (void *ptr, void*) // throw()
{}

difftime.c/     1202506627  0     0     0       849       `
/****************************************************************************/
/*  difftime v2.70                                                          */
/*  Copyright (c) 1996-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#undef _INLINE
#include <time.h> 

_CODE_ACCESS double difftime(time_t time1, time_t time0)
{
    /*----------------------------------------------------------------------*/
    /* THE FOLLOWING CONVERSION INSURES THAT ANY POSSIBLE DIFFERENCE IN THE */
    /* RANGE OF UNSIGNED LONG IS PROPERLY REPRESENTED IN THE RESULT.        */
    /*----------------------------------------------------------------------*/
    return ((time1 > time0) ?  (double)(time1 - time0)
	                    : -(double)(time0 - time1));
}

div.c/          1202506627  0     0     0       742       `
/****************************************************************************/
/*  div ldiv    v2.70                                                       */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>

div_t div(int numer, int denom)
{
    div_t result;

    if (denom == 0) return;

    result.quot = numer / denom;
    result.rem  = numer - (result.quot * denom);
    return result;
}

ldiv_t ldiv(long numer, long denom)
{
    ldiv_t result;

    if (denom == 0) return;

    result.quot = numer / denom;
    result.rem  = numer - (result.quot * denom);
    return result;
}

ecvt.c/         1202506627  0     0     0       2817      `
/****************************************************************************/
/*  ecvt v2.70                                                              */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>

int ltoa(long val, char *buffer);

char *ecvt(long double value, int ndigit, int *decpt, int *sign)

{
    static char out[100]; 

    int   digits = 0;         /* NUMBER OF DIGITS BEFORE .       */
    char *pos    = out + 1;     
    int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* IF TRYING TO CONVERT INFINITY, RETURN HUGE_VALL OF PROPER SIGN     */
    /*--------------------------------------------------------------------*/
    { 
       int *ptr = (int *)&value;

       if (((*ptr >> 20) & 0x7ff) == 0x7ff) 
	  value = (*ptr & 0x80000000) ? -HUGE_VALL : HUGE_VALL;
    }

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos    += temp    = ltoa((long)value, pos);
    *decpt  = digits + temp;

    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    if (temp >= ndigit) 
	 pos = out + ndigit + 1;
    else if ((ndigit -= temp) > 0) do
    {
         value -= (int) value;
	 *pos++ = (int)(value *= 10.0) + '0';
    }
    while (--ndigit);

    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*--pos >= '5')
    {
	char *ptr = pos;
	while ((*--ptr += 1) > '9') *ptr = '0';
	if (ptr == out) { *--pos = 0; *decpt += 1; return(out); }
    }
	
    *pos = 0;
    return out + 1;
}


errno.c/        1202506627  0     0     0       375       `
/*****************************************************************************/
/*  errno    v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                  */
/*****************************************************************************/
#include <errno.h>

_DATA_ACCESS int errno = 0;

errno.h/        1202506627  0     0     0       1225      `
/*****************************************************************************/
/*  ERRNO.H  v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

#ifndef _ERRNO
#define _ERRNO

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cerrno> IS RECOMMENDED OVER <errno.h>.  <errno.h> IS PROVIDED FOR
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
extern "C" namespace std
{
#endif /* __cplusplus */

#include <linkage.h>

#define errno errno
extern _DATA_ACCESS int errno;

#define EDOM   1
#define ERANGE 2
#define ENOENT 3
#define EFPOS  5
#define EILSEQ 6

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::errno;
#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::errno;
#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif  /* _ERRNO */

exception/      1202506627  0     0     0       376       `
/*****************************************************************************/
/* exception  v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _EXCEPTION
#define _EXCEPTION

#endif
exit.c/         1202506627  0     0     0       4052      `
/****************************************************************************/
/*  EXIT.C v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <_lock.h>

#define MAX_FUN   32

static int    at_exit_count = 0;
static void (*at_exit_fun[MAX_FUN])();
void        (*_cleanup_ptr)(void) = NULL;
void   _DATA_ACCESS      (*_dtors_ptr)(void)   = NULL;

/****************************************************************************/
/*                                                                          */
/* LOADER_EXIT -							    */
/* 									    */
/* SET C$$EXIT LABEL SO THE DEBUGGER KNOWS WHEN THE C++ PROGRAM HAS	    */
/* COMPLETED.  THIS CAN BE REMOVED IF THE DEBUGGER IS NOT USED.		    */
/*                                                                          */
/****************************************************************************/
static void loader_exit(void)
{
#if defined(EMBED_CIO_BP)
   __asm("         .global C$$EXITE");
#if defined(__32bis__)
   __asm("C$$EXITE:.word 0xDEFED0FE");
#else
   __asm("	 .align  4");
#if defined(__big_endian__)
   __asm("C$$EXITE:.half 0xDEFE");
#else
   __asm("C$$EXITE:.half 0xD0FE");
#endif /* __big_endian__ */
#endif /* __32bis__      */

#else  /* !EMBED_CIO_BP */
   __asm("        .global C$$EXIT");
   __asm("C$$EXIT: nop");
#endif
}

/****************************************************************************/
/* EXIT() - NORMAL PROGRAM TERMINATION.                                     */
/****************************************************************************/
void exit(int status)        
{
   int i;

   /*-------------------------------------------------------------------*/
   /* MUST LOCK WHEN ACCESSING at_exit_count.                           */
   /*-------------------------------------------------------------------*/
   _lock();
   i = at_exit_count;

   /*-------------------------------------------------------------------*/
   /* HANDLE FUNCTIONS REGISTERED THROUGH atexit().                     */
   /*-------------------------------------------------------------------*/
   while (i) (*at_exit_fun[--i])(); 

   /*-------------------------------------------------------------------*/
   /* IF THERE ARE STATIC DESTRUCTORS, CALL THEM.                       */
   /*-------------------------------------------------------------------*/
   if (_dtors_ptr)  (*_dtors_ptr)();

   /*-------------------------------------------------------------------*/
   /* IF FILES ARE POSSIBLY OPEN, _CLEANUP_PTR() WILL BE SETUP TO CLOSE */
   /* THEM.                                                             */
   /*-------------------------------------------------------------------*/
   if (_cleanup_ptr)  (*_cleanup_ptr)();

   loader_exit();

   for (;;);   /* CURRENTLY, THIS SPINS FOREVER */
}

/****************************************************************************/
/* ATEXIT - ATTEMPT TO REGISTER A FUNCTION FOR CALLING AT PROGRAM END       */
/****************************************************************************/
int atexit(void (*fun)())
{
   /*-------------------------------------------------------------------*/
   /* MUST LOCK WHEN ACCESSING at_exit_count AND at_exit_fun.           */
   /*-------------------------------------------------------------------*/
   _lock();
   if (at_exit_count >= MAX_FUN) {
      _unlock();
      return 1;
   }
   at_exit_fun[at_exit_count++] = fun;
   _unlock();
   return 0;
}

/****************************************************************************/
/* ABORT - ABNORMAL PROGRAM TERMINATION.  CURRENTLY JUST HALTS EXECUTION.   */
/****************************************************************************/
void abort(void)
{
    loader_exit();
    for (;;);   /* SPINS FOREVER */
}
exp.c/          1202506627  0     0     0       2724      `
/****************************************************************************/
/*  exp    v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  EXP() - e ^ x							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 6.              */
/*									    */
/*  N = round(x / ln(2))						    */
/*  g = x - N * ln(2)							    */
/*  z = g * g								    */
/*									    */
/*  R = polynomial expansion						    */
/*									    */
/*  result = R * 2 ^ (N	+ 1)						    */
/****************************************************************************/
double exp(double x)
{
    double g, z, q, p;
    int n;

    /*************************************************************************/
    /* check if input would produce output out of the range of this function */
    /*************************************************************************/
    if (x > MAXX) { errno = ERANGE; return (HUGE_VAL); }

    if (x < 0) n = (int) (x * INVLOGe2 - 0.5);    /* since (int) -1.5 = -1.0 */
    else       n = (int) (x * INVLOGe2 + 0.5);

    /*************************************************************************/
    /* g = x - n * ln(2) (but more mathematically stable)                    */
    /*************************************************************************/
    g  = (x - n * C3) - n * C4;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    z  = g * g;

#if BITS <=29
    p = (EXP1 * z + EXP0) * g;
    q = EXQ1 * z + EXQ0;
#elif BITS>=30 && BITS<=42
    p = (EXP1 * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#elif BITS>=43 && BITS<=56
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#else
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = ((EXQ3 * z + EXQ2) * z + EXQ1) * z + EXQ0;
#endif

    /*************************************************************************/
    /* exp(x) = exp(g) * 2 ^ (n + 1)                                         */
    /*************************************************************************/
    return ldexp(0.5 + p / (q - p), n + 1); 
}
fabs.c/         1202506627  0     0     0       845       `
/****************************************************************************/
/*  FABS   v2.70                                                            */
/*  Copyright (c) 1993-2008 Texas Instruments Incorporated                  */
/****************************************************************************/

#include <math.h>

/****************************************************************************/
/*  FABS() - Floating Point Absolute Value				    */
/*									    */
/*  The definition below is NOT a recursive definition!  The compiler       */
/*  generates calls to fabs() inline, using a single ABS instruction.       */
/****************************************************************************/
double fabs(double x)
{
    return fabs(x);        /* This will be generated inline by the compiler */
}

fclose.c/       1202506627  0     0     0       3774      `
/*****************************************************************************/
/*  FCLOSE.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    Functions:                                                             */
/*       FCLOSE   -  Close a stream                                          */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>
#include <stdlib.h>

extern int _doflush(FILE *_fp);


/*****************************************************************************/
/* FCLOSE   -  Close a stream                                                */
/*                                                                           */
/*    This function flushes the current stream, deallocates any buffers      */
/*    associated with the stream, and closes it.  This function returns a 0  */
/*    if the close was successful, or an EOF if an error occured.            */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int fclose(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int fd = _fp->fd;
   int errchk;
   int remove_flag = _STCHK(_fp, _TMPFILE);

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* Flush the buffer.                                                      */
   /*------------------------------------------------------------------------*/
   if(_doflush(_fp)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* Free the buffer if there was one, and it was malloc'd by SETVBUF.      */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _BUFFALOC))
   {
      free((_fp->buf)-1);
      _UNSET(_fp, _BUFFALOC);
   }

   /*------------------------------------------------------------------------*/
   /* Reset the buffer pointers in the stream.                               */
   /*------------------------------------------------------------------------*/
   _fp->buf = NULL;
   _fp->pos = NULL;
   _fp->bufend = NULL;

   /*------------------------------------------------------------------------*/
   /* Close the file, and give the FILE structure an invalid file descriptor */
   /* so it cannot be used until it is assigned to another stream.           */
   /*------------------------------------------------------------------------*/
   errchk = close(_fp->fd);
   _fp->fd = -1;

   /*------------------------------------------------------------------------*/
   /* If the FILE pointer was associated with a temporary file, look up that */
   /* temporary file's filename, and remove it.                              */
   /*------------------------------------------------------------------------*/
   if(remove_flag) remove(_tmpnams[fd]);  

   return (errchk);
}

fcvt.c/         1202506627  0     0     0       3174      `
/****************************************************************************/
/*  fcvt v2.70                                                              */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <ctype.h>
#include <math.h>

int ltoa(long val, char *buffer);

char *fcvt(long double value, int ndigit, int *decpt, int *sign)

{
    static char out[400]; 

    int   digits = 0;         /* NUMBER OF DIGITS BEFORE .       */
    char *pos    = out + 1;     
    int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* IF TRYING TO CONVERT INFINITY, RETURN HUGE_VALL OF PROPER SIGN     */
    /*--------------------------------------------------------------------*/
    { 
       int *ptr = (int *)&value;

       if (((*ptr >> 20) & 0x7ff) == 0x7ff) 
	  value = (*ptr & 0x80000000) ? -HUGE_VALL : HUGE_VALL;
    }

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos   += temp    = ltoa((long)value, pos);
    *decpt = digits + temp; 

    /*--------------------------------------------------------------------*/
    /* ndigit MAY BE AFFECTED BY PRE-SCALING ...                          */
    /*--------------------------------------------------------------------*/
    ndigit += digits;

    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    if (ndigit > 0) do
    {
         value -= (int)value;
         *pos++ = (int)(value *= 10.0) + '0';
    }
    while (--ndigit);

    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*--pos >= '5')
    {
       char *ptr = pos;
       while ((*--ptr += 1) > '9') *ptr = '0';
       
       if (ptr == out) 
       {
          if (pos > out) *pos   = 0;
          else           out[1] = 0;
          
          *decpt += 1;
          return out;
       }
    }
	
    *pos = 0;
    return out + 1;
}

fd_add16.asm/   1202506627  0     0     0       9678      `
;******************************************************************************
;* FS_ADD16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;******************************************************************************
;* FD_ADD/FD_SUB - ADD / SUBTRACT TWO IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;*   	           POINT NUMBERS.
;******************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1
;*   o INPUT OP2 IS IN r2:r3
;*   o RESULT IS RETURNED IN r0:r1
;*   o INPUT OP2 IN r2:r3 IS PRESERVED
;*
;*   o SUBTRACTION, OP1 - OP2, IS IMPLEMENTED WITH ADDITION, OP1 + (-OP2)
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY 
;*       (0x7ff00000:00000000) or (0xfff00000:00000000) 
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;*   o IF OPERATION INVOLVES INFINITY AS AN INPUT, THE FOLLOWING SUMMARIZES
;*     THE RESULT:
;*                   +----------+----------+----------+ 
;*         ADDITION  + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   -INF   +   +INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |   -INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +   +INF   +
;*        +----------+----------+----------+----------+
;*
;*                   +----------+----------+----------+ 
;*       SUBTRACTION + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   +INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |   -INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +   +INF   +
;*        +----------+----------+----------+----------+
;*
;****************************************************************************
*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global	FD$ADD
	.global	FD$SUB

shift	.set	r0	; OVERLOADED WITH INPUT #1
op1e	.set	r1	; OVERLOADED WITH INPUT #1
op1m1	.set	r2	; OVERLOADED WITH INPUT #2
op1m2	.set	r3	; OVERLOADED WITH INPUT #2
tmp	.set	r4
op2m1	.set	r5
op2m2	.set	r6
op2e	.set	r7


FD$SUB:	.asmfunc stack_usage(24)

	PUSH	{r2-r7}			;
	MOV	tmp, #0x1		;
	LSL	tmp, tmp, #31		;
	EOR	r2, tmp			; NEGATE INPUT #2
	B	ct			;

FD$ADD:	PUSH	{r2-r7}			;
	MOV	tmp, #0x1		;
	LSL	tmp, tmp, #31		;

ct:	PUSH	{r2}			; SAVE MODIFIED INPUT #2

	LSL	op2m1, r2, #12		; BUILD INPUT #2 MANTISSA
	LSR	op2m1, op2m1, #3	;
	LSR	op2m2, r3, #23		;
	ORR	op2m1, op2m2		;
	LSL	op2m2, r3, #9		;
	LSL	op2e, r2, #1		; BUILD INPUT #2 EXPONENT
	LSR	op2e, op2e, #21		;
	BNE	$1			;

	MOV	tmp, op2m1		; IF DENORMALIZED NUMBER (op2m != 0 AND
        ORR     tmp, op2m2		; op2e == 0), THEN UNDERFLOW
	BNE	unfl			;
	ADD	sp, #4			;
        POP	{r2-r7}		        ; ELSE IT IS ZERO SO RETURN INPUT #1
	MOV	pc, lr			;

$1:	LSR	tmp, tmp, #2		; SET IMPLIED ONE IN MANTISSA
	ORR	op2m1, tmp	 	;

	MOV	tmp, #0x7		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	CMP	op2e, tmp		; IF op2e == 0x7FF, THEN OVERFLOW
	BNE	$2			;

	MOV	r1, #0x0		;
	LSR	r0, r2, #20		; PICK UP SIGN AND EXP FROM R2
	LSL	r0, r0, #20
	ADD	sp, #4			;
        POP     {r2-r7}		        ;
	MOV	pc, lr			;

$2:     CMP     r2, #0                  ;
	BPL	$3			; IF INPUT #2 IS NEGATIVE,
	MOV	tmp, #0			;  THEN NEGATE THE MANTISSA
        SUB     op2m2, tmp, op2m2	;
        SBC     tmp, op2m1	        ;
	MOV	op2m1, tmp		;

$3:	LSL	op1m1, r0, #12		; BUILD INPUT #1 MANTISSA
	LSR	op1m1, op1m1, #3	;
	LSR	op1m2, r1, #23		;
	ORR	op1m1, op1m2		;
	LSL	op1m2, r1, #9		;
	LSL	op1e, r0, #1		; BUILD INPUT #1 EXPONENT
	LSR	op1e, op1e, #21		;
	BNE	$4			;

	MOV	tmp, op1m1		; IF DENORMALIZED NUMBER (op1m != 0 AND
        ORR     tmp, op1m2		; op1e == 0), THEN UNDERFLOW
	BNE	unfl			;
	POP	{r0, r2, r3}		; ELSE IT IS ZERO SO RETURN INPUT #2
	MOV 	r1, r3			;
        POP     {r4-r7}  	        ;
	MOV	pc, lr			;

$4:	MOV	tmp, #0x1		; SET IMPLIED ONE IN MANTISSA
	LSL	tmp, tmp, #29		;
	ORR	op1m1, tmp	 	;

	MOV	tmp, #0x7		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	CMP	op1e, tmp		; IF op1e == 0x7FF, THEN OVERFLOW
	BNE	$5

	MOV	r1, #0x0		;
	LSR	r0, r0, #20		; ISOLATE SIGN AND EXP IN R0
	LSL	r0, r0, #20
	ADD	sp, #4			;
        POP	{r2-r7}		        ;
	MOV	pc, lr			;

$5:     CMP     r0, #0                  ;
	BPL	$6			; IF INPUT #1 IS NEGATIVE,
	MOV	tmp, #0			;  THEN NEGATE THE MANTISSA
	SUB	op1m2, tmp, op1m2	;
        SBC     tmp, op1m1	        ;
	MOV	op1m1, tmp		;

$6:     SUB     shift, op1e, op2e       ; GET THE SHIFT AMOUNT
	BPL	norm			;
        MOV     tmp, op1m1              ; IF THE SHIFT AMOUNT IS NEGATIVE, THEN
        MOV     op1m1, op2m1            ;  SWAP THE TWO MANTISSA SO THAT op1m
	MOV  	op2m1, tmp		;  CONTAINS THE LARGER VALUE,
	MOV	tmp, op1m2		;
	MOV	op1m2, op2m2		;
	MOV	op2m2, tmp		;
	MOV	tmp, #0			;
        SUB     shift, tmp, shift       ;  AND NEGATE THE SHIFT AMOUNT,
        MOV     op1e, op2e              ;  AND ENSURE THE LARGER EXP. IS IN op1e

norm:   CMP     shift, #54              ; IF THE SECOND MANTISSA IS SIGNIFICANT,
	BPL	no_add			;

	CMP	shift, #0		; ADJUST THE SECOND MANTISSA, BASED
	BEQ	no_sft			; UPON ITS EXPONENT.

sloop:	LSL	tmp, op2m1, #31		; NORMALIZE THE MANTISSA
	ASR	op2m1, op2m1, #1	;
	LSR	op2m2, op2m2, #1	;
	ORR	op2m2, tmp		;
	SUB	shift, shift, #1	;
	BNE	sloop			;

no_sft:	ADD	op1m2, op1m2, op2m2	; ADD IT TO THE FIRST MANTISSA
	ADC	op1m1, op2m1		;

no_add: MOV	tmp, op1m1		;
	ORR     tmp, op1m2		;
	BEQ	unfl			;

        MOV	tmp, #0x0               ;
	CMP	op1m1, #0		; IF THE RESULT IS POSITIVE, NOTE SIGN
	BPL	nloop			;
        MOV     tmp, #0x1               ; IF THE RESULT IS NEGATIVE, THEN
	MOV	shift, #0		;  NOTE THE SIGN AND
        SUB	op1m2, shift, op1m2     ;  NEGATE THE RESULT
	SBC	shift, op1m1		;
	MOV	op1m1, shift		;
 
nloop:  SUB     op1e, op1e, #1          ; NORMALIZE THE RESULTING MANTISSA
	LSL     op1m2, op1m2, #1 	; ADJUSTING THE EXPONENT AS NECESSARY
	ADC	op1m1, op1m1		; 
        BPL     nloop                   ;
 
	MOV	op2e, #0x0		;
	MOV	shift, #0x1		;
	LSL	shift, shift, #10	;
        ADD     op1m2, op1m2, shift     ; ROUND THE MANTISSA TO THE NEAREST
	ADC	op1m1, op2e		;
	BCC	$7			;
        ADD     op1e, op1e, #1          ; ADJUST EXPONENT IF AN OVERFLOW OCCURS
	B	$8			;
$7:     LSL     op1m2, op1m2, #1 	; REMOVE THE IMPLIED ONE
	ADC	op1m1, op1m1		;
 
$8:     ADD     op1e, op1e, #2          ; NORMALIZE THE EXPONENT
	BLE	unfl			; CHECK FOR UNDERFLOW
	MOV	shift, #0x7		;
	LSL	shift, shift, #8	;
	ADD	shift, #0xFF		;
        CMP     op1e, shift             ; CHECK FOR OVERFLOW
	BCC	$9			;

	POP	{r0, r2, r3}		; OVERFLOW
	MOV	r1, #0x0		;
	LSR	r0, r0, #31
	LSL	r0, r0, #8
	ADD	r0, #0xFF
	LSL	r0, r0, #3
	ADD	r0, r0, #7
	LSL	r0, r0, #20
        POP     {r4-r7}	                ;
	MOV	pc, lr			;
 
$9:	LSR	r0, op1m1, #12		; REPACK THE MANTISSA INTO r0:r1
	LSL	op1e, op1e, #20		;
        ORR     r0, op1e		; REPACK THE EXPONENT INTO r0
	LSL	tmp, tmp, #31		;
        ORR     r0, tmp 		; REPACK THE SIGN INTO r0
        LSL	r1, op1m1, #20		;
	LSR	op1m2, op1m2, #12	;
	ORR	r1, op1m2		;

	ADD	sp, #4			;
        POP	{r2-r7}	        	;
	MOV	pc, lr			;

unfl:   MOV     r0, #0                  ; UNDERFLOW, SO RETURN ZERO
	MOV	r1, #0			;
	ADD	sp, #4			;
        POP     {r2-r7}			;
	MOV	pc, lr			;

	.endasmfunc

        .end
fd_add32.asm/   1202506627  0     0     0       9147      `
;******************************************************************************
;* FD_ADD32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;*****************************************************************************
;* FD_ADD/FD_SUB - ADD / SUBTRACT TWO IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;* 	           POINT NUMBERS.
;*****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1
;*   o INPUT OP2 IS IN r2:r3
;*   o RESULT IS RETURNED IN r0:r1
;*   o INPUT OP2 IN r2:r3 IS PRESERVED
;*
;*   o SUBTRACTION, OP1 - OP2, IS IMPLEMENTED WITH ADDITION, OP1 + (-OP2)
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY 
;*       (0x7ff00000:00000000) or (0xfff00000:00000000) 
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;*   o IF OPERATION INVOLVES INFINITY AS AN INPUT, THE FOLLOWING SUMMARIZES
;*     THE RESULT:
;*                   +----------+----------+----------+ 
;*         ADDITION  + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   -INF   +   +INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |   -INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +   +INF   +
;*        +----------+----------+----------+----------+
;*
;*                   +----------+----------+----------+ 
;*       SUBTRACTION + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   +INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |   -INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +   +INF   +
;*        +----------+----------+----------+----------+
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state32
	.global	FD_ADD
	.global FD_SUB

op1m1	.set	r4
op1m2	.set	r5
op1e	.set	r6
op2m1	.set	r7
op2m2	.set	r8
op2e	.set	r9
shift	.set	r10
tmp	.set	lr

FD_SUB: .asmfunc stack_usage(40)
	STMFD	sp!, {r2-r10, lr}	;
	EOR	r2, r2, #0x80000000	; NEGATE SECOND OPERAND
	B	_start			;

FD_ADD:
	STMFD	sp!, {r2-r10, lr}	;
	
_start:	MOV	op2m1, r2, LSL #12		; BUILD INPUT #2 MANTISSA
	MOV	op2m1, op2m1, LSR #3		;
	ORR	op2m1, op2m1, r3, LSR #23	;
	MOV	op2m2, r3, LSL #9		;
	MOV	op2e, r2, LSL #1		; BUILD INPUT #2 EXPONENT
	MOVS	op2e, op2e, LSR #21		;
	BNE	$1				;

        ORR     tmp, op2m1, op2m2	; IF DENORMALIZED NUMBER (op2m != 0 AND
        MOVNE   r0, #0                  ; op2e == 0), THEN UNDERFLOW
	MOVNE	r1, #0			;
        LDMFD   sp!, {r2-r10, pc}       ; ELSE IT IS ZERO SO RETURN INPUT #1

$1:	ORR	op2m1, op2m1, #0x20000000 	; SET IMPLIED ONE IN MANTISSA
	MOV	shift, #0x700		; INITIALIZE shift WITH 0x7FF
	ADD	shift, shift, #0xFF	;
	CMP	op2e, shift		; IF op2e == 0x7FF, THEN OVERFLOW
	BNE	$2			;
	MOV	r1, #0			;
	MOV	r0, r2, LSR #20
	MOV	r0, r0, LSL #20
        LDMFD   sp!, {r2-r10, pc}       ;

$2:     CMP     r2, #0                  ;
	BPL	$3			; IF INPUT #2 IS NEGATIVE,
        RSBS    op2m2, op2m2, #0        ;  THEN NEGATE THE MANTISSA
        RSC     op2m1, op2m1, #0        ;

$3:	MOV	op1m1, r0, LSL #12		; BUILD INPUT #1 MANTISSA
	MOV	op1m1, op1m1, LSR #3		;
	ORR	op1m1, op1m1, r1, LSR #23	;
	MOV	op1m2, r1, LSL #9		;
	MOV	op1e, r0, LSL #1		; BUILD INPUT #1 EXPONENT
	MOVS	op1e, op1e, LSR #21		;
	BNE	$4				;

        ORR     tmp, op1m1, op1m2	; IF DENORMALIZED NUMBER (op1m != 0 AND
        MOVNE   r0, #0                  ; op1e == 0), THEN UNDERFLOW
	MOVNE	r1, #0			;
        MOVEQ   r0, r2                  ; ELSE IT IS ZERO SO RETURN INPUT #2
	MOVEQ	r1, r3			;
        LDMFD   sp!, {r2-r10, pc}       ;

$4:	ORR	op1m1, op1m1, #0x20000000 	; SET IMPLIED ONE IN MANTISSA
	CMP	op1e, shift		; IF op1e == 0x7FF, THEN OVERFLOW
	BNE	$5			;
	MOV	r1, #0			;
	MOV	r0, r0, LSR #20
	MOV	r0, r0, LSL #20
        LDMFD   sp!, {r2-r10, pc}       ;

$5:     CMP     r0, #0                  ;
	BPL	$6			; IF INPUT #1 IS NEGATIVE,
        RSBS    op1m2, op1m2, #0        ;  THEN NEGATE THE MANTISSA
        RSC     op1m1, op1m1, #0        ;

$6:     SUBS    shift, op1e, op2e       ; GET THE SHIFT AMOUNT
	BPL	$7			;
        MOV     tmp, op1m1              ; IF THE SHIFT AMOUNT IS NEGATIVE, THEN
        MOV     op1m1, op2m1            ;  SWAP THE TWO MANTISSA SO THAT op1m
	MOV  	op2m1, tmp		;  CONTAINS THE LARGER VALUE,
	MOV	tmp, op1m2		;
	MOV	op1m2, op2m2		;
	MOV	op2m2, tmp		;
        RSB     shift, shift, #0        ;  AND NEGATE THE SHIFT AMOUNT,
        MOV     op1e, op2e              ;  AND ENSURE THE LARGER EXP. IS IN op1e

$7:     CMP     shift, #54              ; IF THE SECOND MANTISSA IS SIGNIFICANT,
	BPL	no_add			;

	CMP	shift, #0		; ADJUST THE SECOND MANTISSA, BASED
	BEQ	no_sft			; UPON ITS EXPONENT.

sloop:	MOVS	op2m1, op2m1, ASR #1	;
	MOV	op2m2, op2m2, RRX	;
	SUBS	shift, shift, #1	;
	BNE	sloop

no_sft:	ADDS	op1m2, op1m2, op2m2	; ADD IT TO THE FIRST MANTISSA
	ADCS	op1m1, op1m1, op2m1	;

no_add: ORRS    tmp, op1m1, op1m2	;
        MOVEQ   r0, #0                  ; IF THE RESULT IS ZERO, 
	MOVEQ	r1, #0			;
        LDMEQFD sp!, {r2-r10, pc}       ;  THEN UNDERFLOW

	CMP	op1m1, #0		;
        MOVPL   tmp, #0x0               ; IF THE RESULT IS POSITIVE, NOTE SIGN
	BPL	nloop			;
        MOV     tmp, #0x1               ; IF THE RESULT IS NEGATIVE, THEN
        RSBS    op1m2, op1m2, #0x0      ;  NOTE THE SIGN AND
	RSC	op1m1, op1m1, #0x0	;  NEGATE THE RESULT
 
nloop:  MOVS    op1m2, op1m2, LSL #1    ; NORMALIZE THE RESULTING MANTISSA
	ADCS	op1m1, op1m1, op1m1	; 
        SUB     op1e, op1e, #1          ; ADJUSTING THE EXPONENT AS NECESSARY
        BPL     nloop                   ;
 
        ADDS    op1m2, op1m2, #0x400    ; ROUND THE MANTISSA TO THE NEAREST
	ADCS	op1m1, op1m1, #0	;
        ADDCS   op1e, op1e, #1          ; ADJUST EXPONENT IF AN OVERFLOW OCCURS
	BCS	ovfl			;
        MOVS    op1m2, op1m2, LSL #1    ; REMOVE THE IMPLIED ONE
	ADC	op1m1, op1m1, op1m1	;
 
ovfl:   ADDS    op1e, op1e, #2          ; NORMALIZE THE EXPONENT
        MOVLE   r0, #0                  ; CHECK FOR UNDERFLOW
	MOVLE	r1, #0			;
        LDMLEFD sp!, {r2-r10, pc}       ;
	MOV	shift, #0x700		;
	ADD	shift, shift, #0xFF	;
        CMP     op1e, shift             ; CHECK FOR OVERFLOW
	BCC	$9
	MOV	r1, #0			;
	AND	r2, r2, #0x80000000
	MOV	r0, #0xFF
	MOV	r0, r0, LSL #3
	ADD	r0, r0, #7
	MOV	r0, r0, LSL #20
	ORR	r0, r0, r2
        LDMFD   sp!, {r2-r10, pc}       ;
 
$9:     MOV	op2m1, op1m1, LSL #20	; REPACK THE MANTISSA INTO r0:r1
	ORR	r1, op2m1, op1m2, LSR #12 ;
	MOV	r0, op1m1, LSR #12	;
        ORR     r0, r0, op1e, LSL #20   ; REPACK THE EXPONENT INTO r0
        ORR     r0, r0, tmp, LSL #31    ; REPACK THE SIGN INTO r0
 
        LDMFD   sp!, {r2-r10, pc}       ;
 
	.endasmfunc

        .end

fd_cmp16.asm/   1202506627  0     0     0       5658      `
;******************************************************************************
;* FD_CMP16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************
 
;****************************************************************************
;* FD$CMP - COMPARE TWO IEEE 754 FORMAT DOUBLE PRECISION FLOATING POINT 
;*          NUMBERS, SETTING THE STATUS ON THE RESULT.
;*
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1
;*   o INPUT OP2 IS IN r2:r3
;*   o INPUTS ARE NOT DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o +0 == -0
;*
;*   o IF COMPUTING THE RESULT INVOLVES INFINITIES, THE FOLLOWING TABLE
;*     SUMMARIZES THE EFFECTIVE RESULT
;*                   +----------+----------+----------+ 
;*                   + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   +INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |    -0    +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +    +0    +
;*        +----------+----------+----------+----------+
;*
;*   o THE RESULT OF THE COMPARE IS COMPUTED USING INTEGER SUBRACT IF THE
;*     SIGN OF THE INPUTS IS THE SAME.  THE TABLE SUMMARIZES THE 
;*     IMPLEMENTATION.
;*                 +-----------+-----------+ 
;*                 +   OP2 +   |   OP2 -   +
;*        +--------+===========+===========+ 
;*        + OP1 +  + OP1 - OP2 |    OP1    + 
;*        +--------+-----------+-----------+ 
;*        + OP1 -  +    OP1    | OP2 - OP1 + 
;*        +--------+-----------+-----------+ 
;*
;*   o THE FOLLOWING STATUS BITS ARE SET ON THE RESULT
;*     o Z=1,N=0,V=0  IFF 0
;*     o Z=0,N=1,V=0  IFF -
;*     o Z=0,N=0,V=0  IFF +
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
         .state16

         .global FD$CMP

tmp	.set	r4
tmp2	.set	r5

FD$CMP: .asmfunc stack_usage(8)
	PUSH	{r4, r5}		;

	CMP	r0, r2			; HANDLE THE CASE OF BOTH INPUTS EQUAL 
	BNE	$1			;
	CMP	r1, r3			;
	BEQ	exit			;

$1:	MOV	tmp, r1			;
	ORR	tmp, r3			; HANDLE THE CASE OF BOTH INPUTS BEING
	BNE	$2			; ZERO
	MOV	tmp, r0			;
	ORR	tmp, r2			;
	LSL	tmp, tmp, #1		;
	CMP	tmp, #0x0		;
	BEQ	exit			;

$2:	LSL	tmp, r0, #1		; TEST OP1 == 0
	ORR	tmp, r1			; 
	BNE	$3			;

	CMP	tmp, r2			; OP1 == 0, DISREGARD SIGN OF OP1
	POP	{r4, r5}		; WHEN COMPUTING RESULT STATUS
	MOV	pc, lr			;

$3:	LSL	tmp, r0, #1		; CHECK INPUT #1 FOR INFINITY
	ASR	tmp, tmp, #21		;
	ADD	tmp, tmp, #1		;
	BNE	$4			;
	LSL	tmp, r2, #1		; CHECK INPUT #2 FOR INFINITY
	ASR	tmp, tmp, #21		;
	ADD	tmp, tmp, #1		;
	BNE	$4			;

	LSR	tmp, r2, #31		; HANDLE THE CASE OF BOTH INPUTS
	LSR	tmp2, r0, #31		; BEING INFINITE
	SUB	tmp, tmp, tmp2		;
        POP	{r4, r5}		;
	MOV	pc, lr			;

$4:	CMP	r2, #0			; CHECK OP2'S SIGN
	BMI	$6			;

	CMP	r0, #0			; OP2 IS POSITIVE.  IF OP1 IS NEGATIVE,
	BMI	exit			; THE RESULT IS OP1
	CMP	r0, r2			; ELSE THE RESULT IS OP1 - OP2
        BNE	exit			;
	MOV	tmp, r1			; MAKE SURE WE SET THE N BIT CORRECTLY
	EOR	tmp, r3			;
	BMI	$5			;
	CMP	r1, r3			;
	POP	{r4, r5}		;
	MOV	pc, lr			;
$5:	CMP	r3, #0			;
	POP	{r4, r5}		;
	MOV	pc, lr			;

$6:	CMP	r0, #0			; OP2 IS NEGATIVE.  IF OP1 IS POSITIVE,
	BGT	exit			; THE RESULT IS OP1
	CMP	r2, r0			; ELSE THE RESULT IS OP2 - OP1
	BNE	exit			;
	MOV	tmp, r1			; MAKE SURE WE SET THE N BIT CORRECTLY
	EOR	tmp, r3			;
	BMI	$7			;
	CMP	r3, r1			;
	POP	{r4, r5}		;
	MOV	pc, lr			;
$7:	CMP	r1, #0			;
exit:	POP	{r4, r5}		;
	MOV	pc, lr			;

	.endasmfunc

	.end
fd_cmp32.asm/   1202506627  0     0     0       5689      `
;******************************************************************************
;* FD_CMP32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************
 
;****************************************************************************
;* FD_CMP - COMPARE TWO IEEE 754 FORMAT DOUBLE PRECISION FLOATING POINT 
;*          NUMBERS, SETTING THE STATUS ON THE RESULT.
;*
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1
;*   o INPUT OP2 IS IN r2:r3
;*   o INPUTS ARE NOT DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o +0 == -0
;*
;*   o IF COMPUTING THE RESULT INVOLVES INFINITIES, THE FOLLOWING TABLE
;*     SUMMARIZES THE EFFECTIVE RESULT
;*                   +----------+----------+----------+ 
;*                   + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   +INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |    -0    +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +    +0    +
;*        +----------+----------+----------+----------+
;*
;*   o THE RESULT OF THE COMPARE IS COMPUTED USING INTEGER SUBRACT IF THE
;*     SIGN OF THE INPUTS IS THE SAME.  THE TABLE SUMMARIZES THE 
;*     IMPLEMENTATION.
;*                 +-----------+-----------+ 
;*                 +   OP2 +   |   OP2 -   +
;*        +--------+===========+===========+ 
;*        + OP1 +  + OP1 - OP2 |    OP1    + 
;*        +--------+-----------+-----------+ 
;*        + OP1 -  +    OP1    | OP2 - OP1 + 
;*        +--------+-----------+-----------+ 
;*
;*   o THE FOLLOWING STATUS BITS ARE SET ON THE RESULT
;*     o Z=1,N=0,V=0  IFF 0
;*     o Z=0,N=1,V=0  IFF -
;*     o Z=0,N=0,V=0  IFF +
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global FD_CMP

tmp	.set	lr

FD_CMP: .asmfunc stack_usage(4)
	STMFD	sp!, {lr}

	CMP	r0, r2			; HANDLE THE CASE OF BOTH INPUTS EQUAL 
	BNE	$1			;
	CMP	r1, r3			;
        LDMEQFD sp!, {pc}	        ;

$1:	ORRS	tmp, r1, r3		; HANDLE THE CASE OF BOTH INPUTS BEING
	BNE	$2			; ZERO
	ORR	tmp, r0, r2		;
	MOV	tmp, tmp, LSL #1	;
	CMP	tmp, #0x0		;
        LDMEQFD sp!, {pc}               ;

$2:	ORRS	tmp, r1, r0, LSL #1	; TEST OP1 == 0
	BNE	$3			;

	CMP	tmp, r2			; OP1 == 0, DISREGARD SIGN OF OP1
	LDMFD   sp!, {pc} 	        ; WHEN COMPUTING RESULT SIGN

$3:	MOV	tmp, r0, LSL #1		; CHECK INPUT #1 FOR INFINITY
	MOV	tmp, tmp, ASR #21	;
	ADDS	tmp, tmp, #1		;
	BNE	$4			;
	MOV	tmp, r2, LSL #1		; CHECK INPUT #2 FOR INFINITY
	MOV	tmp, tmp, ASR #21	;
	ADDS	tmp, tmp, #1		;
	BNE	$4			;

	MOV	tmp, r2, LSR #31	; HANDLE THE CASE OF BOTH INPUTS
	SUBS	tmp, tmp, r0, LSR #31	; BEING INFINITE
        LDMFD   sp!, {pc}               ;

$4:	CMP	r2, #0			; CHECK OP2'S SIGN
	BMI	$6			;

	CMP	r0, #0			; OP2 IS POSITIVE.  IF OP1 IS NEGATIVE,
        LDMMIFD sp!, {pc}           	; THE RESULT IS OP1,
	CMP	r0, r2			; ELSE IT IS OP1 - OP2
        LDMNEFD sp!, {pc}       	;
	EORS	tmp, r1, r3		; MAKE SURE WE SET THE N BIT CORRECTLY
	BMI	$5			;
	CMP	r1, r3			;
        LDMFD   sp!, {pc} 	        ;
$5:	CMP	r3, #0			;
        LDMFD   sp!, {pc} 	        ;

$6:	CMP	r0, #0			; OP2 IS NEGATIVE.  IF OP1 IS POSITIVE,
        LDMGTFD sp!, {pc}           	; THE RESULT IS OP1
	CMP	r2, r0			; ELSE IT IS OP2 - OP1
        LDMNEFD sp!, {pc}       	;
	EORS	tmp, r1, r3		; MAKE SURE WE SET THE N BIT CORRECTLY
	BMI	$7			;
	CMP	r3, r1			;
        LDMFD   sp!, {pc} 	        ;
$7:	CMP	r1, #0			;
        LDMFD   sp!, {pc} 	        ;

	.endasmfunc

	.end


fd_div16.asm/   1202506627  0     0     0       7460      `
;******************************************************************************
;* FD_DIV16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD$DIV - DIVIDES TWO IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;* 	    POINT NUMBERS.
;****************************************************************************
;*
;*   o DIVIDEND INPUT OP1 IS IN r0:r1
;*   o DIVISOR INPUT OP2 IS IN r2:r3
;*   o QUOTIENT IS RETURNED IN r0:r1
;*   o INPUT OP2 IN r2:r3 IS PRESERVED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY 
;*       (0x7ff00000:00000000) or (0xfff00000:00000000) 
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*   o DIVIDE BY ZERO RETURNS ZERO
;*
;*   o IF THE OPERATION INVOLVES INFINITY AS AN INPUT, UNLESS THE OTHER INPUT
;*     IS ZERO, THE RESULT IS INFINITY WITH THE SIGN DETERMINED IN THE USUAL
;*     FASHION.
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                       |
;* |   64-bit representation                                      |
;* |   31 30      20 19                  0                        |
;* |   +-+----------+---------------------+                       |
;* |   |S|     E    |        M1           |                       |
;* |   +-+----------+---------------------+                       |
;* |                                                              |
;* |   31                                0                        |
;* |   +----------------------------------+                       |
;* |   |             M2                   |                       |
;* |   +----------------------------------+                       |
;* |                                                              |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE           |
;* |                                 1 - NEGATIVE VALUE           |
;* |                                                              |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0          |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)|
;* |                        1111111111 - INFINITY                 |
;* |                                                              |
;* |   <M1:M2>  MANTISSA FIELDS:                                  |
;* |                          FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global	FD$DIV

res1	.set	r0	; OVERLOADED WITH INPUT #1
op1e	.set	r1	; OVERLOADED WITH INPUT #1
op1m1	.set	r2	; OVERLOADED WITH INPUT #2
op1m2	.set	r3	; OVERLOADED WITH INPUT #2
tmp	.set	r4
op2m1	.set	r5
op2m2	.set	r6
op2e	.set	r7
res2	.set	r7	; OVERLOADED WITH op2e


FD$DIV:	.asmfunc	stack_usage(28)
	PUSH	{r2-r7}			;

	MOV	tmp, r0			; SET THE SIGN OF THE RESULT
        EOR     tmp, r2                 ;
	LSR	tmp, tmp, #31		;
	LSL	tmp, tmp, #31		;
	PUSH	{tmp}			;

	LSL	op2m1, r2, #12		; BUILD INPUT #2 MANTISSA
	LSR	op2m1, op2m1, #12	;
	LSL	op2m2, r3, #1		;
	ADC	op2m1, op2m1		;
	LSL	op2e, r2, #1		; BUILD INPUT #2 EXPONENT
	LSR	op2e, op2e, #21		;
	BEQ	unfl			;

	MOV	tmp, #0x1		;
	LSL	tmp, tmp, #21		; SET IMPLIED ONE IN MANTISSA
	ORR	op2m1, tmp	 	;

	MOV	tmp, #0x7		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	CMP	op2e, tmp		; IF op2e == 0x7FF, THEN OVERFLOW
	BEQ	ovfl			;

	LSL	op1m1, r0, #12		; BUILD INPUT #1 MANTISSA
	LSR	op1m1, op1m1, #12	;
	LSL	op1m2, r1, #1		;
	ADC	op1m1, op1m1		;
	LSL	op1e, r0, #1		; BUILD INPUT #1 EXPONENT
	LSR	op1e, op1e, #21		;
	BEQ	unfl			;

	MOV	tmp, #0x1		; SET IMPLIED ONE IN MANTISSA
	LSL	tmp, tmp, #21		;
	ORR	op1m1, tmp	 	;

	MOV	tmp, #0x7		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	CMP	op1e, tmp		; IF op1e == 0x7FF, THEN OVERFLOW
	BEQ	ovfl			;

        SUB     op1e, op1e, op2e        ; SUBTRACT EXPONENTS
 
        ; DIVIDE THE MANTISAE:  op1m / op2m => res1:res2
        MOV     res1, #0x0              ; INITIALIZE THE QUOTIENT
	MOV	res2, #0x0		;
        MOV     tmp, #54                ; INITIALIZE THE SHIFT COUNTER
 
fdivb:  CMP     op1m1, op2m1            ; IF DIVIDEND IS LARGER THAN DIVISOR,
	BNE	$1			;
	CMP	op1m2, op2m2		;
$1:	BCC	$2			;
        ADC     res2, res2              ;  SHIFT A 1 INTO THE QUOTIENT
	ADC	res1, res1		;
	SUB	op1m2, op1m2, op2m2	;  AND SUBTRACT THE DIVISOR FROM
	SBC	op1m1, op2m1		;  THE DIVIDEND
	B	$3			;
$2:	ADC     res2, res2		; ELSE, SHIFT A 0 INTO THE QUOTIENT
	ADC	res1, res1		;
$3:	SUB	tmp, tmp, #1		; UPDATE THE SHIFT COUNTER
	BEQ	fdive			; EXIT IF OUT OF SHIFTS
	
	CMP	op1m1, #0		; EXIT IF NO DIVIDEND LEFT
	BNE	$4			;
	CMP	op1m2, #0		;
	BEQ	fdive			;
$4:	LSL	op1m2, op1m2, #1	; IF DIVIDEND STILL THERE,
	ADC	op1m1, op1m1		;   UPDATE DIVIDEND AND
	B	fdivb			;   CONTINUE
 
fdive:  CMP	tmp, #32		; ADJUST THE QUOTIENT AS NECESSARY
	BCS	low			;
	CMP	tmp, #22		;
	BCC	high			;

mid:	MOV	res1, res2		;
	LSL	res2, tmp		;
	MOV	op2m2, #32		;
	SUB	op2m2, op2m2, tmp	;
	LSR	res1, op2m2		;
	B	cont			;

low:	SUB	tmp, #32		;
	MOV	res1, res2		;
	LSL	res1, tmp		;
	MOV	res2, #0		;
	B	cont			;

high:	LSL	res1, tmp		;
	MOV	op2m2, #32		;
	SUB	op2m2, op2m2, tmp	;
	MOV	op2m1, res2		;
	LSR	op2m1, op2m2		;
	ORR	res1, op2m1		;
	LSL	res2, tmp		;

cont:   MOV	tmp, #0x1		;
	LSL	tmp, tmp, #21		;
	TST     res1, tmp               ; ALIGN THE QUOTIENT
	BNE	$5			;
	LSL	res2, res2, #1		;
	ADC	res1, res1		;
        SUB     op1e, op1e, #0x1        ;
 
$5:     MOV	tmp, #0x0		;
	ADD     res2, res2, #0x00000001 ; 1/2 ADJUST FOR ROUNDING
	ADC	res1, tmp		;
	MOV	tmp, #0x1		;
	LSL	tmp, tmp, #22		;
	TST	res1, tmp		;
	BEQ	$6			;
        ADD     op1e, op1e, #0x1        ;
	BIC	res1, tmp		;
	B	$7			;
$6:	LSR	tmp, tmp, #1		;
	BIC	res1, tmp		;

$7:	MOV	tmp, #0x3		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	ADD     op1e, op1e, tmp         ; ADJUST FOR BIAS
	BLE	unfl			; AND CHECK FOR UNDERFLOW

	ADD	tmp, tmp, tmp		;
        CMP     op1e, tmp	        ; AND CHECK FOR EXPONENT OVERFLOW 
	BHI	ovfl			;

	LSL	tmp, res1, #31		;
	LSR	res1, res1, #1		; REPACK THE QUOTIENT INTO r0:r1
	LSL	op1e, op1e, #20		;
        ORR     res1, op1e              ; REPACK THE EXPONENT INTO r0
	LSR	r1, res2, #1		;
	ORR	r1, tmp			;
	POP	{tmp}			;
        ORR     res1, tmp               ; REPACK THE SIGN INTO r0
 
	POP	{r2-r7}		        ;
	MOV	pc, lr			;

ovfl:	POP	{r0}			; RETURN OVERFLOW VALUE, WHICH IS
	MOV	r1, #0x0		; BASED ON THE SIGN OF THE RESULT
	LSR	r0, r0, #31
	LSL	r0, r0, #8
	MOV	r0, #0xFF
	LSL	r0, r0, #3
	ADD	r0, r0, #7
	LSL	r0, r0, #20
        POP     {r2-r7}		        ;
	MOV	pc, lr			;

unfl:   MOV     r0, #0                  ; UNDERFLOW, SO RETURN ZERO
	MOV	r1, #0			;
	ADD	sp, #4			;
        POP     {r2-r7}			;
	MOV	pc, lr			;

	.endasmfunc

        .end
fd_div32.asm/   1202506627  0     0     0       7171      `
;******************************************************************************
;* FD_DIV32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD_DIV - DIVIDES TWO IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;* 	    POINT NUMBERS.
;****************************************************************************
;*
;*   o DIVIDEND INPUT OP1 IS IN r0:r1
;*   o DIVISOR INPUT OP2 IS IN r2:r3
;*   o QUOTIENT IS RETURNED IN r0:r1
;*   o INPUT OP2 IN r2:r3 IS PRESERVED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY 
;*       (0x7ff00000:00000000) or (0xfff00000:00000000) 
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*   o DIVIDE BY ZERO RETURNS ZERO
;*
;*   o IF THE OPERATION INVOLVES INFINITY AS AN INPUT, UNLESS THE OTHER INPUT
;*     IS ZERO, THE RESULT IS INFINITY WITH THE SIGN DETERMINED IN THE USUAL
;*     FASHION.
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
****************************************************************************
	.state32

	.global FD_DIV

op1m1	.set	r2	; OVERLOADED WITH INPUT #2
op1m2	.set	r3	; OVERLOADED WITH INPUT #2
op1e	.set	r4
op2m1	.set	r5
op2m2	.set	r6
op2e	.set	r7
sign	.set	r8
tmp	.set	lr

FD_DIV:	.asmfunc stack_usage(32)
	STMFD	sp!, {r2-r8, lr}
 
        EORS    sign, r0, r2            ; SET THE SIGN OF THE RESULT
        MOVMI   sign, #0x80000000       ;
        MOVPL   sign, #0x00000000       ;
 	
	MOV	op2m1, r2, LSL #12	; BUILD INPUT #2 MANTISSA
	MOV	op2m1, op2m1, LSR #12	;
	MOVS	op2m2, r3, LSL #1	;
	ADC	op2m1, op2m1, op2m1	;
	MOV	op2e, r2, LSL #1	; BUILD INPUT #2 EXPONENT
	MOVS	op2e, op2e, LSR #21	;
        ORRNE   op2m1, op2m1,#0x00200000; SET IMPLIED 1 IN MANTISSA IF op2e != 0
        MOVEQ   r0, #0                  ; IF op2e == 0, THEN UNDERFLOW
	MOVEQ	r1, #0			;
        LDMEQFD sp!, {r2-r8, pc}        ;

	MOV	tmp, #0x700		;
	ADD	tmp, tmp, #0xFF		;
        CMP     op2e, tmp               ; IF op2e == 0x7FF, THEN OVERFLOW
	BEQ	ovfl			;

	MOV	op1m1, r0, LSL #12	; BUILD INPUT #1 MANTISSA
	MOV	op1m1, op1m1, LSR #12	;
	MOVS	op1m2, r1, LSL #1	;
	ADC	op1m1, op1m1, op1m1	;
	MOV	op1e, r0, LSL #1	; BUILD INPUT #1 EXPONENT
	MOVS	op1e, op1e, LSR #21	;
        ORRNE   op1m1, op1m1,#0x00200000; SET IMPLIED 1 IN MANTISSA IF op1e != 0
        MOVEQ   r0, #0                  ; IF op1e == 0, THEN UNDERFLOW
	MOVEQ	r1, #0			;
        LDMEQFD sp!, {r2-r8, pc}        ;

        CMP     op1e, tmp               ; IF op1e == 0x7FF, THEN OVERFLOW
	BEQ	ovfl			;

        SUB     op1e, op1e, op2e        ; SUBTRACT EXPONENTS
 
        ; DIVIDE THE MANTISAE:  op1m / op2m => r0:r1
        MOV     r0, #0x0                ; INITIALIZE THE QUOTIENT
	MOV	r1, #0x0		;
        MOV     tmp, #54                ; INITIALIZE THE SHIFT COUNTER
 
fdivb:  CMP     op1m1, op2m1            ; IF DIVIDEND IS LARGER THAN DIVISOR,
	BNE	$1			;
	CMP	op1m2, op2m2		;
$1:	BCC	$2			;
        ADCS    r1, r1, r1              ;  SHIFT A 1 INTO THE QUOTIENT
	ADC	r0, r0, r0		;
	SUBS	op1m2, op1m2, op2m2	;  AND SUBTRACT THE DIVISOR FROM
	SBC	op1m1, op1m1, op2m1	;  THE DIVIDEND
	B	$3			;
$2:	ADCS    r1, r1, r1		; ELSE, SHIFT A 0 INTO THE QUOTIENT
	ADC	r0, r0, r0		;
$3:	SUBS	tmp, tmp, #1		; UPDATE THE SHIFT COUNTER
	BEQ	fdive			; EXIT IF OUT OF SHIFTS
	ORRS	op2e, op1m1, op1m2	;
	BEQ	fdive			; IF DIVIDEND STILL THERE,
	MOVS	op1m2, op1m2, LSL #1	;  UPDATE DIVIDEND
	ADC	op1m1, op1m1, op1m1	;  AND
	B	fdivb			;  CONTINUE
 
fdive:  CMP	tmp, #32		; ADJUST THE QUOTIENT AS NECESSARY
	BCS	low			;
	CMP	tmp, #22		;
	BCC	high			;

mid:	RSB	op2e, tmp, #32		;
	MOV	r0, r1, LSR op2e	;
	MOV	r1, r1, LSL tmp		;
	B	cont			;

low:	SUB	tmp, tmp, #32		;
	MOV	r0, r1, LSL tmp		;
	MOV	r1, #0			;
	B	cont			;

high:	MOV	r0, r0, LSL tmp		;
	RSB	op2e, tmp, #32		;
	ORR	r0, r0, r1, LSR op2e	;
	MOV	r1, r1, LSL tmp		;

cont:   TST     r0, #0x00200000         ; ALIGN THE QUOTIENT
	BNE	$4			;
	MOVS	r1, r1, LSL #1		;
	ADC	r0, r0, r0		;
        SUB     op1e, op1e, #0x1        ;
 
$4:     ADDS    r1, r1, #0x00000001     ; 1/2 ADJUST FOR ROUNDING
	ADC	r0, r0, #0		;
	TST	r0, #0x00400000		;
        ADDNE   op1e, op1e, #0x1        ;
	BICNE	r0, r0, #0x00400000	;
	BICEQ	r0, r0, #0x00200000	;
 
	MOV	op2e, #0x300		;
	ADD	op2e, op2e, #0xFF	;
	ADDS    op1e, op1e, op2e        ; ADJUST FOR BIAS
        MOVLE   r0, #0x0                ; AND CHECK FOR UNDERFLOW
	MOVLE	r1, #0x0		;
        LDMLEFD sp!, {r2-r6, pc}        ;
 
	ADD	op2e, op2e, #0x400	; AND CHECK FOR EXPONENT OVERFLOW
        CMP     op1e, op2e	        ;
	BCS	ovfl			;

	MOVS	r0, r0, LSR #1		; REPACK THE QUOTIENT INTO r0:r1
	MOV	r1, r1, RRX		; 
        ORR     r0, r0, op1e, LSL #20   ; REPACK THE EXPONENT INTO r0
        ORR     r0, r0, sign            ; REPACK THE SIGN INTO r0
 
        LDMFD   sp!, {r2-r8, pc}        ;
 
ovfl:	MOV	r1, #0x0		; IF OVERFLOW, RETURN +/- INFINITY
	MOV	r0, #0xFF
	MOV	r0, r0, LSL #3
	ADD	r0, r0, #7
	MOV	r0, r0, LSL #20
	ORR	r0, r0, sign
        LDMFD   sp!, {r2-r8, pc}        ;
 
	.endasmfunc

        .end

fd_mul16.asm/   1202506627  0     0     0       7021      `
;******************************************************************************
;* FD_MUL16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD$MUL - MULTIPLY TWO IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;*          POINT NUMBERS.
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1
;*   o INPUT OP2 IS IN r2:r3
;*   o RESULT IS RETURNED IN r0:r1
;*   o INPUT OP2 IN r2:r3 IS NOT DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY 
;*       (0x7ff00000:00000000) or (0xfff00000:00000000) 
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;*   o IF THE OPERATION INVOLVES INFINITY AS AN INPUT, UNLESS THE OTHER INPUT
;*     IS ZERO, THE RESULT IS INFINITY WITH THE SIGN DETERMINED IN THE USUAL
;*     FASHION.
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global	FD$MUL

res1	.set	r0	; OVERLOADED WITH INPUT #1
op1e	.set	r1	; OVERLOADED WITH INPUT #1
op1m1	.set	r2	; OVERLOADED WITH INPUT #2
op1m2	.set	r3	; OVERLOADED WITH INPUT #2
tmp	.set	r4
op2m1	.set	r5
op2m2	.set	r6
op2e	.set	r7
res2	.set	r7	; OVERLOADED WITH op2e


FD$MUL:	.asmfunc	stack_usage(32)
	PUSH	{r2-r7, lr}		;

	MOV	tmp, r0			; SET THE SIGN OF THE RESULT
        EOR     tmp, r2                 ;
	LSR	tmp, tmp, #31		;
	LSL	tmp, tmp, #31		;
	PUSH	{tmp}			;

	LSL	op2m1, r2, #11		; BUILD INPUT #2 MANTISSA
	LSR	tmp, r3, #21		;
	ORR	op2m1, tmp		;
	LSL	op2m2, r3, #11		;
	LSL	op2e, r2, #1		; BUILD INPUT #2 EXPONENT
	LSR	op2e, op2e, #21		;
	BEQ	unfl			;

	MOV	tmp, #0x1		;
	LSL	tmp, tmp, #31		; SET IMPLIED ONE IN MANTISSA
	ORR	op2m1, tmp	 	;

	MOV	tmp, #0x7		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	CMP	op2e, tmp		; IF op2e == 0x7FF, THEN OVERFLOW
	BEQ	ovfl			;

	LSL	op1m1, r0, #11		; BUILD INPUT #1 MANTISSA
	LSR	tmp, r1, #21		;
	ORR	op1m1, tmp		;
	LSL	op1m2, r1, #11		;
	LSL	op1e, r0, #1		; BUILD INPUT #1 EXPONENT
	LSR	op1e, op1e, #21		;
	BEQ	unfl			;

	MOV	tmp, #0x1		; SET IMPLIED ONE IN MANTISSA
	LSL	tmp, tmp, #31		;
	ORR	op1m1, tmp	 	;

	MOV	tmp, #0x7		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	CMP	op1e, tmp		; IF op1e == 0x7FF, THEN OVERFLOW
	BEQ	ovfl			;

        ADD     op1e, op1e, op2e        ; ADD EXPONENTS

	NOP				; 
	BX	pc			; CHANGE TO 32 BIT STATE FOR MULTIPLY
	NOP				;

	.state32

	; MULTIPLY THE MANTISAE: op1m * op2m => res1:res2
	UMULL	res2, res1, op1m1, op2m1   ; op1m1*op2m1 =>res1:res2: 0   : 0
	UMULL	tmp, op1m1, op2m2, op1m1   ; op1m1*op2m2 =>  0 :op1m1:tmp : 0
	UMULL	lr, op2m2, op1m2, op2m2    ; op1m2*op2m2 =>  0 :  0 :op2m2: lr
	UMULL	lr, op2m1, op1m2, op2m1    ; op1m2*op2m1 =>  0 :op2m1: lr : 0
	ADDS	op2m2, op2m2, lr	   ;                 0 :  0 :op2m2: 0

	MOV	op1m2, #0x0		   ;
	ADD	lr, pc, #0x1		   ; CHANGE BACK TO 16 BIT STATE
	BX	lr			   ;

	.state16

	ADC	op2m1, op1m2		   ;                 0 :op2m1: 0  : 0
	ADC	res1, op1m2		   ;               res1:  0 : 0   : 0
	ADD	tmp, op2m2		   ;                 0 :  0 : tmp : 0
	ADC	op2m1, op1m2		   ;                 0 :op2m1: 0  : 0
	ADC	res1, op1m2	 	   ;               res1:  0 : 0   : 0

	MOV	tmp, #0x80		   ; SETUP 1/2 CONSTANT FOR ROUNDING
	LSL	tmp, tmp, #2    	   ;

	ADD	op1m1, op2m1		   ;                 0 :op1m1: 0  : 0
	ADC	res1, op1m2		   ;               res1:  0 : 0   : 0
	ADD	res2, op1m1		   ;                 0 :res2: 0   : 0
	ADC	res1, op1m2		   ;               res1:  0 : 0   : 0

	BPL	$1			; IF THE MANTISSA WILL NOT NEED
	LSL	tmp, tmp, #0x1		; ALIGNMENT, ADJUST 1/2 CONSTANT.

$1:	ADD	res2, res2, tmp		; ADD 1/2 FOR ROUNDING
	ADC	res1, op1m2		;

	BMI	$2			; ALIGN THE RESULT
	LSL	res2, res2, #1		;
	ADC	res1, res1		;
	B	$3			;

$2:	ADD	op1e, op1e, #0x1	; 

$3:	MOV	tmp, #0x3		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	SUB     op1e, op1e, tmp         ; ADJUST FOR BIAS
	BLE	unfl			; AND CHECK FOR UNDERFLOW

	ADD	tmp, tmp, tmp		;
        CMP     op1e, tmp	        ; AND CHECK FOR EXPONENT OVERFLOW 
	BHI	ovfl			;

	LSL	op1m1, op1e, #20	; ALIGN EXPONENT INTO op1m1
	LSR	r1, res2, #11		; REPACK LOW PART OF RESULT
	LSL	tmp, res1, #21		;
	ORR	r1, tmp			;
	LSL	r0, res1, #1		; REPACK HIGH PART OF RESULT
	LSR	r0, r0, #12		;
        ORR     r0, op1m1               ; REPACK THE EXPONENT INTO r0
	POP	{tmp}			;
        ORR     r0, tmp                 ; REPACK THE SIGN INTO r0
 
	POP	{r2-r7, pc}	        ;

ovfl:   MOV     r1, #0                  ; IF OVERFLOW, RETURN +/- INFINITY
	MOV	r0, #0xFF
	LSL	r0, r0, #3
	ADD	r0, r0, #7
	LSL	r0, r0, #20
	POP	{tmp}			;
        ORR     r0, tmp                 ;
        POP     {r2-r7, pc}	        ;

unfl:   MOV     r0, #0                  ; UNDERFLOW, SO RETURN ZERO
	MOV	r1, #0			;
	ADD	sp, #4			;
        POP     {r2-r7, pc}             ;
 
	.endasmfunc

        .end


fd_mul32.asm/   1202506627  0     0     0       6683      `
;******************************************************************************
;* FD_MUL32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD_MUL - MULTIPLY TWO IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;* 	    POINT NUMBERS.
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1
;*   o INPUT OP2 IS IN r2:r3
;*   o RESULT IS RETURNED IN r0:r1
;*   o INPUT OP2 IN r2:r3 IS NOT DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY 
;*       (0x7ff00000:00000000) or (0xfff00000:00000000) 
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;*   o IF THE OPERATION INVOLVES INFINITY AS AN INPUT, UNLESS THE OTHER INPUT
;*     IS ZERO, THE RESULT IS INFINITY WITH THE SIGN DETERMINED IN THE USUAL
;*     FASHION.
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
****************************************************************************
	.state32

	.global	FD_MUL

op1m1	.set	r2	; OVERLOADED WITH INPUT #2
op1m2	.set	r3	; OVERLOADED WITH INPUT #2
op1e	.set	r4
op2m1	.set	r5
op2m2	.set	r6
op2e	.set	r7
sign	.set	r8
tmp	.set	lr

FD_MUL: .asmfunc stack_usage(32)
	STMFD	sp!, {r2-r8, lr}
 
        EORS    sign, r0, r2            ; SET THE SIGN OF THE RESULT
        MOVMI   sign, #0x80000000       ;
        MOVPL   sign, #0x00000000       ;
 	
	MOV	op2m1, r2, LSL #11		; BUILD INPUT #2 MANTISSA
	ORR	op2m1, op2m1, r3, LSR #21	;
	MOV	op2m2, r3, LSL #11		;
	MOV	op2e, r2, LSL #1		; BUILD INPUT #2 EXPONENT
	MOVS	op2e, op2e, LSR #21		;
        ORRNE   op2m1, op2m1,#0x80000000	; SET IMPLIED 1 IN MANTISSA
        MOVEQ   r0, #0                  	; IF op2e == 0, ELSE UNDERFLOW
	MOVEQ	r1, #0				;
        LDMEQFD sp!, {r2-r8, pc}        	;

	MOV	tmp, #0x700		;
	ADD	tmp, tmp, #0xFF		;
        CMP     op2e, tmp               ; IF op2e == 0x7FF, THEN OVERFLOW
	BEQ	ovfl			;

	MOV	op1m1, r0, LSL #11		; BUILD INPUT #1 MANTISSA
	ORR	op1m1, op1m1, r1, LSR #21	;
	MOV	op1m2, r1, LSL #11		;
	MOV	op1e, r0, LSL #1		; BUILD INPUT #1 EXPONENT
	MOVS	op1e, op1e, LSR #21		;
        ORRNE   op1m1, op1m1,#0x80000000	; SET IMPLIED 1 IN MANTISSA
        MOVEQ   r0, #0                  	; IF op1e == 0, ELSE UNDERFLOW
	MOVEQ	r1, #0				;
        LDMEQFD sp!, {r2-r8, pc}        	;

        CMP     op1e, tmp               ; IF op1e == 0x7FF, THEN OVERFLOW
	BEQ	ovfl			;

        ADD     op1e, op1e, op2e        ; ADD EXPONENTS

	; MULTIPLY THE MANTISAE: op1m * op2m => r0:r1
	UMULL	r1, r0, op1m1, op2m1       ; op1m1*op2m1 => r0 : r1 : 0   : 0
	UMULL	tmp, op2e, op1m1, op2m2	   ; op1m1*op2m2 =>  0 :op2e:tmp  : 0
	UMULL	op2m2, op1m1, op1m2, op2m2 ; op1m2*op2m2 =>  0 :  0 :op1m1:op2m2
	ADDS	tmp, tmp, op1m1		   ;                 0 :  0 :tmp  :0
	ADCS	op2e, op2e, #0		   ;                 0 :op2e: 0   : 0
	ADC	r0, r0, #0		   ;                r0 :  0 : 0   : 0
	UMULL	op2m2, op1m1, op1m2, op2m1 ; op1m2*op2m1 =>  0 :op1m1:op2m2: 0
	ADDS	tmp, tmp, op2m2		   ;                 0 :  0 : tmp : 0
	ADCS	op2e, op2e, #0		   ;                 0 :op2e: 0   : 0
	ADC	r0, r0, #0	 	   ;                r0 :  0 : 0   : 0
	ADDS	op2e, op2e, op1m1	   ;                 0 :op2e: 0   : 0
	ADC	r0, r0, #0		   ;                r0 :  0 : 0   : 0
	ADDS	r1, r1, op2e		   ;                 0 : r1 : 0   : 0
	ADCS	r0, r0, #0		   ;                r0 :  0 : 0   : 0

	MOVMI	tmp, #0x00000400	; SETUP 1/2 CONSTANT FOR ROUNDING
	MOVPL	tmp, #0x00000200	;

        ADDS    r1, r1, tmp             ; ROUND TO NEAREST
	ADCS	r0, r0, #0		;

	ADDMI	op1e, op1e, #0x1	; ALIGN THE RESULT
	BMI	$1			;
	MOVS	r1, r1, LSL #1		;
	ADC	r0, r0, r0		;

$1:	MOV	op2e, #0x300		;
	ADD	op2e, op2e, #0xFF	;
	SUBS    op1e, op1e, op2e        ; ADJUST FOR BIAS
        MOVLE   r0, #0x0                ; AND CHECK FOR UNDERFLOW
	MOVLE	r1, #0x0		;
        LDMLEFD sp!, {r2-r8, pc}        ;
 
	ADD	op2e, op2e, #0x400	; AND CHECK FOR EXPONENT OVERFLOW
        CMP     op1e, op2e	        ;
	BCS	ovfl			;

	MOV	r1, r1, LSR #11		; REPACK LOW PART OF RESULT INTO r1
	ORR	r1, r1, r0, LSL #21	;
	MOV	r0, r0, LSL #1		; REPACK HIGH PART OF RESULT INTO r0
	MOV	r0, r0, LSR #12		;
        ORR     r0, r0, op1e, LSL #20   ; REPACK THE EXPONENT INTO r0
        ORR     r0, r0, sign            ; REPACK THE SIGN INTO r0
 
        LDMFD   sp!, {r2-r8, pc}        ;
 

ovfl:	MOV	r1, #0			; IF OVERFLOW, RETURN +/- INFINITY
	MOV	r0, #0xFF
	MOV	r0, r0, LSL #3
	ADD	r0, r0, #7
	MOV	r0, r0, LSL #20
	ORR	r0, r0, sign
        LDMFD   sp!, {r2-r8, pc}        ;
 
	.endasmfunc

        .end

fd_toi16.asm/   1202506627  0     0     0       4125      `
;******************************************************************************
;* FD_TOI16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD$TOI - CONVERT AN IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;*          INTO A SIGNED 32 BIT INTEGER 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1
;*   o RESULT IS RETURNED IN r0
;*   o INPUT OP IN r1 IS DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0x7FFFFFFF/0x80000000, DEPENDING ON THE SIGN OF
;*     THE INPUT
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global	FD$TOI

ope	.set	r2
tmp	.set	r3
sign	.set	lr

FD$TOI:	.asmfunc stack_usage(12)
	PUSH	{r2, r3, lr}		; SAVE CONTEXT

	LSL	ope, r0, #1		; PUT EXPONENT IN ope
	LSR	ope, ope, #21		;

	MOV	tmp, #0x3		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	SUB	ope, ope, tmp		; ADJUST FOR EXPONENT BIAS AND
	BCC	unfl			; CHECK FOR UNDERFLOW

	MOV	tmp, #0x1F		;
	SUB	ope, tmp, ope		; CHECK FOR OVERFLOW
	BLS	ovfl			; IF OVERFLOW, RETURN INFINITY

	MOV	sign, r0		; SAVE SIGN
	LSL	r0, r0, #11		; PUT HI MANTISSA IN r0
	MOV	tmp, #0x1		;
	LSL	tmp, tmp, #31		;
	ORR	r0, tmp			; SET IMPLIED ONE IN HI MANTISSA

	LSR	r0, ope			; COMPUTE THE INTEGER VALUE
	CMP	ope, #11		; FROM HI HALF OF THE MANTISSA.
	BCS	$1			; IF THE LOW HALF OF THE MANTISSA IS
	ADD	ope, #21		;  SIGNIFICANT, INCLUDE IT INTO THE 
	LSR	r1, ope			;  INTEGER VALUE, ALSO.
	ORR	r0, r1			;

$1:	MOV	tmp, sign		;
	CMP	tmp, #0x0		; IF THE INPUT IS NEGATIVE,
	BPL	$2			;  THEN NEGATE THE RESULT
	NEG	r0, r0			;
$2:	POP	{r2, r3, pc}		;

unfl:   MOV     r0, #0                  ; UNDERFLOW
	POP	{r2, r3, pc}		;
 
ovfl:	MOV	tmp, r0			; IF OVERFLOW, RETURN INFINITY
	MOV	r0, #0x1		;
	LSL	r0, r0, #31		;
	CMP	tmp, #0			; CHECK THE SIGN OF THE INPUT
	BMI	$3			; AND ADJUST THE VALUE OF INFINITY
	SUB	r0, #1			; ACCORDINGLY
$3:	POP 	{r2, r3, pc}		;

	.endasmfunc

	.end

fd_toi32.asm/   1202506627  0     0     0       3906      `
;******************************************************************************
;* FD_TOI32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD_TOI - CONVERT AN IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;*          INTO A SIGNED 32 BIT INTEGER 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1
;*   o RESULT IS RETURNED IN r0
;*   o INPUT OP IN r1 IS DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0x7FFFFFFF/0x80000000, DEPENDING ON THE SIGN OF
;*     THE INPUT
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global	FD_TOI

opm	.set	r2
ope	.set	lr

FD_TOI:	.asmfunc stack_usage(8)
	STMFD	sp!, {r2, lr}		; SAVE CONTEXT

	MOV	ope, r0, LSL #1		; PUT EXPONENT IN ope
	MOV	ope, ope, LSR #21	;

	SUB	ope, ope, #0x300	; ADJUST FOR EXPONENT BIAS AND
	SUBS	ope, ope, #0xFF		; CHECK FOR UNDERFLOW
	MOVMI	r0, #0			; IF UNDERFLOW, RETURN ZERO
	LDMMIFD sp!, {r2, pc}		;

	RSBS	ope, ope, #0x1F		; CHECK FOR OVERFLOW
	BLS	ovfl			; IF OVERFLOW, RETURN INFINITY

	MOV	opm, r0, LSL #11	; PUT HI MANTISSA IN opm
	ORR	opm, opm, #0x80000000	; SET IMPLIED ONE IN HI MANTISSA

	MOV	opm, opm, LSR ope	; COMPUTE THE INTEGER VALUE
	CMP	ope, #11		; FROM HI HALF OF THE MANTISSA.
	ADDCC	ope, ope, #21		; IF THE LOW HALF OF THE MANTISSA IS
	ORRCC	opm, opm, r1, LSR ope	;  SIGNIFICANT, INCLUDE IT ALSO

	CMP	r0, #0			; IF THE INPUT IS NEGATIVE,
	RSBMI	r0, opm, #0		;  THEN NEGATE THE RESULT
	MOVPL	r0, opm			;

	LDMFD 	sp!, {r2, pc}		;

ovfl:	CMP	r0, #0			; IF OVERFLOW, RETURN INFINITY
	MOV	r0, #0x80000000		; CHECK THE SIGN OF THE INPUT
	SUBPL	r0, r0, #0x1		; AND ADJUST INFINITY ACCORDINGLY
	LDMFD	sp!, {r2, pc}		;

	.endasmfunc

	.end
fd_toll16.asm/  1202506627  0     0     0       5407      `
;******************************************************************************
;* FD_TOLL16.ASM  - 16 BIT STATE -  v2.70                                     *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD$TOLL - CONVERT AN IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;*           INTO A SIGNED 64 BIT INTEGER 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0x7FFFFFFF:FFFFFFFF/0x80000000:00000000, DEPENDING 
;*     ON THE SIGN OF THE INPUT
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global	FD$TOLL

	.if .TMS470_LITTLE

o_hi	.set r1
o_lo	.set r0

	.else

o_hi	.set r0
o_lo	.set r1

	.endif

ope	.set	r2
tmp	.set	r3
tmp2    .set    r4
sign	.set	lr

FD$TOLL: .asmfunc stack_usage(16)
        PUSH	{r2-r4, lr}		; SAVE CONTEXT

	LSL	ope, r0, #1		; PUT EXPONENT IN ope
	LSR	ope, ope, #21		;

	MOV	tmp, #0x3		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	SUB	ope, ope, tmp		; ADJUST FOR EXPONENT BIAS AND
	BCC	unfl			; CHECK FOR UNDERFLOW

	MOV	tmp, #0x3F		;
	SUB	ope, tmp, ope		; CHECK FOR OVERFLOW
	BLS	ovfl			; IF OVERFLOW, RETURN INFINITY

	MOV	sign, r0		; SAVE SIGN

	LSL	r0, r0, #11		; PUT MANTISSA IN r0:r1
        LSR     tmp, r1, #21            ;
        ORR     r0, tmp                 ;
        LSL     r1, r1, #11             ;
	MOV	tmp, #0x1		;
	LSL	tmp, tmp, #31		;
	ORR	r0, tmp			; SET IMPLIED ONE IN HI MANTISSA


        ; COMPUTE THE INTEGER VALUE
        MOV     tmp, ope                ;
        SUB     tmp, #32                ; IF ope >= 32 
        BCC     $1                      ;
        MOV     r1, r0                  ;    r0:r1 = 0:r0 >> (ope - 32)
        MOV     r0, #0                  ;
	LSR	r1, tmp		        ;
	B       adj_sign                ;
$1:
        LSR     r1, ope                 ; IF ope < 32
        NEG     tmp, tmp                ;    
        MOV     tmp2, r0                ;    r0:r1 = r0:r1 >> ope
        LSL     tmp2, tmp               ;          = r0 >> ope : 
        ORR     r1, tmp2                ;             r1 >> ope | r0 << (32-ope)
        LSR     r0, ope                 ;

adj_sign:	
        MOV	tmp, sign		;
	CMP	tmp, #0x0		; IF THE INPUT IS NEGATIVE,
	BPL	$2			;  
        MOV     tmp, #0                 ;
	NEG	r1, r1			;  THEN NEGATE THE RESULT
        SBC     tmp, r0                 ;
        MOV     r0, tmp                 ;
$2:	
	; IN LITTLE ENDIAN MODE THE OUTPUT LONG LONG VALUE SHOULD BE IN R1:R0.
	; SO SWAP THE REGISTER VALUES BEFORE RETURN.

	.if .TMS470_LITTLE
	MOV	lr, r0			;
	MOV	r0, r1			;
	MOV	r1, lr			;
	.endif

        POP	{r2-r4, pc}		;

unfl:   MOV     o_hi, #0                ; UNDERFLOW
        MOV     o_lo, #0                ;
	POP	{r2-r4, pc}		;
 
ovfl:	MOV	tmp, r0			; IF OVERFLOW, RETURN INFINITY
	MOV	o_lo, #0		;
	MOV	o_hi, #0x1		;
	LSL	o_hi, o_hi, #31		;
	CMP	tmp, #0			; CHECK THE SIGN OF THE INPUT
	BMI	$3			; AND ADJUST THE VALUE OF INFINITY
        MOV     tmp, #0                 ; ACCORDINGLY
	SUB	o_lo, #1		; 
        SBC     o_hi, tmp               ;
$3:	
        POP 	{r2-r4, pc}		;

	.endasmfunc
	.end

fd_toll32.asm/  1202506627  0     0     0       5009      `
;******************************************************************************
;* FD_TOLL32.ASM  - 32 BIT STATE -  v2.70                                     *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD_TOLL - CONVERT AN IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;*           INTO A SIGNED 64 BIT INTEGER 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0x7FFFFFFF:FFFFFFFF/0x80000000:00000000, DEPENDING 
;*     ON THE SIGN OF THE INPUT
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global	FD_TOLL

	.if .TMS470_LITTLE

o_hi	.set r1
o_lo	.set r0

	.else

o_hi	.set r0
o_lo	.set r1

	.endif

ope	.set	lr
sign	.set	r2
tmp     .set    r3

FD_TOLL: .asmfunc stack_usage(12)
        STMFD	sp!, {r2, r3, lr}	; SAVE CONTEXT

	MOV	ope, r0, LSL #1		; PUT EXPONENT IN ope
	MOV	ope, ope, LSR #21	;

	SUB	ope, ope, #0x300	; ADJUST FOR EXPONENT BIAS AND
	SUBS	ope, ope, #0xFF		; CHECK FOR UNDERFLOW
	MOVMI	r0, #0			; IF UNDERFLOW, RETURN ZERO
	MOVMI	r1, #0			; IF UNDERFLOW, RETURN ZERO
	LDMMIFD sp!, {r2, r3, pc}		;

	RSBS	ope, ope, #0x3F		; CHECK FOR OVERFLOW
	BLS	ovfl			; IF OVERFLOW, RETURN INFINITY

        MOV     sign, r0                ;
	MOV	r0, r0, LSL #11		; SHIFT THE EXPONENT (11 BITS) 
        ORR     r0, r0, r1, LSR #21     ; OUT OF THE MANTISSA R0:R1 
        MOV     r1, r1, LSL #11         ; 
	ORR	r0, r0, #0x80000000	; SET IMPLIED ONE IN HI MANTISSA 

        ; ADJUST THE VALUE IN R0:R1 FOR THE EXPONENT BY RIGHT SHIFTING 
        ; EXPONENT NUMBER OF BITS OUT OF R0:R1.
        SUBS    tmp, ope, #0x20         ; IF (EXP >= 32)
        MOVCS   r1, r0, LSR tmp         ;    R1 = MNT.HI >> EXP - 32
        MOVCS   r0, #0                  ;    R0 = 0 

        RSBCC   tmp, ope, #0x20         ; IF (EXP < 32)
        MOVCC   r1, r1, LSR ope         ; R0:R1 = R0:R1 >> EXP
        MOVCC   tmp, r0, LSL tmp        ;
        ORRCC   r1, r1, tmp             ;
        MOVCC   r0, r0, LSR ope         ;

	CMP	sign, #0		; IF THE INPUT IS NEGATIVE,
        BPL     return                  ;
	RSBS 	r1, r1, #0		;  THEN NEGATE THE RESULT
        RSC     r0, r0, #0              ;

return:
	; IN LITTLE ENDIAN MODE THE OUTPUT LONG LONG VALUE SHOULD BE IN R1:R0.
	; SO SWAP THE REGISTER VALUES BEFORE RETURN.

	.if .TMS470_LITTLE
	MOV	lr, r0			;
	MOV	r0, r1			;
	MOV	r1, lr			;
	.endif

	LDMFD 	sp!, {r2, r3, pc}	;

ovfl:	CMP	r0, #0			; IF OVERFLOW, RETURN INFINITY
	MOV	o_hi, #0x80000000	; CHECK THE SIGN OF THE INPUT
        MOV     o_lo, #0                ;
	LDMMIFD sp!, {r2, r3, pc}	;
	SUBS 	o_lo, o_lo, #0x1	; AND ADJUST INFINITY ACCORDINGLY
	SBC  	o_hi, o_hi, #0  	; 
	LDMFD sp!, {r2, r3, pc}	        ;

	.endasmfunc
	.end

fd_tos16.asm/   1202506627  0     0     0       5173      `
;******************************************************************************
;* FD_TOS16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD$TOFS - CONVERT AN IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;* 	     POINT NUMBER TO 754 FORMAT SINGLE PRECISION FLOATING 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1
;*   o RESULT IS RETURNED IN r0
;*   o r1 IS DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY (0x7F800000/FF800000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |   32-bit representation                                      |
;* |   31 30    23 22                    0                        |
;* |   +-+--------+-----------------------+                       |
;* |   |S|    E   |           M           +                       |
;* |   +-+--------+-----------------------+                       |
;* |                                                              |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE             |
;* |                               1 - NEGATIVE VALUE             |
;* |                                                              |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0            |
;* |                         01...FE - EXPONENT VALUE (127 BIAS)  |
;* |                              FF - INFINITY                   |
;* |                                                              |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global	FD$TOFS

tmp	.set	r2

FD$TOFS: .asmfunc stack_usage(4)
	PUSH	{r2}			; SAVE CONTEXT

	LSR	r1, r1, #20		; SETUP MANTISSA INTO r1
	LSL	tmp, r0, #12		;
	ORR	r1, tmp			;

	MOV	tmp, #0x1		;
	LSL	tmp, tmp, #8		;
	ADD	r1, r1, tmp		; ADD 1/2 FOR ROUNDING
	BCC	$1			;
	LSR	r1, r1, #1		; IF OVERFLOW, ADJUST MANTISSA AND
	LSL	tmp, tmp, #12		; EXPONENT
	ADD	r0, r0, tmp		;

$1:	LSR	r1, r1, #9		; ALIGN MANTISSA
	CMP	r0, #0			; AND ADD SIGN
	BPL	$2			;
	MOV	tmp, #0x1		;
	LSL	tmp, tmp, #31		;
	ORR	r1, tmp			;

$2:	LSL	r0, r0, #1		; SETUP EXPONENT
	LSR	r0, r0, #21		;
	BEQ	unfl			; CHECK FOR UNDERFLOW / ZERO

	MOV	tmp, #0x38		;
	LSL	tmp, tmp, #4		;
	SUB	r0, r0, tmp		; ADJUST FOR THE BIAS

	CMP	r0, #0xFF		; CHECK FOR OVERFLOW
	BCS	ovfl			;

	LSL	r0, r0, #23		;
	ORR	r0, r1			; ADD EXPONENT INTO RESULT
	POP	{r2}			;
	MOV	pc, lr			;
	
unfl:	POP	{r2}			; IF UNDERFLOW, RETURN 0
	MOV	pc, lr			;

ovfl:	LSR	r1, r1, #31		; OVERFLOW, RETURN +/- INF
	LSL	r1, r1, #31
	MOV	r0, #0xFF
	LSL	r0, r0, #23
	ORR	r0, r1			;
	POP	{r2}			;
	MOV	pc, lr			;

	.endasmfunc

	.end

fd_tos32.asm/   1202506627  0     0     0       4830      `
;******************************************************************************
;* FD_TOS32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD_TOFS - CONVERT AN IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;* 	     POINT NUMBER TO 754 FORMAT SINGLE PRECISION FLOATING 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1
;*   o RESULT IS RETURNED IN r0
;*   o r1 IS DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY (0x7F800000/FF800000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |   32-bit representation                                      |
;* |   31 30    23 22                    0                        |
;* |   +-+--------+-----------------------+                       |
;* |   |S|    E   |           M           +                       |
;* |   +-+--------+-----------------------+                       |
;* |                                                              |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE             |
;* |                               1 - NEGATIVE VALUE             |
;* |                                                              |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0            |
;* |                         01...FE - EXPONENT VALUE (127 BIAS)  |
;* |                              FF - INFINITY                   |
;* |                                                              |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global	FD_TOFS

FD_TOFS: .asmfunc
	MOV	r1, r1, LSR #20		; SETUP MANTISSA INTO r1
	ORR	r1, r1, r0, LSL #12	;

	ADDS	r1, r1, #0x00000100	; ADD 1/2 FOR ROUNDING
	MOVCS	r1, r1, LSR #1		;
	ADDCS	r0, r0, #0x00100000	;

	MOV	r1, r1, LSR #9		; ALIGN MANTISSA
	CMP	r0, #0			; AND ADD SIGN
	ORRMI	r1, r1, #0x80000000	;

	MOV	r0, r0, LSL #1		; SETUP EXPONENT
	MOVS	r0, r0, LSR #21		;
	MOVEQ	pc, lr			; CHECK FOR UNDERFLOW / ZERO

	SUB	r0, r0, #0x380		; ADJUST FOR THE BIAS

	CMP	r0, #0xFF		; CHECK FOR OVERFLOW
	BCS	ovfl			;

	ORR	r0, r1, r0, LSL #23	; ADD EXPONENT INTO RESULT
	MOV	pc, lr			;
	

ovfl:	AND	r1, r1, #0x80000000	; OVERFLOW, RETURN +/- INF
	MOV	r0, #0xFF
	MOV	r0, r0, LSL #23
	ORR	r0, r0, r1
	MOV	pc, lr			;

	.endasmfunc

	.end
fd_tou16.asm/   1202506627  0     0     0       3972      `
;******************************************************************************
;* FD_TOU16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD$TOU - CONVERT AN IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;*          INTO AN UNSIGNED 32 BIT INTEGER 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1
;*   o RESULT IS RETURNED IN r0
;*   o INPUT OP IN r1 IS DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0xFFFFFFFF
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o NEGATIVE VALUE RETURNS ZERO
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global	FD$TOU, FD$TOI

ope	.set	r2
tmp	.set	r3

FD$TOU:	.asmfunc stack_usage(8)
	PUSH	{r2, r3, lr}		; SAVE CONTEXT

	CMP	r0, #0			; CHECK FOR A NEGATIVE VALUE
        BPL     pos
        BL      FD$TOI                  ; CAST TO INT
        POP     {r2, r3, pc}


pos:	LSL	ope, r0, #1		; PUT EXPONENT IN ope
	LSR	ope, ope, #21		;

	MOV	tmp, #0x3		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	SUB	ope, ope, tmp		; ADJUST FOR EXPONENT BIAS AND
	BCC	unfl			; CHECK FOR UNDERFLOW

	MOV	tmp, #0x1F		;
	SUB	ope, tmp, ope		; CHECK FOR OVERFLOW
	BCC	ovfl			; IF OVERFLOW, RETURN 0xFFFFFFFF

	LSL	r0, r0, #11		; PUT HI MANTISSA IN r0
	MOV	tmp, #0x1		;
	LSL	tmp, tmp, #31		;
	ORR	r0, tmp			; SET IMPLIED ONE IN HI MANTISSA

	LSR	r0, ope			; COMPUTE THE INTEGER VALUE
	CMP	ope, #11		; FROM HI HALF OF THE MANTISSA.
	BCS	$1			; IF THE LOW HALF OF THE MANTISSA IS
	ADD	ope, #21		;  SIGNIFICANT, INCLUDE IT INTO THE 
	LSR	r1, ope			;  INTEGER VALUE, ALSO.
	ORR	r0, r1			;

$1:	POP	{r2, r3, pc}		;

unfl:   MOV     r0, #0                  ; UNDERFLOW
	POP	{r2, r3, pc}		;
 
ovfl:	MOV	r0, #0x0		; IF OVERFLOW, RETURN INFINITY
	SUB	r0, r0, #0x1		;
	POP	{r2, r3, pc}		;
 
	.endasmfunc

	.end
fd_tou32.asm/   1202506627  0     0     0       3851      `
;******************************************************************************
;* FD_TOU32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD_TOU - CONVERT AN IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;* 	    POINT NUMBER TO A 32 BIT UNSIGNED INTEGER
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1
;*   o RESULT IS RETURNED IN r0
;*   o INPUT OP IN r1 IS DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0xFFFFFFFF
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o NEGATIVE VALUE RETURNS ZERO
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global	FD_TOU, FD_TOI

ope	.set	lr

FD_TOU:	.asmfunc stack_usage(4)
	STMFD   sp!, {lr}               ; SAVE CONTEXT
	CMP	r0, #0			; CHECK FOR A NEGATIVE VALUE
	BPL     pos
        BL      FD_TOI                  ; CAST TO INT
        LDMFD   sp!, {pc}               ;

pos:	MOV	ope, r0, LSL #1		; PUT EXPONENT IN ope
	MOV	ope, ope, LSR #21	;

	SUB	ope, ope, #0x300	; ADJUST FOR EXPONENT BIAS AND
	SUBS	ope, ope, #0xFF		; CHECK FOR UNDERFLOW
	MOVMI	r0, #0			; IF UNDERFLOW, RETURN ZERO
	LDMMIFD sp!, {pc}		;

	RSBS	ope, ope, #0x1F		; CHECK FOR OVERFLOW
	BCC	ovfl			; IF OVERFLOW, RETURN 0xFFFFFFFF

	MOV	r0, r0, LSL #11		; PUT HI MANTISSA IN r0
	ORR	r0, r0, #0x80000000	; SET IMPLIED ONE IN HI MANTISSA

	MOV	r0, r0, LSR ope		; COMPUTE THE INTEGER VALUE FROM HI 
	CMP	ope, #11		; HALF OF THE MANTISSA.  IF THE LOW
	ADDCC	ope, ope, #21		; HALF OF THE MANTISSA IS SIGNIFICANT,
	ORRCC	r0, r0, r1, LSR ope	; INCLUDE IT ALSO.

	LDMFD 	sp!, {pc}		;

ovfl:	MOV	r0, #0x0		; IF OVERFLOW, RETURN 0XFFFFFFFF
	SUB	r0, r0, #0x1		;
	LDMFD	sp!, {pc}		;

	.endasmfunc

	.end

fd_toull16.asm/ 1202506627  0     0     0       4882      `
;******************************************************************************
;* FD_TOULL16.ASM  - 16 BIT STATE -  v2.70                                    *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD$TOULL - CONVERT AN IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;*            INTO AN UNSIGNED 64 BIT INTEGER 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0xFFFFFFFF:FFFFFFFF
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o NEGATIVE VALUE RETURNS ZERO
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global	FD$TOULL, FD$TOLL

ope	.set	r2
tmp	.set	r3

FD$TOULL: .asmfunc stack_usage(12)
        PUSH	{r2-r3, lr}		; SAVE CONTEXT

	CMP	r0, #0			; CHECK FOR A NEGATIVE VALUE
        BPL     pos
        BL      FD$TOLL                 ; CAST TO INT
        POP     {r2, r3, pc}


pos:	LSL	ope, r0, #1		; PUT EXPONENT IN ope
	LSR	ope, ope, #21		;

	MOV	tmp, #0x3		;
	LSL	tmp, tmp, #8		;
	ADD	tmp, #0xFF		;
	SUB	ope, ope, tmp		; ADJUST FOR EXPONENT BIAS AND
	BCC	unfl			; CHECK FOR UNDERFLOW

	MOV	tmp, #0x3F		;
	SUB	ope, tmp, ope		; CHECK FOR OVERFLOW
	BCC	ovfl			; IF OVERFLOW, RETURN 0xFFFFFFFF

	LSL	r0, r0, #11		; PUT MANTISSA IN r0:r1
        LSR     tmp, r1, #21            ;
        ORR     r0, tmp                 ;
        LSL     r1, r1, #11             ;
	MOV	tmp, #0x1		;
	LSL	tmp, tmp, #31		;
	ORR	r0, tmp			; SET IMPLIED ONE IN HI MANTISSA

        ; COMPUTE THE INTEGER VALUE
        MOV     tmp, ope                ;
        SUB     tmp, #32                ; IF ope >= 32 
        BCC     $1                      ;
        MOV     r1, r0                  ;    r0:r1 = 0:r0 >> (ope - 32)
        MOV     r0, #0                  ;
	LSR	r1, tmp		        ;
	B       return                  ;
$1:
        LSR     r1, ope                 ; IF ope < 32
        NEG     tmp, tmp                ;    
        MOV     lr, r0                  ;    r0:r1 = r0:r1 >> ope
        LSL     r0, tmp                 ;
        ORR     r1, r0                  ;
        MOV     r0, lr                  ;
        LSR     r0, ope                 ;

	; IN LITTLE ENDIAN MODE THE OUTPUT LONG LONG VALUE SHOULD BE IN R1:R0.
	; SO SWAP THE REGISTER VALUES BEFORE RETURN.
return:
	.if .TMS470_LITTLE
	MOV	lr, r0			;
	MOV	r0, r1			;
	MOV	r1, lr			;
	.endif

	POP	{r2-r3, pc}		;

unfl:   MOV     r0, #0                  ; UNDERFLOW
        MOV     r1, #0                  ;
	POP	{r2-r3, pc}		;
 
ovfl:	MOV	r0, #0x0		; IF OVERFLOW, 
	SUB	r0, r0, #0x1		; RETURN 0xFFFFFFFF:FFFFFFFF
        MOV     r1, r0                  ;
	POP	{r2-r3, pc}		;
	
	.endasmfunc
	.end
fd_toull32.asm/ 1202506627  0     0     0       4616      `
;******************************************************************************
;* FD_TOULL32.ASM  - 32 BIT STATE -  v2.70                                    *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FD_TOULL - CONVERT AN IEEE 754 FORMAT DOUBLE PRECISION FLOATING 
;*   	      POINT NUMBER TO A 64 BIT UNSIGNED INTEGER
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0xFFFFFFFF:FFFFFFFF
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o NEGATIVE VALUE RETURNS ZERO
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global	FD_TOULL, FD_TOLL

ope	.set	lr
tmp     .set    r2

FD_TOULL: .asmfunc stack_usage(8)
	STMFD	sp!, {r2, lr}		; SAVE CONTEXT
        CMP	r0, #0			; CHECK FOR A NEGATIVE VALUE
	BPL     pos
        BL      FD_TOLL                 ; CAST TO INT
	LDMFD	sp!, {r2, pc}


pos:	MOV	ope, r0, LSL #1		; PUT EXPONENT IN ope
	MOV	ope, ope, LSR #21	;

	SUB	ope, ope, #0x300	; ADJUST FOR EXPONENT BIAS AND
	SUBS	ope, ope, #0xFF		; CHECK FOR UNDERFLOW
	MOVMI	r0, #0			; IF UNDERFLOW, RETURN ZERO
	MOVMI	r1, #0			; 
	LDMMIFD sp!, {r2, pc}		;

	RSBS	ope, ope, #0x3F		; CHECK FOR OVERFLOW. IF OVERFLOW, 
	BCC	ovfl			; RETURN 0xFFFFFFFF:FFFFFFFF

	MOV	r0, r0, LSL #11		; SHIFT THE EXPONENT (11 BITS) 
        ORR     r0, r0, r1, LSR #21     ; OUT OF THE MANTISSA R0:R1 
        MOV     r1, r1, LSL #11         ; 
	ORR	r0, r0, #0x80000000	; SET IMPLIED ONE IN HI MANTISSA 

        ; ADJUST THE VALUE IN R0:R1 FOR THE EXPONENT BY RIGHT SHIFTING 
        ; EXPONENT NUMBER OF BITS OUT OF R0:R1.
        SUBS    tmp, ope, #0x20         ; IF (EXP >= 32)
        MOVCS   r1, r0, LSR tmp         ;    R1 = MNT.HI >> EXP - 32
        MOVCS   r0, #0                  ;    R0 = 0 

        RSBCC   tmp, ope, #0x20         ; IF (EXP < 32)
        MOVCC   r1, r1, LSR ope         ; R0:R1 = R0:R1 >> EXP
        MOVCC   tmp, r0, LSL tmp        ;
        ORRCC   r1, r1, tmp             ;
        MOVCC   r0, r0, LSR ope         ;

	; IN LITTLE ENDIAN MODE THE OUTPUT LONG LONG VALUE SHOULD BE IN R1:R0.
	; SO SWAP THE REGISTER VALUES BEFORE RETURN.

	.if .TMS470_LITTLE
	MOV	lr, r0			;
	MOV	r0, r1			;
	MOV	r1, lr			;
	.endif

	LDMFD 	sp!, {r2, pc}		;

ovfl:	MOV	r0, #0x0		; IF OVERFLOW, RETURN 0XFFFFFFFF
	SUB	r0, r0, #0x1		;
        MOV     r1, r0                  ;
	LDMFD	sp!, {r2, pc}		;

	.endasmfunc
	.end
feof.c/         1202506627  0     0     0       829       `
/*****************************************************************************/
/*  FEOF.C v2.70                                                             */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the function FEOF, which returns a 1 if an EOF      */
/*    has occured on that stream.  The function merely calls a macro         */
/*    that is defined in STDIO.H.                                            */
/*****************************************************************************/
#include <stdio.h>

_CODE_ACCESS int feof(FILE *_fp) { return (((_fp)->flags & _STATEOF)); }


ferror.c/       1202506628  0     0     0       827       `
/*****************************************************************************/
/*  FERROR.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This file contains the function FERROR, which returns a 1 if an I/O    */
/*    error has occured on that stream.  The function merely calls a macro   */
/*    that is defined in STDIO.H.                                            */
/*****************************************************************************/
#include <stdio.h>

_CODE_ACCESS int ferror(FILE *_fp) { return (_STCHK(_fp, _STATERR)); }


fflush.c/       1202506628  0     0     0       5188      `
/*****************************************************************************/
/*  FFLUSH.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* FUNCTIONS:                                                                */
/*    fflush   -  Call _doflush for all streams that require flushing        */
/*    _doflush -  Flush one stream                                           */
/*****************************************************************************/
#include <stdio.h>
#include <_lock.h>
#include "file.h"

extern _DATA_ACCESS int _ft_end;

int _doflush(FILE *_fp);






/*****************************************************************************/
/* FFLUSH   -  Call _doflush for all streams that require flushing           */
/*                                                                           */
/*    This function returns a 0 upon success, and an EOF upon failure.       */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int fflush(register FILE *_fp)
{
   int result = 0;
 
   /*------------------------------------------------------------------------*/
   /* If _fp is not a NULL pointer, call _DOFLUSH for that stream.           */
   /* Otherwise, call _DOFLUSH for all file streams in the table that are    */
   /* active.                                                                */
   /*------------------------------------------------------------------------*/
   if (_fp) result = _doflush(_fp);
   else
   {
      int index;

      /*---------------------------------------------------------------------*/
      /* This is a critical section because it depends on the global	     */
      /* variable _ft_end.						     */
      /*---------------------------------------------------------------------*/
      _lock();
      for(index = 0; index < _ft_end; index++)
         if(_ftable[index].fd != -1) result |= _doflush(&_ftable[index]);
      _unlock();
   }
 
   return (result);
}






/*****************************************************************************/
/* _DOFLUSH -  Flush one stream                                              */
/*                                                                           */
/*    This function flushes the stream pointed to by _fp.  If the function   */
/*    is successful, it returns a 0.  If unsuccessful, it returns an EOF     */
/*                                                                           */
/*****************************************************************************/
int _doflush(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*                                                                        */
   /*    num_write   -  The number of bytes to be written to the file        */
   /*    errchk      -  An indicator to see if WRITE was successful          */
   /*------------------------------------------------------------------------*/
   unsigned num_write = _fp->pos - _fp->buf;
   int errchk = 0;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the stream is writable, and it has a buffer, call WRITE, and store  */
   /* its return value in errchk                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODEW)) errchk = write(_fp->fd, (char *)_fp->buf, num_write);
 
   /*------------------------------------------------------------------------*/
   /* If WRITE fails, set the error flag in the stream pointer, and return   */
   /* an EOF                                                                 */
   /*------------------------------------------------------------------------*/
   if(errchk < 0)
   {
      _SET(_fp, _STATERR);
      return (EOF);
   }
 
   /*------------------------------------------------------------------------*/
   /* Reset the buffer pointer, make files opened with the "+" flag          */
   /* available for wither reading or writing, and return a 0, indicating    */
   /* a success                                                              */
   /*------------------------------------------------------------------------*/
   _fp->pos          =  _fp->buf;
   _fp->buff_stop    =  NULL;
   if (_STCHK(_fp, _MODERW)) _UNSET(_fp, (_MODER | _MODEW));
   return 0;
 
}
 
fgetc.c/        1202506628  0     0     0       4142      `
/*****************************************************************************/
/*  FGETC.C v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    GETC     -  Get a character from a stream                              */
/*    GETCHAR  -  Get a character from stdin                                 */
/*    FGETC    -  Get a character from a stream                              */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern void _buff_read(FILE *_fp);
extern int  _rd_ok    (FILE *_fp);

extern _CODE_ACCESS int fgetc(register FILE *_fp);






/*****************************************************************************/
/* GETC  -  Get a character from a stream                                    */
/*                                                                           */
/*    This function is equivalent to FGETC.                                  */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int getc(FILE *_fp) { return (fgetc(_fp)); }






/*****************************************************************************/
/* GETCHAR  -  Get a character from stdin                                    */
/*                                                                           */
/*    This function calls a macro defined in STDIO.H, which calls FGETC with */
/*    stdin as its argument.                                                 */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int getchar(void) { return(_getchar()); }






/*****************************************************************************/
/* FGETC -  Get a character from a stream                                    */
/*****************************************************************************/
_CODE_ACCESS int fgetc(register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Make sure that it is OK to read from this stream.                      */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp)) return (EOF);
   
   /*------------------------------------------------------------------------*/
   /* For non-buffered streams, call the lowlevel READ function.             */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      int   errchk;
      char  result;

      errchk = read(_fp->fd, &result, 1);
      if(errchk <= 0)
      {
         _SET(_fp, (errchk == 0) ? _STATEOF : _STATERR);
         return (EOF);
      }

      return ((int)result);
   }

   /*------------------------------------------------------------------------*/
   /* If the buffer has been entirely read, or is empty, call _BUFF_READ to  */
   /* fill the buffer.                                                       */
   /*------------------------------------------------------------------------*/
   if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);
 
   /*------------------------------------------------------------------------*/
   /* If the buffer read was unsuccessful, return an EOF.  Otherwise, clear  */
   /* the _UNGETC flag in the stream, and return the next character.         */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, (_STATERR | _STATEOF))) return (EOF);
   _UNSET(_fp, _UNGETC);

   return ((int)*(_fp->pos++)); 
   
}

fgetpos.c/      1202506628  0     0     0       1018      `
/*****************************************************************************/
/*  FGETPOS.C v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*    This function contains the function FGETPOS, which stores the current  */
/*    position in the file into the variable pointed to by _POS.  A 0 is     */
/*    returned upon success, and upon failure, ERRNO is set to 5, and a -1L  */
/*    is returned.                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <errno.h>
#include "file.h"

_CODE_ACCESS int fgetpos(FILE *_fp, fpos_t *_pos)
{
   if((*_pos = ftell(_fp)) != -1L) return (0);
   else { errno = 5; return (-1);  }
}

fgets.c/        1202506628  0     0     0       7794      `
/*****************************************************************************/
/*  FGETS.C v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FGETS    -  Get a string from a stream                                 */
/*    GETS     -  Get a string from stdin                                    */
/*    _DOFGETS -  Perform the main FGETS routine                             */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"

extern int  _rd_ok(FILE *_fp);
extern void _buff_read(FILE *_fp);

static char *_dofgets(char *_ptr, register int _size, register FILE *_fp,
                      int _gets_flag);






/*****************************************************************************/
/* FGETS -  Get a string from a stream                                       */
/*                                                                           */
/*    This function calls _DOFGETS, with a 0 for the _GETS_FLAG argument.    */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS char *fgets(char *_ptr, register int _size, register FILE *_fp)
{
   return(_dofgets(_ptr, _size, _fp, 0));
}






/*****************************************************************************/
/* GETS  -  Get a string from stdin                                          */
/*                                                                           */
/*    This function calls FGETS with stdin as the stream argument.           */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS char *gets(char *_ptr) { return (_dofgets(_ptr, 1, stdin, 1)); }






/*****************************************************************************/
/* _DOFGETS -  Perform the main FGETS routine                                */
/*                                                                           */
/*    This function gets a string from the stream _FP.  It returns a pointer */
/*    to the string upon success, or NULL upon failure.                      */
/*                                                                           */
/*****************************************************************************/
static char *_dofgets(char *_ptr, register int _size, register FILE *_fp, 
                      int _gets_flag)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned    char     *next_nl    = NULL;
               char     *fpos       = _ptr;
               size_t   num_left    = _size -1,
                        num_to_read;
               int      skipped_nl  = 0;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is readable.                                 */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp) || _STCHK(_fp, _STATEOF) || (_size -1) < 0) return (NULL);

   /*------------------------------------------------------------------------*/
   /* If the stream is non buffered, read the string in one character at a   */
   /* time, using the lowlevel READ function.                                */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      int errchk;
 
      while((errchk = read(_fp->fd, fpos, 1) > 0) && (*(fpos++) != '\n'));
 
      switch(errchk)
      {
         case  0 :
         case -1 : return (NULL);
      }
 
      *fpos = '\0';
 
      return (_ptr);
   }
 
   while((num_left > 0 || _gets_flag) && ! next_nl)
   {
      /*---------------------------------------------------------------------*/
      /* If the buffer is empty or completely read, fill it up.              */
      /*---------------------------------------------------------------------*/
      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop) _buff_read(_fp);

      if (_STCHK(_fp, (_STATERR | _STATEOF)))
      {
          /*-----------------------------------------------------------------*/
          /* If we've read any characters, fall out of for loop, returning   */
          /* what we've read in.                                             */
          /*-----------------------------------------------------------------*/
          if (fpos != _ptr) break;
          /*-----------------------------------------------------------------*/
          /* Otherwise we have not read anything (some kind of error).       */
          /*-----------------------------------------------------------------*/
          return (NULL);
      }

      /*---------------------------------------------------------------------*/
      /* Determine the location of the next newline character (NEXT_NL).     */
      /*---------------------------------------------------------------------*/
      next_nl = (unsigned char *)memchr(_fp->pos, '\n', (_fp->buff_stop - 
                                        _fp->pos));

      /*---------------------------------------------------------------------*/
      /* Determine how many characters to read from the buffer.  If this     */
      /* function was called from GETS (_GETS_FLAG == 1), read until a       */
      /* newline character, EOF character, or the end of the buffer is       */
      /* encountered.  Do the same otherwise, but do not read any more       */
      /* characters than specified by NUM_LEFT.                              */
      /*---------------------------------------------------------------------*/
      num_to_read =  _fp->buff_stop - _fp->pos;
      num_to_read =  (next_nl) ? (next_nl - _fp->pos + 1) : num_to_read;
      num_to_read =  (_gets_flag) ? num_to_read :
                     (num_left < num_to_read) ? num_left : num_to_read;

      /*---------------------------------------------------------------------*/
      /* If this function was called from GETS (_GETS_FLAG == 1), do not     */
      /* retain a newline character if one is present                        */
      /*---------------------------------------------------------------------*/
      if(next_nl && _gets_flag)
      {
         num_to_read--;
         skipped_nl = 1;
      }

      /*---------------------------------------------------------------------*/
      /* Copy the characters, and update pointers and counters.              */
      /*---------------------------------------------------------------------*/
      memcpy(fpos, _fp->pos, num_to_read);
      _fp->pos += (skipped_nl + num_to_read);
      num_left -= num_to_read;
      fpos += num_to_read;
   }

   /*------------------------------------------------------------------------*/
   /* Tack on the NULL terminator, clear the _UNGETC flag and the _GETS_FLAG.*/
   /*------------------------------------------------------------------------*/
   *fpos = '\0';
   _UNSET(_fp, _UNGETC);
   _gets_flag = 0; 

   return(_ptr);
}

file.h/         1202506628  0     0     0       3205      `
/*****************************************************************************/
/*  FILE.H v2.70                                                             */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Macros and declarations used in lowlevel I/O functions.                   */
/*****************************************************************************/
#ifndef _FILE
#define _FILE

#include <linkage.h>

/*---------------------------------------------------------------------------*/
/* constants for file manipulations                                          */
/*---------------------------------------------------------------------------*/
#define  O_RDONLY    (0x0000) /* open for reading      */
#define  O_WRONLY    (0x0001) /* open for writing      */
#define  O_RDWR      (0x0002) /* open for read & write */
#define  O_APPEND    (0x0008) /* append on each write  */
#define  O_CREAT     (0x0200) /* open with file create */
#define  O_TRUNC     (0x0400) /* open with truncation  */
#define  O_BINARY    (0x8000) /* open in binary mode   */

/*---------------------------------------------------------------------------*/
/* lowlevel I/O declarations                                                 */
/*---------------------------------------------------------------------------*/
#ifdef __cplusplus
#define _DECL extern "C"
#else /* ! __cplusplus */
#define _DECL extern
#endif

#ifndef _OFF_T
#define _OFF_T
typedef long off_t;
#endif /* _OFF_T */

#define SEEK_SET  (0x0000)
#define SEEK_CUR  (0x0001)
#define SEEK_END  (0x0002)

_DECL _CODE_ACCESS int   open(const char *path, unsigned flags, int mode);
_DECL _CODE_ACCESS int   read(int fildes, char *bufptr, unsigned cnt);
_DECL _CODE_ACCESS int   write(int fildes, const char *bufptr, unsigned cnt);
_DECL _CODE_ACCESS off_t lseek(int fildes, off_t offset, int origin);
_DECL _CODE_ACCESS int   close(int fildes);
_DECL _CODE_ACCESS int   unlink(const char *path);
_DECL _CODE_ACCESS int   rename(const char *old_name, const char *new_name);

_DECL _CODE_ACCESS int add_device(
    char     *name,			           
    unsigned  flags,
    int      (*dopen)(const char *path, unsigned flags, int llv_fd),
    int      (*dclose)(int dev_fd),
    int      (*dread)(int dev_fd, char *buf, unsigned count),
    int      (*dwrite)(int dev_fd, const char *buf, unsigned count),
    off_t    (*dlseek)(int dev_fd, off_t offset, int origin),
    int      (*dunlink)(const char *path),
    int      (*drename)(const char *old_name, const char *new_name));

#define _NSTREAM        20                   /* Size of stream table        */
#define _NDEVICE        3                    /* Size of device table        */

#define _SSA      (0x0000)             /* Single Stream allowed       */
#define _BUSY     (0x0001)             /* Device busy                 */
#define _MSA      (0x0002)             /* Multiple Streams Allowed    */

#undef _DECL

#endif /* _FILE */


float.h/        1202506628  0     0     0       3028      `
/*****************************************************************************/
/* float.h    v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

/********************************************************************/
/*    KEY:  FLT_     - APPLIES TO TYPE FLOAT                        */
/*          DBL_     - APPLIES TO TYPE DOUBLE                       */
/*          LDBL_    - APPLIES TO TYPE LONG DOUBLE                  */
/********************************************************************/
#ifndef _FLOAT
#define _FLOAT

#define FLT_RADIX                         2   /* RADIX OF EXPONENT         */
#define FLT_ROUNDS                        1   /* TRUE IF ADDITION ROUNDS   */

#define FLT_DIG                           6   /* DECIMAL PRECISION         */
#define FLT_MANT_DIG                     24   /* BITS IN MANTISSA          */
#define FLT_MIN_EXP                    -125   /* SMALLEST EXPONENT         */
#define FLT_MAX_EXP                     128   /* LARGEST EXPONENT          */
#define FLT_MIN_10_EXP                  -37   /* MIN POWER OF 10           */
#define FLT_MAX_10_EXP                   38   /* MAX POWER OF 10           */
#define FLT_EPSILON        1.192092896E-07F   /* SMALLEST X WHERE 1+X != 1 */
#define FLT_MIN            1.175494351E-38F   /* SMALLEST POSITIVE VALUE   */
#define FLT_MAX            3.402823466E+38F   /* LARGEST POSITIVE VALUE    */

#define DBL_DIG                          15   /* DECIMAL PRECISION         */
#define DBL_MANT_DIG                     53   /* BITS IN MANTISSA          */
#define DBL_MIN_EXP                   -1021   /* SMALLEST EXPONENT         */
#define DBL_MAX_EXP                    1024   /* LARGEST EXPONENT          */
#define DBL_MIN_10_EXP                 -307   /* MIN POWER OF 10           */
#define DBL_MAX_10_EXP                  308   /* MAX POWER OF 10           */
#define DBL_EPSILON  2.2204460492503131E-16   /* SMALLEST X WHERE 1+X != 1 */
#define DBL_MIN     2.2250738585072014E-308   /* SMALLEST POSITIVE VALUE   */
#define DBL_MAX     1.7976931348623157E+308   /* LARGEST POSITIVE VALUE    */
 
#define LDBL_DIG                         15   /* DECIMAL PRECISION         */
#define LDBL_MANT_DIG                    53   /* BITS IN MANTISSA          */
#define LDBL_MIN_EXP                  -1021   /* SMALLEST EXPONENT         */
#define LDBL_MAX_EXP                   1024   /* LARGEST EXPONENT          */
#define LDBL_MIN_10_EXP                -307   /* MIN POWER OF 10           */
#define LDBL_MAX_10_EXP                 308   /* MAX POWER OF 10           */
#define LDBL_EPSILON 2.2204460492503131E-16   /* SMALLEST X WHERE 1+X != 1 */
#define LDBL_MIN    2.2250738585072014E-308   /* SMALLEST POSITIVE VALUE   */
#define LDBL_MAX    1.7976931348623157E+308   /* LARGEST POSITIVE VALUE    */

#endif
floor.c/        1202506628  0     0     0       375       `
/****************************************************************************/
/*  FLOOR  v2.70                                                            */
/*  Copyright (c) 1993-2008 Texas Instruments Incorporated                  */
/****************************************************************************/

#undef _INLINE
#define _FLOOR

#include <math.h>

fmod.c/         1202506628  0     0     0       1434      `
/****************************************************************************/
/*  fmod   v2.70                                                            */
/*  Copyright (c) 1996-2008 Texas Instruments Incorporated                  */
/****************************************************************************/

#ifndef _MATH
#undef _INLINE
#endif

#include <math.h>

/****************************************************************************/
/*  FMOD() - Floating point remainder                                       */
/*									    */
/*  Returns the remainder after dividing x by y an integral number of times.*/
/*                                                                          */
/****************************************************************************/
double fmod(double x, double y)
{
   double d = fabs(x); 

   /*************************************************************************/
   /* if y is too small, any remainder is negligible.                       */
   /*************************************************************************/
   if (d - fabs(y) == d) return (0.0);

   /*************************************************************************/
   /* otherwise, divide; result = dividend - (quotient * divisor)           */
   /*************************************************************************/
   modf(x/y, &d);
   return (x - d * y);
}
fopen.c/        1202506628  0     0     0       9894      `
/*****************************************************************************/
/*  FOPEN.C v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* FUNCTIONS:                                                                */
/*    FOPEN       -  Open a file and return a pointer to it                  */
/*    FREOPEN     -  Switch a FILE pointer to a different stream             */
/*    _OPENFILE   -  Set file flags, and call lowlevel OPEN                  */
/*    _SEARCH_FP  -  Find an open slot in the file table                     */
/*****************************************************************************/
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <_lock.h>
#include "file.h"
 
extern _DATA_ACCESS int _ft_end;
extern _DATA_ACCESS void (*_cleanup_ptr)(void);

extern void   _cleanup(void);
 
static FILE *_search_fp(void);
static FILE *_openfile(const char *_fname, register FILE *_fp, const char
                       *_mode);


/*****************************************************************************/
/* FOPEN    -  Open a file and return a pointer to it                        */
/*                                                                           */
/*    This function calls _SEARCH_FP to locate an empty slot in the file     */
/*    table (_ftable), and calls _OPENFILE with it to open a stream to the   */
/*    file _FNAME.  It returns a pointer to the stream that was allocated,   */
/*    or NULL if it was not successful.                                      */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS FILE *fopen(const char *_fname, const char *_mode)
{
    FILE *f;

    /*-----------------------------------------------------------------------*/
    /* This is a critical section because search_fp looks for a new file     */
    /* slot in the global table _ftable.				     */
    /*-----------------------------------------------------------------------*/
    _lock();
    f = _openfile(_fname, _search_fp(), _mode);
    _unlock();
    return f;
}

 
/*****************************************************************************/
/* FREOPEN  -  Switch a FILE pointer to a different stream                   */
/*                                                                           */
/*    This function attempts to close any file associated with _FP, and then */
/*    reassigns _FP to the file _FNAME by calling _OPENFILE.  It returns a   */
/*    pointer to the stream if successful, or NULL if the function is not    */
/*    successful.                                                            */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS FILE *freopen(const char *_fname, const char *_mode, register FILE *_fp)
{
    FILE *f;

    /*-----------------------------------------------------------------------*/
    /* This is a critical section because it expects the same slot in the    */
    /* global table _ftable to be available.				     */
    /*-----------------------------------------------------------------------*/
    _lock();
    fclose(_fp); 
    f = _openfile(_fname, _fp, _mode);
    _unlock();
    return f;
}


/*****************************************************************************/
/* _SEARCH_FP  -  Find an open slot in the file table                        */
/*                                                                           */
/*    This function looks through the array _ftable, searching for a null    */
/*    pointer which indicates an empty slot.  It mallocs a stream for that   */
/*    slot, and assigns a pointer to it there, initializing it and returning */
/*    it to the calling function.                                            */
/*                                                                           */
/*****************************************************************************/
static FILE *_search_fp(void)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int index;
	
   /*------------------------------------------------------------------------*/
   /* Search the file table for an empty slot.  Return a NULL is there       */
   /* aren't any available.                                                  */
   /*------------------------------------------------------------------------*/
   for(index = 0; (index < _ft_end) && _ftable[index].fd != -1; index++);
   if (index == _NFILE) return (NULL);
   if (index == _ft_end) _ft_end++;

   /*------------------------------------------------------------------------*/
   /* Initialize the new stream.                                             */
   /*------------------------------------------------------------------------*/
   memset(&_ftable[index], '\0', sizeof(FILE));

   return (&_ftable[index]);
}
 

/*****************************************************************************/
/* _OPENFILE   -  Set file flags, and call lowlevel OPEN                     */
/*                                                                           */
/*    This function sets FILE flags for reading or writing by the character  */
/*    string _MODE.  It then calls the lowlevel OPEN function to open the    */
/*    file, and assigns the file descriptor returned from that function into */
/*    the FD member of the stream.                                           */
/*                                                                           */
/*****************************************************************************/
static FILE *_openfile(const char *_fname, register FILE *_fp, const char 
                       *_mode)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   int         wr, 
               bin = 0, 
               plus = 0;
   unsigned    lflags = 0;

   if (! _fp) return (NULL);
 
   /*------------------------------------------------------------------------*/
   /* SETUP _CLEANUP_PTR SO THAT ALL OPENED FILES WILL BE CLOSED AT EXIT.    */
   /*------------------------------------------------------------------------*/
   _cleanup_ptr = _cleanup;
   
   /*------------------------------------------------------------------------*/
   /* Set the flags in the stream to reflect to I/O mode of the stream to be */
   /* opened.                                                                */
   /*------------------------------------------------------------------------*/
   wr    = _mode[0];
   if (_mode[1])
   {
      bin  = ((_mode[1] == 'b') || (_mode[2] == 'b'));
      plus = ((_mode[1] == '+') || (_mode[2] == '+'));
   }

   _fp->flags = 0;

   if(!plus)
      _SET(_fp, (wr == 'r') ? _MODER : 
                (wr == 'w' || wr == 'a') ? _MODEW : 0);

   _SET(_fp, (wr == 'a') ? _MODEA : 0);
   _SET(_fp, (bin)  ? _MODEBIN : 0);
   _SET(_fp, (plus) ? _MODERW  : 0);
 
   if(bin) lflags |= (O_BINARY);

   /*------------------------------------------------------------------------*/
   /* Set the flags in LFLAGS to reflect the flags that will be necessary to */
   /* call the lowlevel OPEN function properly for this stream.              */
   /*------------------------------------------------------------------------*/
   switch (wr)
   {
      case 'r' : lflags |= (plus) ? O_RDWR : O_RDONLY;
                 break;
 
      case 'a' : lflags |= (plus) ? O_RDWR : O_WRONLY;
                 lflags |= (O_APPEND | O_CREAT);
                 break;
 
      case 'w' : lflags |= (plus) ? O_RDWR : O_WRONLY;
                 lflags |= (O_TRUNC | O_CREAT);
                 break;
   }

   /*------------------------------------------------------------------------*/
   /* Call the lowlevel OPEN function, and store the returned file           */
   /* descriptor into the stream.  If the OPEN function fails, return NULL.  */
   /*------------------------------------------------------------------------*/
   if ((_fp->fd = open(_fname, lflags, 0666)) < 0) return (NULL);

   return (_fp);
}


/*****************************************************************************/
/* _CLEANUP   -  CLOSE ALL OPEN STREAMS.  THIS IS CALLED BY EXIT() IF A FILE */
/*               IS EVER OPENED OR A BUFFER IS EVER CREATED.                 */
/*****************************************************************************/
void _cleanup(void)
{
   int j;

   /*------------------------------------------------------------------------*/
   /* CLOSE ALL STREAMS THAT ARE CURRENTLY OPEN.                             */
   /*------------------------------------------------------------------------*/
   /* This is a critical section because it depends on the global variable   */
   /* _ft_end.								     */
   /*------------------------------------------------------------------------*/
   _lock();
   fclose(&_ftable[0]);
   for(j = 1; j < _ft_end; j++) 
       if (_ftable[j].fd > 0) fclose(&_ftable[j]); 
   _unlock();
}
format.h/       1202506628  0     0     0       2285      `
/*****************************************************************************/
/*  FORMAT.H v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Structures and macros used in printf and scanf                            */
/*****************************************************************************/
#ifndef __FORMAT_H
#define __FORMAT_H
#include <stdarg.h>

#define _ARSIZE 400

#ifdef __cplusplus
extern "C" namespace std {
#else 
extern
#endif

  int _scanfi(void *inp, const char *_format, va_list _ap,
	      int (*_chkmbc)(void **inp, char **_format, int *num_read),
	      int (*_inpchar)(void **inp),
	      void (*_uninpchar)(void **inp, int outchar));
 
  /**************************************************************************/
  /* _FIELD STRUCTURE AND MACROS USED FOR PRINTF AND SCANF                  */
  /**************************************************************************/
  typedef struct {
    unsigned int flags;         /* Format flags */
    int          fwidth;        /* Field width */
    int          precision;     /* Field precision */
    char         conv;          /* Conversion specifier */
  } _PFIELD;
  
  typedef struct {
    unsigned int flags;         /* Format flags */
    int          fwidth;        /* Field width */
    int          precision;     /* Field precision */
    char         scanset[96];   /* Scanset used for '[' conversion */
    char         conv;          /* Conversion specifier */
  } _SFIELD;

#ifdef __cplusplus
}
#endif /* __cplusplus */

/****************/
/* PRINTF FLAGS */
/****************/

#define _PFMINUS  0x01
#define _PFPLUS   0x02
#define _PFSPACE  0x04
#define _PFPOUND  0x08
#define _PFZERO   0x10
 
/***************/
/* SCANF FLAGS */
/***************/

#define _SFSTAR   0x01
#define _SFCIRC   0x02

/****************/
/* MUTUAL FLAGS */
/****************/

#define _MFH      0x20
#define _MFL      0x40
#define _MFLD     0x80
#define _MFLL     0x100

#endif

fprintf.c/      1202506628  0     0     0       2879      `
/*****************************************************************************/
/*  FPRINTF.C v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FPRINTF  -  Print formatted output to a stream                         */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));

static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);


/*****************************************************************************/
/* FPRINTF  -  Print formatted output to a stream                            */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream _FP.              */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int fprintf(FILE *_fp, const char *_format, ...)
{
   va_list  _ap;
   int rval;
   char *fptr = (char *)_format;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (-1);

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)_fp, _outc, _outs);
   va_end(_ap);
   return (rval);
}
 

/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }


/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


fputc.c/        1202506628  0     0     0       4420      `
/*****************************************************************************/
/*  FPUTC.C v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PUTC     -  Write a character to a stream                              */
/*    PUTCHAR  -  Write a character to stdout                                */
/*    FPUTC    -  Write a character to a stream                              */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _wrt_ok(FILE *_fp);
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* PUTC  -  Write a character to a stream                                    */
/*                                                                           */
/*    This function is equivalent to FPUTC.                                  */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int putc(int _x, FILE *_fp) { return(fputc(_x, _fp)); }






/*****************************************************************************/
/* PUTCHAR  -  Write a character to stdout                                   */
/*                                                                           */
/*    This function calls a macro defined in STDIO.H, which in turn calls    */
/*    FPUTC, with stdout as its stream argument.                             */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int putchar(int _x) { return(_putchar(_x)); }






/*****************************************************************************/
/* FPUTC -  Write a character to a stream                                    */
/*                                                                           */
/*    This function writes character _C into the stream specified by _FP.    */
/*    Upon success, it returns the character written.  Upon failure, it      */
/*    returns an EOF.                                                        */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int fputc(int _c, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
      char cbuf = (char)_c;

      if((write(_fp->fd, &cbuf, 1)) == -1)
      {
         _SET(_fp, _STATERR);
         return (EOF);
      }
      else return ((unsigned char)_c);
   }

   /*------------------------------------------------------------------------*/
   /* Put the character in the buffer.                                       */
   /*------------------------------------------------------------------------*/
   *(_fp->pos++) = (unsigned char)_c;

   /*------------------------------------------------------------------------*/
   /* If the buffer is full, or a line-buffered stream reached a newline     */
   /* character, flush it.                                                   */
   /*------------------------------------------------------------------------*/
   if((_fp->pos == _fp->bufend) || (_STCHK(_fp, _IOLBF) && _c == '\n'))
      if(_doflush(_fp))
      {
         _SET(_fp, _STATERR);
         return (EOF);
      }

   return((unsigned char)_c);
}

fputs.c/        1202506628  0     0     0       5194      `
/*****************************************************************************/
/*  FPUTS.C v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PUTS  -  Write a string to stdout                                      */
/*    FPUTS -  Write a string to a stream                                    */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"

extern int _wrt_ok(FILE *_fp);
extern int _doflush(FILE *_fp);






/*****************************************************************************/
/* PUTS  -  Write a string + newline to stdout.                              */
/*                                                                           */
/*    This function calls FPUTS, with stdout as the stream argument.         */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int puts(const char *_ptr) 
{ 
    int count = fputs(_ptr, stdout);
    count += fputs("\n", stdout); 
    return count;
}



/*****************************************************************************/
/* FPUTS -  Write a string to a stream                                       */
/*                                                                           */ 
/*    This function writes string _PTR to stream _FP, returning the number   */
/*    of characters written upon success, or an EOF upon failure.            */
/*                                                                           */ 
/*****************************************************************************/
_CODE_ACCESS int fputs(const char *_ptr, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   size_t   num_left, ptr_strlen;
   char     *fpos          = (char *)_ptr;
   int      room_left,
            flush_flag     = 0,
            num_to_write;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp)) return (EOF);
 
   room_left = (int)(_fp->bufend - _fp->pos);
   ptr_strlen = num_left = strlen(_ptr);

   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF) 
   {
       int num_written = 0;

       while (num_left > 0)
       {
	   int write_return = write(_fp->fd, _ptr + num_written, num_left);
	   if (write_return < 0) 
	   { 
	       _SET(_fp, _STATERR); 
	       return (EOF);
	   }
	   else
	   {
	       num_written += write_return;
	       num_left    -= write_return;
	   }
       }

       return ptr_strlen;
   }
 
   /*------------------------------------------------------------------------*/
   /* Write the string into the buffer, flushing it when full.               */
   /*------------------------------------------------------------------------*/
   while(num_left > 0)
   {
      num_to_write = (num_left > room_left) ? room_left : num_left;
      if((_BUFFMODE(_fp) == _IOLBF) && memchr(fpos, '\n', num_to_write))
      { 
         num_to_write = (char *)memchr(fpos, '\n', num_to_write) - fpos + 1;
         flush_flag = 1;
      }
      memcpy(_fp->pos, fpos, num_to_write);

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      _fp->pos  += num_to_write;
      fpos      += num_to_write;
      num_left  -= num_to_write;
      room_left -= num_to_write;

      /*---------------------------------------------------------------------*/
      /* If the buffer is full, flush it.  Any I/O errors cause this         */
      /* function to exit, returning an EOF.                                 */
      /*---------------------------------------------------------------------*/
      if(room_left == 0 || flush_flag)
      {
         if(_doflush(_fp))
         {
            _SET(_fp, _STATERR);
            return (EOF);
         }
         room_left = (int)(_fp->bufend - _fp->pos);
         _SET(_fp, _MODEW);
         flush_flag = 0;
      }
   }
   return ptr_strlen;
}

fread.c/        1202506628  0     0     0       4825      `
/*****************************************************************************/
/*  FREAD.C v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FREAD       -  Read a block of bytes from a stream                     */
/*****************************************************************************/
#include <string.h>
#include <stdio.h>
#include "file.h"
 
extern int  _rd_ok(FILE *_fp);
extern void _buff_read(FILE *_fp);





/*****************************************************************************/
/* FREAD -  Read a block of bytes from a stream                              */
/*                                                                           */
/*    This function reads _COUNT blocks of _SIZE size from stream _FP, and   */
/*    stores them in string _PTR.  The function returns the number of        */
/*    blocks read.                                                           */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS size_t fread(void *_ptr, size_t _size, size_t _count, FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned char     *fpos       = (unsigned char *)_ptr;
            size_t   num_left    = _size * _count,
                     num_read    = 0,
                     num_to_read = 0;
 
   /*------------------------------------------------------------------------*/
   /* Make sure that the file is readable.                                   */
   /*------------------------------------------------------------------------*/
   if(! _rd_ok(_fp) || _size == 0 || _count == 0) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel READ function.	     */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF)
   {
       int num_read = 0;

       while (num_left > 0)
       {
	   int read_return = (size_t)(read(_fp->fd, 
					   (char *)fpos + num_read, num_left));
	   if (read_return < 0)
	   {
	       _SET(_fp, _STATERR);
	       return (num_read / _size);
	   }
	   else if (read_return == 0) 
	   {
	       _SET(_fp, _STATEOF);
	       return (num_read / _size);
	   }
	   else 
	   {
	       num_read += read_return;
	       num_left -= read_return;
	   }
       }

       return (num_read / _size);
   }
   
   while (num_left > 0)
   {
      /*---------------------------------------------------------------------*/
      /* If the buffer has been completely read, fill it up.  Exit the loop  */
      /* if an I/O error occurs, or the end of the file is reached.          */
      /*---------------------------------------------------------------------*/
      if(_fp->pos == _fp->buff_stop || !_fp->buff_stop)  _buff_read(_fp);
      if(_STCHK(_fp, (_STATERR | _STATEOF))) break;

      /*---------------------------------------------------------------------*/
      /* Determine how many characters can fit in the buffer, and read them  */
      /* in.                                                                 */
      /*---------------------------------------------------------------------*/
      num_to_read = (num_left < (_fp->buff_stop - _fp->pos)) ?
                    num_left : (_fp->buff_stop - _fp->pos);
      memcpy(fpos, _fp->pos, num_to_read);

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      fpos += num_to_read;
      _fp->pos += num_to_read;
      num_read += num_to_read;
      num_left -= num_to_read; 
   }

   /*------------------------------------------------------------------------*/
   /* Clear the _UNGETC flag in the stream, and return the number of blocks  */
   /* read.                                                                  */
   /*------------------------------------------------------------------------*/
   _UNSET(_fp, _UNGETC);
 
   return (num_read / _size);
 
}
 

frexp.c/        1202506628  0     0     0       1329      `
/****************************************************************************/
/*  frexp  v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>

double frexp(double value, int *exp)
{
     unsigned long *ptr = (unsigned long *)&value;

     /***********************************************************************/
     /* IF THE VALUE IS ZERO, THE RESULTS ARE ZERO                          */ 
     /***********************************************************************/ 
     if (!*ptr) { *exp = 0; return value; }

     /***********************************************************************/
     /* EXTRACT THE EXPONENT, SUBTRACT THE BIAS, THEN ADD 1                 */
     /***********************************************************************/
     *exp = ((*ptr >> 20) & 0x7FF) - 0x3FE;

     /***********************************************************************/
     /* SET THE EXPONENT OF THE FRACTION TO -1                              */
     /***********************************************************************/
     *ptr = (*ptr & 0x800FFFFF) | (0x3FE << 20);

     return (value);
}

fs_add16.asm/   1202506628  0     0     0       6454      `
;******************************************************************************
;* FS_ADD16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;*****************************************************************************
;* FS$ADD/FS$SUB - ADD/SUBTRACT TWO IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	           POINT NUMBERS.
;*****************************************************************************
;*
;*   o INPUT OP1 IS IN r0
;*   o INPUT OP2 IS IN r1
;*   o RESULT IS RETURNED IN r0
;*   o FOR SUBTRACTION, INPUT OP2 IN r1 IS KILLED 
;*
;*   o SUBTRACTION, OP1 - OP2, IS IMPLEMENTED WITH ADDITION, OP1 + (-OP2)
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY (0x7f800000/ff800000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;*   o IF OPERATION INVOLVES INFINITY AS AN INPUT, THE FOLLOWING SUMMARIZES
;*     THE RESULT:
;*                   +----------+----------+----------+ 
;*         ADDITION  + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   -INF   +   +INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |   -INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +   +INF   +
;*        +----------+----------+----------+----------+
;*
;*                   +----------+----------+----------+ 
;*       SUBTRACTION + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   +INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |   -INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +   +INF   +
;*        +----------+----------+----------+----------+
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global FS$ADD
	.global FS$SUB


m0	.set	r2
e0	.set	r3
m1	.set	r4
e1	.set	r5
shift	.set	r6
tmp	.set	r7

FS$SUB:	.asmfunc stack_usage(24)
	PUSH	{r2-r7}			;
	MOV	tmp, #1			;
	LSL	tmp, tmp, #31		;
	EOR	r1, tmp			; NEGATE INPUT #2
	B	$1			;

FS$ADD:	PUSH	{r2-r7}			;
	MOV	tmp, #1			;
	LSL	tmp, tmp, #31		;

$1:	LSL	m1, r1, #8		; PUT INPUT #2 MANTISSA IN m1
	LSL	e1, r1, #1		; PUT INPUT #2 EXPONENT IN e1
	LSR	e1, e1, #24		;
	BNE	$2			;

	CMP	m1, #0			; IF DENORMALIZED NUMBER (m0 != 0 AND
	BNE	unfl			; e1 == 0), THEN UNDERFLOW
	POP	{r2-r7}			;  ELSE IT IS ZERO SO RETURN INPUT #1
	MOV	pc, lr			;

$2:	ORR	m1, tmp			; SET IMPLIED ONE IN MANTISSA

	CMP	e1, #0xFF		; IF e1 == 0xFF, THEN OVERFLOW
	BEQ	ovfl1			;

	LSR	m1, m1, #2		; ADJUST THE MANTISSA
	CMP	r1, #0			; IF INPUT #2 IS NEGATIVE,
	BPL	$3			;
	NEG	m1, m1 			;  THEN NEGATE THE MANTISSA

$3:	LSL	m0, r0, #8		; PUT INPUT #1 MANTISSA IN m0
	LSL	e0, r0, #1		; PUT INPUT #1 EXPONENT IN e0
	LSR	e0, e0, #24		;
	BNE	$4			;

	CMP	m0, #0			; IF A DENORMALIZED NUMBER 
	BNE	unfl			; (m0 != 0 AND e0 == 0), THEN UNDERFLOW
	MOV	r0, r1			;  ELSE IT IS ZERO SO RETURN INPUT #2
	POP	{r2-r7}			; 
	MOV	pc, lr			;

$4:	ORR	m0, tmp			; SET IMPLIED ONE IN MANTISSA

	CMP	e0, #0xFF		; IF e0 == 0xFF, THEN OVERFLOW
	BEQ	ovfl0			;

	LSR	m0, m0, #2		; ADJUST THE MANTISSA
	CMP	r0, #0			; IF INPUT #1 IS NEGATIVE,
	BPL	$5			;
	NEG	m0, m0			;  THEN NEGATE THE MANTISSA
	

$5:	SUB	shift, e0, e1		; GET THE SHIFT AMOUNT
	BPL	$6			;
	MOV	tmp, m0			; IF THE SHIFT AMOUNT IS NEGATIVE, THEN
	MOV	m0, m1			;  SWAP THE TWO MANTISSA SO THAT m0
	MOV	m1, tmp			;  CONTAINS THE LARGER VALUE,
	NEG	shift, shift		;  AND NEGATE THE SHIFT AMOUNT,
	MOV	e0, e1			;  AND ENSURE THE LARGER EXP. IS IN e0

$6:	CMP	shift, #30		; IF THE SECOND MANTISSA IS SIGNIFICANT,
	BPL	$7			;
	ASR	m1, shift		;  ADD IT TO THE FIRST MANTISSA
	ADD	m0, m1			;

$7:	CMP	m0, #0x0		; IF THE RESULT IS ZERO, 
	BEQ	unfl 			;  THEN UNDERFLOW
	BPL	$8			;
	NEG	m0, m0			; IF THE RESULT IS NEGATIVE, THEN
	MOV	tmp, #0x1		;  NEGATE THE RESULT AND
	B	loop			;

$8:	MOV	tmp, #0x0		; NOTE THE SIGN

loop:	SUB	e0, #1			; NORMALIZE THE RESULTING MANTISSA
	LSL	m0, m0, #1		; ADJUSTING THE EXPONENT AS NECESSARY
	BPL	loop			;

	ADD	m0, #0x80		; ROUND THE MANTISSA TO THE NEAREST
	BCC	$9			;
	ADD	e0, e0, #1		; ADJUST EXPONENT IF AN OVERFLOW OCCURS
	B	ct			;

$9:	LSL	m0, m0, #1		; REMOVE THE IMPLIED ONE

ct:	ADD	e0, #2			; NORMALIZE THE EXPONENT
	BLE	unfl			; CHECK FOR UNDERFLOW
	CMP	e0, #0xFF		;
	BCS	ovfl			; CHECK FOR OVERFLOW

	LSR	r0, m0, #9		; REPACK THE MANTISSA INTO r0
	LSL	e0, e0, #23		;
	ORR	r0, e0			; REPACK THE EXPONENT INTO r0
	LSL	tmp, tmp, #31		;
	ORR	r0, tmp			; REPACK THE SIGN INTO r0

	POP	{r2-r7}			;
	MOV	pc, lr			;
	
unfl:	MOV	r0, #0			; UNDERFLOW
	POP	{r2-r7}			;
	MOV	pc, lr			;

					; OVERFLOW
ovfl1:  MOV	r0, r1			; SIGN BIT in R1
ovfl0:	LSR	tmp, r0, #31 		; ISOLATE SIGN BIT
ovfl:	LSL	tmp, tmp, #31		; 
	MOV	r0, #0ffh		; EXPONENT = Emax = 255
	LSL	r0, r0, #23		; SHIFT EXPONENT INTO PLACE
	ORR	r0, tmp			; COMBINE WITH SIGN BIT
	POP	{r2-r7}			;
	MOV	pc, lr			;

	.endasmfunc

	.end
fs_add32.asm/   1202506628  0     0     0       6247      `
;******************************************************************************
;* FS_ADD32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;*****************************************************************************
;* FS_ADD/FS_SUB - ADD/SUBTRACT TWO IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	           POINT NUMBERS.
;*****************************************************************************
;*
;*   o INPUT OP1 IS IN r0
;*   o INPUT OP2 IS IN r1
;*   o RESULT IS RETURNED IN r0
;*   o FOR SUBTRACTION, INPUT OP2 IN r1 IS KILLED 
;*
;*   o SUBTRACTION, OP1 - OP2, IS IMPLEMENTED WITH ADDITION, OP1 + (-OP2)
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY (0x7f800000/ff800000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;*   o IF OPERATION INVOLVES INFINITY AS AN INPUT, THE FOLLOWING SUMMARIZES
;*     THE RESULT:
;*                   +----------+----------+----------+ 
;*         ADDITION  + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   -INF   +   +INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |   -INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +   +INF   +
;*        +----------+----------+----------+----------+
;*
;*                   +----------+----------+----------+ 
;*       SUBTRACTION + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   +INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |   -INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +   +INF   +
;*        +----------+----------+----------+----------+
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global FS_ADD
	.global FS_SUB


m0	.set	r2
e0	.set	r3
m1	.set	r4
e1	.set	r5
shift	.set	r6
tmp	.set	lr

FS_SUB:	.asmfunc stack_usage(24)
	EOR	r1, r1, #0x80000000	; NEGATE INPUT #2

FS_ADD:
	STMFD	sp!, {r2-r6, lr}

	MOV	m1, r1, LSL #8		; PUT INPUT #2 MANTISSA IN m1
	MOV	e1, r1, LSL #1		; PUT INPUT #2 EXPONENT IN e1
	MOVS	e1, e1, LSR #24		;
	BNE	$1			;

	CMP	m1, #0			; IF DENORMALIZED NUMBER (m0 != 0 AND
	MOVNE	r0, #0			; e1 == 0), THEN UNDERFLOW
	LDMFD	sp!, {r2-r6, pc}	; ELSE IT IS ZERO SO RETURN INPUT #1

$1:	ORR	m1, m1, #0x80000000	; SET IMPLIED ONE IN MANTISSA

	CMP	e1, #0xFF		; IF e1 == 0xFF, THEN OVERFLOW
	
	BEQ	ovfl1			;

	MOV	m1, m1, LSR #2		; ADJUST THE MANTISSA
	CMP	r1, #0			; IF INPUT #2 IS NEGATIVE,
	RSBMI	m1, m1, #0		;  THEN NEGATE THE MANTISSA
	
	MOV	m0, r0, LSL #8		; PUT INPUT #1 MANTISSA IN m0
	MOV	e0, r0, LSL #1		; PUT INPUT #1 EXPONENT IN e0
	MOVS	e0, e0, LSR #24		;
	BNE	$2			;

	CMP	m0, #0			; IF DENORMALIZED NUMBER (m0 != 0 AND
	MOVNE	r0, #0			; e0 == 0), THEN UNDERFLOW
	MOVEQ	r0, r1			; ELSE IT IS ZERO SO RETURN INPUT #2
	LDMFD	sp!, {r2-r6, pc}	;

$2:	ORR	m0, m0, #0x80000000	; SET IMPLIED ONE IN MANTISSA

	CMP	e0, #0xFF		; IF e0 == 0xFF, THEN OVERFLOW
	BEQ	ovfl0			;

	MOV	m0, m0, LSR #2		; ADJUST THE MANTISSA
	CMP	r0, #0			; IF INPUT #1 IS NEGATIVE,
	RSBMI	m0, m0, #0		;  THEN NEGATE THE MANTISSA
	
	SUBS	shift, e0, e1		; GET THE SHIFT AMOUNT
	MOVMI	tmp, m0			; IF THE SHIFT AMOUNT IS NEGATIVE, THEN
	MOVMI	m0, m1			;  SWAP THE TWO MANTISSA SO THAT m0
	MOVMI	m1, tmp			;  CONTAINS THE LARGER VALUE,
	RSBMI	shift, shift, #0	;  AND NEGATE THE SHIFT AMOUNT,
	MOVMI	e0, e1			;  AND ENSURE THE LARGER EXP. IS IN e0

	CMP	shift, #30		; IF THE 2nd MANTISSA IS SIGNIFICANT,
	ADDMI	m0, m0, m1, ASR shift	; ADD IT TO THE FIRST MANTISSA
	CMP	m0, #0x0		;
	MOVEQ	r0, #0			; IF THE RESULT IS ZERO, 
	LDMEQFD	sp!, {r2-r6, pc}	;  THEN UNDERFLOW
	RSBMI	m0, m0, #0x0		; IF THE RESULT IS NEGATIVE, THEN
	MOVMI	tmp, #0x1		;  NEGATE THE RESULT AND
	MOVPL	tmp, #0x0		; NOTE THE SIGN

loop:	MOVS	m0, m0, LSL #1		; NORMALIZE THE RESULTING MANTISSA
	SUB	e0, e0, #1		; ADJUSTING THE EXPONENT AS NECESSARY
	BPL	loop			;

	ADDS	m0, m0, #0x80		; ROUND THE MANTISSA TO THE NEAREST
	ADDCS	e0, e0, #1		; ADJUST EXPONENT IF AN OVERFLOW OCCURS
	MOVCC	m0, m0, LSL #1		; REMOVE THE IMPLIED ONE

	ADDS	e0, e0, #2		; NORMALIZE THE EXPONENT
	MOVLE	r0, #0			; CHECK FOR UNDERFLOW
	LDMLEFD	sp!, {r2-r6, pc}	;
	CMP	e0, #0xFF		; CHECK FOR OVERFLOW
	BCS	ovfl			;

	MOV	r0, m0, LSR #9		; REPACK THE MANTISSA INTO r0
	ORR	r0, r0, e0, LSL #23	; REPACK THE EXPONENT INTO r0
	ORR	r0, r0, tmp, LSL #31	; REPACK THE SIGN INTO r0

	LDMFD	sp!, {r2-r6, pc}	;
	
ovfl1:	MOV	r0, r1			; OVERFLOW
ovfl0:  MOV	tmp, r0, LSR #31	;
ovfl:	MOV	tmp, tmp, LSL #31	; ISOLATE SIGN BIT
	MOV	r0, #0xFF		; SET UP Emax EXPONENT
	MOV	r0, r0, LSL #23
	ORR	r0, r0, tmp		; COMBINE SIGN AND EXPONENT
	LDMFD	sp!, {r2-r6, pc}	;

	.endasmfunc

	.end

fs_cmp16.asm/   1202506628  0     0     0       4359      `
;******************************************************************************
;* FS_CMP16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS$CMP - COMPARE TWO IEEE 754 FORMAT SINGLE PRECISION FLOATING POINT 
;*          NUMBERS, SETTING THE STATUS ON THE RESULT.
;*
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0
;*   o INPUT OP2 IS IN r1
;*   o INPUTS ARE NOT DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o +0 == -0
;*
;*   o IF COMPUTING THE RESULT INVOLVES INFINITIES, THE FOLLOWING TABLE
;*     SUMMARIZES THE EFFECTIVE RESULT
;*                   +----------+----------+----------+ 
;*                   + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   +INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |    -0    +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +    +0    +
;*        +----------+----------+----------+----------+
;*
;*   o THE RESULT OF THE COMPARE IS COMPUTED USING INTEGER SUBRACT IF THE
;*     SIGN OF THE INPUTS IS THE SAME.  THE TABLE SUMMARIZES THE 
;*     IMPLEMENTATION.
;*                 +-----------+-----------+ 
;*                 +   OP2 +   |   OP2 -   +
;*        +--------+===========+===========+ 
;*        + OP1 +  + OP1 - OP2 |    OP1    + 
;*        +--------+-----------+-----------+ 
;*        + OP1 -  +    OP1    | OP2 - OP1 + 
;*        +--------+-----------+-----------+ 
;*
;*   o THE FOLLOWING STATUS BITS ARE SET ON THE RESULT
;*     o Z=1,N=0,V=0  IFF 0
;*     o Z=0,N=1,V=0  IFF -
;*     o Z=0,N=0,V=0  IFF +
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global FS$CMP

tmp	.set	r2
tmp2	.set	r3

FS$CMP:	.asmfunc stack_usage(8)
	PUSH	{r2, r3}		;

	CMP	r0, r1			; HANDLE THE CASE OF BOTH INPUTS EQUAL 
	BEQ	exit			;

	MOV	tmp, r0			;
	ORR	tmp, r1			; HANDLE THE CASE OF BOTH INPUTS BEING
	LSL	tmp, tmp, #1		; ZERO
	CMP	tmp, #0x0		;
	BEQ	exit			;

	MOV	tmp, r0			; TEST OP1 == 0
	LSL	tmp, tmp, #1		; 
	BNE	$2			;

	CMP	tmp, r1			; OP1 == 0, DISREGARD SIGN OF OP1
	POP	{r2, r3}		; WHEN COMPUTING RESULT STATUS
	MOV	pc, lr			;

$2	LSL	tmp, r0, #1		;
	LSR	tmp, tmp, #24	 	; CHECK INPUT #1 FOR INFINITY
	CMP	tmp, #0xFF		;
	BNE	$1			;
	LSL	tmp, r1, #1		; CHECK INPUT #2 FOR INFINITY
	LSR	tmp, tmp, #24		;
	CMP	tmp, #0xFF		;
	BNE	$1			;

	LSR	tmp, r1, #31		; HANDLE THE CASE OF BOTH INPUTS
	LSR	tmp2, r0, #31		; BEING INFINITE
	SUB	tmp, tmp, tmp2		;
	POP	{r2, r3}		;
	MOV	pc, lr			;

$1:	CMP	r1, #0			; CHECK OP2'S SIGN
	BMI	op2_m			;

	CMP	r0, #0			; OP2 IS POSITIVE.
	BMI	exit			; IF OP1 IS POSITIVE,
	CMP	r0, r1 			;  THE RESULT IS OP1 - OP2, 
exit:	POP	{r2, r3}		;  ELSE OP1
	MOV	pc, lr			;

op2_m:	CMP	r0, #0			; OP2 IS NEGATIVE.
	BGT	exit			; IF OP1 IS NEGATIVE,
	CMP	r1, r0			;  THE RESULT IS OP2 - OP1,
	POP	{r2, r3}		;  ELSE OP1
	MOV	pc, lr			;

	.endasmfunc

	.end

fs_cmp32.asm/   1202506628  0     0     0       4280      `
;******************************************************************************
;* FS_CMP32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS_CMP32 - COMPARE TWO IEEE 754 FORMAT SINGLE PRECISION FLOATING POINT 
;*            NUMBERS, SETTING THE STATUS ON THE RESULT.
;*
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0
;*   o INPUT OP2 IS IN r1
;*   o INPUTS ARE NOT DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o +0 == -0
;*
;*   o IF COMPUTING THE RESULT INVOLVES INFINITIES, THE FOLLOWING TABLE
;*     SUMMARIZES THE EFFECTIVE RESULT
;*                   +----------+----------+----------+ 
;*                   + OP2 !INF | OP2 -INF + OP2 +INF +
;*        +----------+==========+==========+==========+ 
;*        + OP1 !INF +    -     |   +INF   +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 -INF +   -INF   |    -0    +   -INF   +
;*        +----------+----------+----------+----------+ 
;*        + OP1 +INF +   +INF   |   +INF   +    +0    +
;*        +----------+----------+----------+----------+
;*
;*   o THE RESULT OF THE COMPARE IS COMPUTED USING INTEGER SUBRACT IF THE
;*     SIGN OF THE INPUTS IS THE SAME.  THE TABLE SUMMARIZES THE 
;*     IMPLEMENTATION.
;*                 +-----------+-----------+ 
;*                 +   OP2 +   |   OP2 -   +
;*        +--------+===========+===========+ 
;*        + OP1 +  + OP1 - OP2 |    OP1    + 
;*        +--------+-----------+-----------+ 
;*        + OP1 -  +    OP1    | OP2 - OP1 + 
;*        +--------+-----------+-----------+ 
;*
;*   o THE FOLLOWING STATUS BITS ARE SET ON THE RESULT
;*     o Z=1,N=0,V=0  IFF 0
;*     o Z=0,N=1,V=0  IFF -
;*     o Z=0,N=0,V=0  IFF +
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global FS_CMP

tmp	.set	lr

FS_CMP:	.asmfunc stack_usage(4)
	STR	lr, [sp, #-4]!

	CMP	r0, r1			; HANDLE THE CASE OF BOTH INPUTS EQUAL 
	LDREQ	pc, [sp], #4		;

	ORR	tmp, r0, r1		; HANDLE THE CASE OF BOTH INPUTS BEING
	MOV	tmp, tmp, LSL #1	; ZERO
	CMP	tmp, #0x0		;
	LDREQ	pc, [sp], #4		;

	MOVS	tmp, r0, LSL #1		; TEST OP1 == 0
	BNE	_ct2_			; 

	CMP	tmp, r1			; OP1 == 0, DISREGARD SIGN OF OP1 
	LDR	pc, [sp], #4		; WHEN COMPUTING RESULT STATUS

_ct2_:	MOV	tmp, r0, LSL #1		;
	MOV	tmp, tmp, LSR #24 	; CHECK INPUT #1 FOR INFINITY
	CMP	tmp, #0xFF		;
	BNE	_ct1_			;
	MOV	tmp, r1, LSL #1		; CHECK INPUT #2 FOR INFINITY
	MOV	tmp, tmp, LSR #24	;
	CMP	tmp, #0xFF		;
	BNE	_ct1_			;

	MOV	tmp, r1, LSR #31	; HANDLE THE CASE OF BOTH INPUTS
	SUBS	tmp, tmp, r0, LSR #31	; BEING INFINITE
	LDR	pc, [sp], #4		;

_ct1_:	CMP	r1, #0			; CHECK OP2'S SIGN
	BMI	op2_m			;

	CMP	r0, #0			; OP2 IS POSITIVE.  IF OP1 IS POSITIVE,
	CMPGT	r0, r1 			; THE RESULT IS OP1 - OP2, ELSE OP1
	LDR	pc, [sp], #4		;

op2_m:	CMP	r0, #0			; OP2 IS NEGATIVE.  IF OP1 IS NEGATIVE,
	CMPMI	r1, r0			; THE RESULT IS OP2 - OP1, ELSE OP1
	LDR	pc, [sp], #4		;

	.endasmfunc

	.end
	

fs_div16.asm/   1202506628  0     0     0       4707      `
;******************************************************************************
;* FS_DIV16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS$DIV - DIVIDES TWO IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	    POINT NUMBERS.
;****************************************************************************
;*
;*   o DIVIDEND INPUT OP1 IS IN r0
;*   o DIVISOR INPUT OP2 IS IN r1
;*   o QUOTIENT IS RETURNED IN r0
;*   o INPUT OP2 IN r1 IS DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY (0x7f800000/ff800000)
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*   o DIVIDE BY ZERO RETURNS ZERO
;*
;*   o IF THE OPERATION INVOLVES INFINITY AS AN INPUT, UNLESS THE OTHER INPUT
;*     IS ZERO, THE RESULT IS INFINITY WITH THE SIGN DETERMINED IN THE USUAL
;*     FASHION.
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global FS$DIV


in1	.set	r0
in2	.set	r1

m1	.set	r2
e1	.set	r3
m2	.set	r4
e2	.set	r5
sign	.set	r6
tmp	.set	r7

FS$DIV:	.asmfunc stack_usage(24)
	PUSH	{r2-r7}			;

	MOV	tmp, #1			; SETUP 0x80000000 CONSTANT
	LSL	tmp, tmp, #31		;

	MOV	sign, in1		;
	EOR	sign, in2		; SET THE SIGN OF THE RESULT
	LSR	sign, sign, #31		;
	LSL	sign, sign, #31		;

	LSL	m1, in1, #8		; PUT INPUT #1 MANTISSA IN m1
	LSL	e1, in1, #1		; PUT INPUT #1 EXPONENT IN e1
	LSR	e1, e1, #24		;
	BEQ	unfl			; IF e1 == 0, THEN UNDERFLOW
	ORR	m1, tmp			; SET IMPLIED ONE IN MANTISSA IF e1 != 0

	CMP	e1, #0xFF		; IF e1 == 0xFF, THEN OVERFLOW
	BEQ	ovfl			;

	LSL	m2, in2, #8		; PUT INPUT #2 MANTISSA IN m2
	LSL	e2, in2, #1		; PUT INPUT #2 EXPONENT IN e2
	LSR	e2, e2, #24		;
	BEQ	unfl			; IF e2 == 0, THEN UNDERFLOW
	ORR	m2, tmp			; SET IMPLIED ONE IN MANTISSA IF e2 != 0

	CMP	e2, #0xFF		; IF e2 == 0xFF, THEN OVERFLOW
	BEQ	ovfl			;

	SUB	e1, e1, e2		; SUBTRACT EXPONENTS

	; DIVIDE THE MANTISAE:  m1 / m2 => in1
	MOV	in1, #0x0		; INITIALIZE THE QUOTIENT
  	MOV	in2, #32		; INITIALIZE THE SHIFT COUNTER (IN in2)
        LSR     m2, m2, #1	        ; SETUP THE DIVISOR
        LSR     m1, m1, #1      	; SETUP THE DIVIDEND
	
_fdiv_:	CMP	m1, m2			; IF DIVIDEND IS LARGER THAN DIVISOR,
	ADC	in1, in1		; SHIFT A 1 INTO THE QUOTIENT, ELSE 0
	CMP	m1, m2			;
	BCC	$1			;
	SUB	m1, m1, m2		; IF DIVIDEND LARGER, SUBTRACT DIVISOR
$1:	SUB	in2, #0x1		; UPDATE THE SHIFT COUNTER
	BEQ	_flb1_			; EXIT IF OUT OF SHIFTS
	CMP	m1, #0x0		; IF DIVIDEND NOT STILL THERE,
	BEQ	$2			;  EXIT
	LSL	m1, m1, #1		;  ELSE UPDATE DIVIDEND
	BNE	_fdiv_			;  AND CONTINUE

$2:	LSL	in1, in2		; ADJUST THE MANTISSA AS NECESSARY

_flb1_:	TST	in1, tmp		; ALIGN THE MANTISSA
	BNE	$3			;
	LSL	in1, in1, #1		;
	SUB	e1, #0x1		;

$3:	ADD	in1, #0x80		; 1/2 ADJUST FOR ROUNDING
	BCC	$4			;
	ADD	e1, #0x1		;
	B	_flb2_;
$4:	LSL	in1, in1, #1		;

_flb2_:	ADD	e1, #0x7F		; ADJUST FOR BIAS
	BLE	unfl			; AND CHECK FOR UNDERFLOW

	CMP	e1, #0xFF		; AND CHECK FOR EXPONENT OVERFLOW
	BCS	ovfl			;

	LSR	in1, in1, #0x9		; REPACK THE MANTISSA
	LSL	e1, e1, #23		;
	ORR	in1, e1			; REPACK THE EXPONENT INTO in1
	ORR	in1, sign		; REPACK THE SIGN INTO in1
		
	POP	{r2-r7}			;
	MOV	pc, lr			;

unfl:	MOV	in1, #0			; UNDERFLOW
	POP	{r2-r7}			;
	MOV	pc, lr			;

ovfl:	MOV	in1, #0xFF		; OVERFLOW
	LSL	in1, in1, #23		;
	ORR	in1, sign		;
	POP	{r2-r7}			;
	MOV	pc, lr			;

	.endasmfunc

	.end

fs_div32.asm/   1202506628  0     0     0       4706      `
;******************************************************************************
;* FS_DIV32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS_DIV - DIVIDES TWO IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	    POINT NUMBERS.
;****************************************************************************
;*
;*   o DIVIDEND INPUT OP1 IS IN r0
;*   o DIVISOR INPUT OP2 IS IN r1
;*   o QUOTIENT IS RETURNED IN r0
;*   o INPUT OP2 IN r1 IS DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY (0x7f800000/ff800000)
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*   o DIVIDE BY ZERO RETURNS ZERO
;*
;*   o IF THE OPERATION INVOLVES INFINITY AS AN INPUT, UNLESS THE OTHER INPUT
;*     IS ZERO, THE RESULT IS INFINITY WITH THE SIGN DETERMINED IN THE USUAL
;*     FASHION.
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global FS_DIV


in1	.set	r0
in2	.set	r1

m1	.set	r2
e1	.set	r3
m2	.set	r4
e2	.set	r5
sign	.set	r6
tmp	.set	lr

FS_DIV:	.asmfunc stack_usage(24)
	STMFD	sp!, {r2-r6, lr}

	EORS	sign, in1, in2		; SET THE SIGN OF THE RESULT
	MOVMI	sign, #0x80000000	;
	MOVPL	sign, #0x00000000	;

	MOV	m1, in1, LSL #8		; PUT INPUT #1 MANTISSA IN m1
	MOV	e1, in1, LSL #1		; PUT INPUT #1 EXPONENT IN e1
	MOVS	e1, e1, LSR #24		;
	ORRNE	m1, m1, #0x80000000	; SET IMPLIED ONE IN MANTISSA IF e1 != 0

	MOVEQ	in1, #0			; IF e1 == 0, THEN UNDERFLOW
	LDMEQFD	sp!, {r2-r6, pc}	;

	CMP	e1, #0xFF		; IF e1 == 0xFF, THEN OVERFLOW
	BEQ	ovfl			;

	MOV	m2, in2, LSL #8		; PUT INPUT #2 MANTISSA IN m2
	MOV	e2, in2, LSL #1		; PUT INPUT #2 EXPONENT IN e2
	MOVS	e2, e2, LSR #24		;
	ORRNE	m2, m2, #0x80000000	; SET IMPLIED ONE IN MANTISSA IF e2 != 0

	MOVEQ	in1, #0			; IF e2 == 0, THEN UNDERFLOW
	LDMEQFD	sp!, {r2-r6, pc}	;

	CMP	e2, #0xFF		; IF e2 == 0xFF, THEN OVERFLOW
	BEQ	ovfl			;

	SUB	e1, e1, e2		; SUBTRACT EXPONENTS

	; DIVIDE THE MANTISAE:  m1 / m2 => in1
	MOV	in1, #0x0		; INITIALIZE THE QUOTIENT
  	MOV	tmp, #32		; INITIALIZE THE SHIFT COUNTER
        MOV     m2, m2, LSR #1          ; SETUP THE DIVISOR
        MOV     m1, m1, LSR #1          ; SETUP THE DIVIDEND
	
_fdiv_:
	CMP	m1, m2			; IF DIVIDEND IS LARGER THAN DIVISOR,
	ADC	in1, in1, in1		; SHIFT A 1 INTO THE QUOTIENT, ELSE 0
	SUBCS	m1, m1, m2		; IF DIVIDEND LARGER, SUBTRACT DIVISOR
	SUBS	tmp, tmp, #0x1		; UPDATE THE SHIFT COUNTER
	BEQ	_flb1_			; EXIT IF OUT OF SHIFTS
	CMP	m1, #0x0		; IF DIVIDEND STILL THERE,
	MOVNE	m1, m1, LSL #1		;  UPDATE DIVIDEND
	BNE	_fdiv_			;  CONTINUE

	MOV	in1, in1, LSL tmp	; ADJUST THE MANTISSA AS NECESSARY

_flb1_:	TST	in1, #0x80000000	; ALIGN THE MANTISSA
	MOVEQ	in1, in1, LSL #1	;
	SUBEQ	e1, e1, #0x1		;

	ADDS	in1, in1, #0x00000080	; 1/2 ADJUST FOR ROUNDING
	ADDCS	e1, e1, #0x1		;
	MOVCC	in1, in1, LSL #1	;

_flb2_:	ADDS	e1, e1, #0x7F		; ADJUST FOR BIAS
	MOVLE	in1, #0			; AND CHECK FOR UNDERFLOW
	LDMLEFD	sp!, {r2-r6, pc}	;

	CMP	e1, #0x000000FF		; AND CHECK FOR EXPONENT OVERFLOW
	BCS	ovfl			;

	MOV	in1, in1, LSR #0x9	; REPACK THE MANTISSA
	ORR	in1, in1, e1, LSL #23	; REPACK THE EXPONENT INTO in1
	ORR	in1, in1, sign		; REPACK THE SIGN INTO in1
		
	LDMFD	sp!, {r2-r6, pc}	;

ovfl:	MOV	tmp, #0xFF		; OVERFLOW, RETURN +/- INFINITY
	MOV	tmp, tmp, LSL #23	;
	ORR	in1, sign, tmp		;
	LDMFD	sp!, {r2-r6, pc}	;

	.endasmfunc

	.end
fs_mul16.asm/   1202506628  0     0     0       4745      `
;******************************************************************************
;* FS_MUL16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS$MUL - MULTIPLY TWO IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	    POINT NUMBERS.
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0
;*   o INPUT OP2 IS IN r1
;*   o RESULT IS RETURNED IN r0
;*   o INPUT OP2 IN r1 IS NOT DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY (0x7f800000/ff800000)
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;*   o IF THE OPERATION INVOLVES INFINITY AS AN INPUT, UNLESS THE OTHER INPUT
;*     IS ZERO, THE RESULT IS INFINITY WITH THE SIGN DETERMINED IN THE USUAL
;*     FASHION.
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global FS$MUL


in1	.set	r0
in2	.set	r1

m1	.set	r2
e1	.set	r3
m2	.set	r4
e2	.set	r5
sign	.set	r6
tmp	.set	r7

FS$MUL:	.asmfunc stack_usage(24)
	PUSH	{r2-r7}			;

        MOV     tmp, #1                 ; SETUP 0x080000000 CONSTANT
        LSL     tmp, tmp, #31           ;
 
        MOV     sign, in1               ;
        EOR     sign, in2               ; SET THE SIGN OF THE RESULT
        BMI     $1			;
        MOV     sign, #0                ;
        B       $2			;
$1:	MOV     sign, tmp               ;
 
$2:	LSL     m1, in1, #8             ; PUT INPUT #1 MANTISSA IN m1
        LSL     e1, in1, #1             ; PUT INPUT #1 EXPONENT IN e1
        LSR     e1, e1, #24             ;
        BEQ     unfl			; IF e1 == 0, THEN UNDERFLOW
        ORR     m1, tmp                 ; SET IMPLIED ONE IN MANTISSA IF e1 != 0 
        CMP     e1, #0xFF               ; IF e1 == 0xFF, THEN OVERFLOW
        BEQ     ovfl			;

        LSL     m2, in2, #8             ; PUT INPUT #2 MANTISSA IN m2
        LSL     e2, in2, #1             ; PUT INPUT #2 EXPONENT IN e2
        LSR     e2, e2, #24             ;
        BEQ     unfl			; IF e2 == 0, THEN UNDERFLOW
        ORR     m2, tmp                 ; SET IMPLIED ONE IN MANTISSA IF e2 != 0 
        CMP     e2, #0xFF               ; IF e2 == 0xFF, THEN OVERFLOW
        BEQ     ovfl			;

	ADD	e1, e2			; ADD EXPONENTS

	BX	pc			; SWITCH TO 32 BIT STATE FOR THE
	NOP				; LONG MULTIPLY

	.state32
	UMULL	e2, m2, m1, m2		; MULTIPLY THE MANTISAE INTO m2:e2

	ADD	e2, pc, #1		; SWITCH BACK TO 16 BIT STATE
	BX	e2			;

	.state16
	CMP	m2, #0			;
	BMI	$3			;
	LSL	m2, m2, #1		; ADJUST THE EXPONENT AS NECESSARY
	SUB	e1, #0x1		; AND ADJUST FOR BIAS

$3:	ADD	m2, #0x80		; ADD 1/2 FOR ROUNDING
	BCC	$4			;
	ADD	e1, #0x1		; AND ADJUST FOR OVERFLOW
	LSR	m2, m2, #1		;

$4:	SUB	e1, #0x7E		; ADJUST THE BIAS
	BLE	unfl			; AND CHECK FOR UNDERFLOW

	CMP	e1, #0xFF		; CHECK FOR EXPONENT OVERFLOW
	BCS	ovfl			;

	BIC	m2, tmp			; REMOVE IMPLIED 1 IN MANTISSA
	LSR	in1, m2, #8		; SETUP THE MANTISSA
        LSL     e1, e1, #23             ;
	ORR	in1, e1			; REPACK THE EXPONENT INTO in1
	ORR	in1, sign		; REPACK THE SIGN INTO in1
		
        POP     {r2-r7}		     	;
	MOV	pc, lr			;

unfl:	MOV     in1, #0                 ; UNDERFLOW
        POP     {r2-r7}		     	;
	MOV	pc, lr			;
 
ovfl:	MOV	in1, #0xFF		; OVERFLOW
	LSL	in1, in1, #23		;
        ORR     in1, sign               ;
        POP     {r2-r7}		     	;
	MOV	pc, lr			;

	.endasmfunc

	.end


fs_mul32.asm/   1202506628  0     0     0       4094      `
;******************************************************************************
;* FS_MUL.ASM  - 32 BIT STATE -  v2.70                                        *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* F_MUL - MULTIPLY TWO IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	   POINT NUMBERS.
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0
;*   o INPUT OP2 IS IN r1
;*   o RESULT IS RETURNED IN r0
;*   o INPUT OP2 IN r1 IS NOT DESTROYED
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY (0x7f800000/ff800000)
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;*   o IF THE OPERATION INVOLVES INFINITY AS AN INPUT, UNLESS THE OTHER INPUT
;*     IS ZERO, THE RESULT IS INFINITY WITH THE SIGN DETERMINED IN THE USUAL
;*     FASHION.
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global FS_MUL


in1	.set	r0
in2	.set	r1

m1	.set	r2
e1	.set	r3
m2	.set	r4
e2	.set	r5
sign	.set	r6
tmp	.set	lr

FS_MUL:	.asmfunc stack_usage(24)
	STMFD	sp!, {r2-r6, lr}

	EORS	sign, in1, in2		; SET THE SIGN OF THE RESULT
	MOVMI	sign, #0x80000000	;
	MOVPL	sign, #0x00000000	;

	MOV	m1, in1, LSL #8		; PUT INPUT #1 MANTISSA IN m1
	MOV	e1, in1, LSL #1		; PUT INPUT #1 EXPONENT IN e1
	MOVS	e1, e1, LSR #24		;
	ORRNE	m1, m1, #0x80000000	; SET IMPLIED ONE IN MANTISSA IF e1 != 0

	MOVEQ	in1, #0			; IF e1 == 0, THEN UNDERFLOW
	LDMEQFD	sp!, {r2-r6, pc}	;

	CMP	e1, #0xFF		; IF e1 == 0xFF, THEN OVERFLOW
	BEQ	ovfl			;

	MOV	m2, in2, LSL #8		; PUT INPUT #2 MANTISSA IN m2
	MOV	e2, in2, LSL #1		; PUT INPUT #2 EXPONENT IN e2
	MOVS	e2, e2, LSR #24		;
	ORRNE	m2, m2, #0x80000000	; SET IMPLIED ONE IN MANTISSA IF e2 != 0

	MOVEQ	in1, #0			; IF e2 == 0, THEN UNDERFLOW
	LDMEQFD	sp!, {r2-r6, pc}	;

	CMP	e2, #0xFF		; IF e2 == 0xFF, THEN OVERFLOW
	BEQ	ovfl			;

	ADD	e1, e1, e2		; ADD EXPONENTS

	UMULL	e2, m2, m1, m2		; MULTIPLY THE MANTISAE INTO m2:e2

	CMP	m2, #0			;
	MOVPL	m2, m2, LSL #1		; ADJUST THE EXPONENT AS NECESSARY
	SUBPL	e1, e1, #0x1		; AND ADJUST FOR BIAS

	ADDS	m2, m2, #0x00000080	; ADD 1/2 FOR ROUNDING
	ADDCS	e1, e1, #0x1		; AND ADJUST FOR OVERFLOW
	MOVCS	m2, m2, LSR #1		;

	SUBS	e1, e1, #0x00000007E	; ADJUST THE BIAS
	MOVLE	in1, #0			; AND CHECK FOR UNDERFLOW
	LDMLEFD	sp!, {r2-r6, pc}	;

	CMP	e1, #0x000000FF		; CHECK FOR EXPONENT OVERFLOW
	BCS	ovfl			;

	MOV	in1, m2, LSR #8		; SETUP THE MANTISSA
	BIC	in1, in1, #0x00800000	; REMOVE IMPLIED 1 IN MANTISSA
	ORR	in1, in1, e1, LSL #23	; REPACK THE EXPONENT INTO in1
	ORR	in1, in1, sign		; REPACK THE SIGN INTO in1
		
	LDMFD	sp!, {r2-r6, pc}	;

ovfl:	MOV	tmp, #0xFF		; OVERFLOW, RETURN +/- INFINITY
	MOV	tmp, tmp, LSL #23	; 
	ORR	in1, sign, tmp		;
	LDMFD	sp!, {r2-r6, pc}	;

	.endasmfunc

	.end
fs_tod16.asm/   1202506628  0     0     0       5115      `
;******************************************************************************
;* FS_TOD16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS$TOFD - CONVERT AN IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	     POINT NUMBER TO 754 FORMAT DOUBLE PRECISION FLOATING 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0:r1
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY 
;*       (0x7ff00000:00000000) or (0xfff00000:00000000) 
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |   32-bit representation                                      |
;* |   31 30    23 22                    0                        |
;* |   +-+--------+-----------------------+                       |
;* |   |S|    E   |           M           +                       |
;* |   +-+--------+-----------------------+                       |
;* |                                                              |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE             |
;* |                               1 - NEGATIVE VALUE             |
;* |                                                              |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0            |
;* |                         01...FE - EXPONENT VALUE (127 BIAS)  |
;* |                              FF - INFINITY                   |
;* |                                                              |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global	FS$TOFD

e0	.set	r3

FS$TOFD: .asmfunc stack_usage(4)
	PUSH	{r3}			; SAVE CONTEXT

	LSL	e0, r0, #1		; SETUP EXPONENT IN e0
	LSR	e0, e0, #24		;
	BEQ	unfl			; CHECK FOR UNDERFLOW / ZERO

	CMP	e0, #0xFF		; CHECK FOR INFINITY
	BEQ	ovfl			; AND RETURN OVERFLOW

	MOV	r1, #0x7		; SETUP #0x380 CONSTANT
	LSL	r1, r1, #7		;
	ADD	e0, e0, r1		; ADJUST FOR THE BIAS

	LSR	r1, r0, #31		; ENCODE SIGN WITH EXPONENT
	LSL	r1, r1, #11		;
	ORR	e0, r1			;

	LSL	r1, r0, #29		; SETUP LOW PART OF MANTISSA
	LSL	r0, r0, #9		; AND SETUP HIGH PART OF MANTISSA
	LSR	r0, r0, #12		;
	LSL	e0, e0, #20		;
	ORR	r0, e0			; OR SIGN AND EXPONENT INTO RESULT
	POP	{r3}			;
	MOV	pc, lr			;
	
unfl:	MOV	r0, #0x0		; IF UNDERFLOW, RETURN 0
	MOV	r1, #0x0		;
	POP	{r3}			;
	MOV	pc, lr			;

ovfl:	MOV	r1, #0			; IF OVERFLOW, RETURN +/- INFINITY
        LSR	r0, r0, #23		; ISOLATE EXP AND SIGN
	LSL	r0, r0, #3		; FILL IN REST OF Emax
	ADD	r0, r0, #7		;
        LSL	r0, r0, #20		; SHIFT EXP AND SIGN INTO PLACE
	POP	{r3}			;
	MOV	pc, lr			;

	.endasmfunc

	.end

fs_tod32.asm/   1202506628  0     0     0       4980      `
;******************************************************************************
;* FS_TOD32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS_TOFD - CONVERT AN IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	     POINT NUMBER TO 754 FORMAT DOUBLE PRECISION FLOATING 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0:r1
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS +/- INFINITY 
;*       (0x7ff00000:00000000) or (0xfff00000:00000000) 
;*   o DENORMALIZED NUMBERS ARE TREATED AS UNDERFLOWS
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |   32-bit representation                                      |
;* |   31 30    23 22                    0                        |
;* |   +-+--------+-----------------------+                       |
;* |   |S|    E   |           M           +                       |
;* |   +-+--------+-----------------------+                       |
;* |                                                              |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE             |
;* |                               1 - NEGATIVE VALUE             |
;* |                                                              |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0            |
;* |                         01...FE - EXPONENT VALUE (127 BIAS)  |
;* |                              FF - INFINITY                   |
;* |                                                              |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global	FS_TOFD

e0	.set	lr

FS_TOFD: .asmfunc stack_usage(4)
	STMFD	sp!, {lr}		; SAVE CONTEXT

	MOVS	e0, r0, LSL #1		; SETUP EXPONENT IN e0
	MOVS	e0, e0, LSR #24		;
	BEQ	unfl			; CHECK FOR UNDERFLOW / ZERO

	CMP	e0, #0xFF		; CHECK FOR INFINITY
	BEQ	ovfl			; AND RETURN OVERFLOW

	ADD	e0, e0, #0x380		; ADJUST FOR THE BIAS

	MOV	r1, r0, LSR #31		; ENCODE SIGN WITH EXPONENT
	ORR	e0, e0, r1, LSL #11	;

	MOV	r1, r0, LSL #29		; SETUP LOW PART OF MANTISSA
	MOV	r0, r0, LSL #9		; AND SETUP HIGH PART OF MANTISSA
	MOV	r0, r0, LSR #12		;
	ORR	r0, r0, e0, LSL #20	; OR SIGN AND EXPONENT INTO RESULT
	LDMFD	sp!, {pc}		;
	
unfl:	MOV	r0, #0x0		; IF UNDERFLOW, RETURN 0
	MOV	r1, #0x0		;
	LDMFD	sp!, {pc}		;

ovfl:	MOV	r1, #0			; IF OVERFLOW, RETURN +/- INFINITY
	MOV	r0, r0, LSR #23		; ISOLATE SIGN AND EXPONENT
	MOV	r0, r0, LSL #3
	ADD	r0, r0, #7
	MOV	r0, r0, LSL #20
	LDMFD	sp!, {pc}		;

	.endasmfunc

	.end
fs_toi16.asm/   1202506628  0     0     0       2884      `
;******************************************************************************
;* FS_TOI.ASM  - 16 BIT STATE -  v2.70                                        *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS$TOI - CONVERT AN IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	    POINT NUMBER TO A 32 BIT SIGNED INTEGER
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0x7FFFFFFF/80000000, DEPENDING ON THE SIGN OF THE
;*     INPUT
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global FS$TOI


e0	.set	r1
tmp	.set	r2
sign	.set	lr

FS$TOI:	.asmfunc stack_usage(12)
	PUSH	{r1, r2, lr}		;

	LSL	e0, r0, #1		; PUT EXPONENT IN e0
	LSR	e0, e0, #24		;

	SUB	e0, #0x7F		; CHECK FOR UNDERFLOW
	BMI	unfl			; IF UNDERFLOW, RETURN ZERO

	MOV	tmp, #0x1F		;
	SUB	e0, tmp, e0		;
	BLS	ovfl			; CHECK FOR OVERFLOW

	MOV	sign, r0		; SAVE SIGN
	LSL	r0, r0, #8		; PUT MANTISSA IN r0
	MOV	tmp, #1			;
	LSL	tmp, tmp, #31		;
	ORR	r0, tmp			; SET IMPLIED ONE IN MANTISSA

	LSR	r0, e0			; COMPUTE THE INTEGER VALUE

	MOV	tmp, sign		;
	CMP	tmp, #0			;
	BPL	$1			; IF THE INPUT IS NEGATIVE,
	NEG	r0, r0			;  THEN NEGATE THE RESULT AND RETURN
$1:	POP 	{r1, r2, pc}		;

unfl:	MOV	r0, #0			; UNDERFLOW
	POP 	{r1, r2, pc}		;

ovfl:   MOV	tmp, r0			; OVERFLOW
	MOV	r0, #0x1		;
	LSL	r0, r0, #31		;
	CMP	tmp, #0			; IF INPUT IS NEGATIVE, RETURN
	BMI	$2			; 0x80000000
	SUB	r0, r0, #1
$2:	POP 	{r1, r2, pc}		;

	.endasmfunc

	.end
fs_toi32.asm/   1202506628  0     0     0       2892      `
;******************************************************************************
;* FS_TOI32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS_TOI - CONVERT AN IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;*          POINT NUMBER TO A 32 BIT SIGNED INTEGER
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0x7FFFFFFF/80000000, DEPENDING ON THE SIGN OF THE
;*     INPUT
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global FS_TOI


m0	.set	r1
e0	.set	lr

FS_TOI:	.asmfunc stack_usage(8)
	STMFD	sp!, {m0, lr}

	MOV	e0, r0, LSL #1		; PUT EXPONENT IN e0
	MOV	e0, e0, LSR #24		;

	SUBS	e0, e0, #0x7F		; CHECK FOR UNDERFLOW
	MOVMI	r0, #0			; IF UNDERFLOW, RETURN ZERO
	LDMMIFD sp!, {m0, pc}		;

	RSBS	e0, e0, #0x1F		; CHECK FOR OVERFLOW
	BLS	ovfl			; IF OVERFLOW, RETURN INFINITY

	MOV	m0, r0, LSL #8		; PUT MANTISSA IN m0
	ORR	m0, m0, #0x80000000	; SET IMPLIED ONE IN MANTISSA

	MOV	m0, m0, LSR e0		; COMPUTE THE INTEGER VALUE << 1
 
        CMP     r0, #0                  ; IF THE INPUT IS NEGATIVE,
        RSBMI   r0, m0, #0              ;  THEN NEGATE THE RESULT
        MOVPL   r0, m0                  ;

	LDMFD 	sp!, {m0, pc}		;

ovfl:	CMP	r0, #0			; IF OVERFLOW, RETURN INFINITY
	MOV	r0, #0x80000000		; CHECK THE SIGN OF THE INPUT
	SUBPL	r0, r0, #0x1		; AND ADJUST THE VALUE OF INFINITY
	LDMFD	sp!, {m0, pc}		; ACCORDINGLY

	.endasmfunc

	.end
fs_toll16.asm/  1202506628  0     0     0       4169      `
;******************************************************************************
;* FS_TOLL.ASM  - 16 BIT STATE -  v2.70                                       *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS$TOLL - CONVERT AN IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	     POINT NUMBER TO A 64 BIT SIGNED INTEGER
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0x7FFFFFFF:FFFFFFFF/80000000:00000000, DEPENDING ON 
;*     THE SIGN OF THE INPUT
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global FS$TOLL

	.if .TMS470_LITTLE

o_hi	.set r1
o_lo	.set r0

	.else

o_hi	.set r0
o_lo	.set r1

	.endif

e0	.set	r2
tmp	.set	r3
sign	.set	lr

FS$TOLL: .asmfunc stack_usage(12)
        PUSH	{r2, r3, lr}		;

	LSL	e0, r0, #1		; PUT EXPONENT IN e0
	LSR	e0, e0, #24		;

	SUB	e0, #0x7F		; CHECK FOR UNDERFLOW
	BMI	unfl			; IF UNDERFLOW, RETURN ZERO

	MOV	tmp, #0x3F		;
	SUB	e0, tmp, e0		;
	BLS	ovfl			; CHECK FOR OVERFLOW

	MOV	sign, r0		; SAVE SIGN
	LSL	r0, r0, #8		; PUT MANTISSA IN r0
	MOV	tmp, #1			;
	LSL	tmp, tmp, #31		;
	ORR	r0, tmp			; SET IMPLIED ONE IN MANTISSA

        MOV     tmp, e0                 ; COMPUTE THE INTEGER VALUE BY RIGHT 
        SUB     tmp, #32                ; SHIFTING THE MANTISSA BY THE e0
        BCC     $1                      ; 
        MOV     r1, r0                  ; IF e0 >= 32
        MOV     r0, #0                  ;    r0:r1 = 0:((r0 >> (e0 - 32))
	LSR	r1, tmp		        ; 
	B       adj_sign                ;
$1:
        MOV     r1, r0                  ; IF e0 < 32
        LSR     r0, e0                  ;    r0:r1 = (r0:0) >> e0
        NEG     tmp, tmp                ;
        LSL     r1, tmp                 ;

adj_sign:
	MOV	tmp, sign		;
	CMP	tmp, #0			;
	BPL	$2			; IF THE INPUT IS NEGATIVE,
        MOV     tmp, #0                 ;
	NEG	r1, r1			;  THEN NEGATE THE RESULT AND RETURN
        SBC     tmp, r0                 ;
        MOV     r0, tmp                 ;

$2:	
	; IN LITTLE ENDIAN MODE THE OUTPUT LONG LONG VALUE SHOULD BE IN R1:R0.
	; SO SWAP THE REGISTER VALUES BEFORE RETURN.

	.if .TMS470_LITTLE
	MOV	lr, r0			;
	MOV	r0, r1			;
	MOV	r1, lr			;
	.endif

	POP 	{r2, r3, pc}		;

unfl:	MOV	r0, #0			; UNDERFLOW
        MOV     r1, #0                  ;
	POP 	{r2, r3, pc}		;

ovfl:   MOV	tmp, r0			; OVERFLOW
	MOV	o_lo, #0		;
	MOV	o_hi, #0x1		;
	LSL	o_hi, o_hi, #31		;
	CMP	tmp, #0			; IF INPUT IS NEGATIVE, RETURN
	BMI	$3			; 0x80000000:00000000
        MOV     tmp, #0                 ;
	SUB	o_lo, o_lo, #1          ; ELSE RETURN 0x7FFFFFFF:FFFFFFFF
        SBC     o_hi, tmp               ;
$3:	POP 	{r2, r3, pc}		;

	.endasmfunc
	.end

fs_toll32.asm/  1202506628  0     0     0       3927      `
;******************************************************************************
;* FS_TOLL32.ASM  - 32 BIT STATE -  v2.70                                     *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS_TOLL - CONVERT AN IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;*           POINT NUMBER TO A 64 BIT SIGNED INTEGER
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0x7FFFFFFF:FFFFFFFF/80000000:00000000, DEPENDING ON 
;*     THE SIGN OF THE INPUT
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global FS_TOLL

	.if .TMS470_LITTLE

o_hi	.set r1
o_lo	.set r0

	.else

o_hi	.set r0
o_lo	.set r1

	.endif

sign	.set	r2
tmp     .set    r3
e0	.set	lr

FS_TOLL: .asmfunc stack_usage(12)
        STMFD	sp!, {r2, r3, lr}

	MOV	e0, r0, LSL #1		; PUT EXPONENT IN e0
	MOV	e0, e0, LSR #24		;

	SUBS	e0, e0, #0x7F		; CHECK FOR UNDERFLOW
	MOVMI	r0, #0			; IF UNDERFLOW, RETURN ZERO
	MOVMI	r1, #0			; 
	LDMMIFD sp!, {r2, r3, pc}	;

	RSBS	e0, e0, #0x3F		; CHECK FOR OVERFLOW
	BLS	ovfl			; IF OVERFLOW, RETURN INFINITY

	MOV	sign, r0		; SAVE THE SIGN
	MOV	r0, r0, LSL #8		; PUT MANTISSA IN m0
	ORR	r0, r0, #0x80000000	; SET IMPLIED ONE IN MANTISSA

	MOV	r1, #0			;
        ; COMPUTE THE INTEGER VALUE
        CMP     e0, #0x20               ; IF e0 GREATER OR EQUAL TO 32, PERFORM
        MOVCS   r1, r0                  ; RIGHT SHIFT IN TWO STEPS.
        MOVCS   r0, #0                  ;    r0:r1 >>= 32 
        SUBCS   e0, e0, #0x20           ;    and 
        MOV     r1, r1, LSR e0          ;    r0:r1 >>= e0 - 32
        RSBCC   tmp, e0, #0x20          ;
        ORRCC   r1, r1, r0, LSL tmp     ;
        MOVCC   r0, r0, LSR e0          ; 

        CMP     sign, #0                ; IF THE INPUT IS NEGATIVE,
	BPL	return			;

        RSBS    r1, r1, #0              ;  THEN NEGATE THE RESULT
        RSC     r0, r0, #0              ;

return:
	; IN LITTLE ENDIAN MODE THE OUTPUT LONG LONG VALUE SHOULD BE IN R1:R0.
	; SO SWAP THE REGISTER VALUES BEFORE RETURN.

	.if .TMS470_LITTLE
	MOV	lr, r0			;
	MOV	r0, r1			;
	MOV	r1, lr			;
	.endif

	LDMFD 	sp!, {r2, r3, pc}	;

ovfl:	CMP	r0, #0			; IF OVERFLOW, RETURN INFINITY
	MOV	o_hi, #0x80000000	; CHECK THE SIGN OF THE INPUT
        MOV     o_lo, #0                ;
	LDMMIFD sp!, {r2, r3, pc}	;
	SUBS 	o_lo, o_lo, #0x1	; AND ADJUST INFINITY ACCORDINGLY
	SBC  	o_hi, o_hi, #0  	; 
	LDMFD   sp!, {r2, r3, pc}	;

	.endasmfunc
	.end

fs_tou16.asm/   1202506628  0     0     0       3081      `
;******************************************************************************
;* FS_TOU16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS$TOU - CONVERT AN IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	    POINT NUMBER TO A 32 BIT UNSIGNED INTEGER
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0xFFFFFFFF
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o NEGATIVE VALUE RETURNS ZERO
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global FS$TOU, FS$TOI

e0      .set    r1
tmp     .set    r2

FS$TOU: .asmfunc stack_usage(8)
	PUSH	{r1, r2, lr}		; SAVE CONTEXT

	CMP	r0, #0			; CHECK FOR A NEGATIVE VALUE
        BPL     pos
        BL      FS$TOI                  ; CAST TO INT
        POP     {r1, r2, pc}

pos:    LSL     e0, r0, #1              ; PUT EXPONENT IN e0
        LSR     e0, e0, #24             ;
 
        SUB     e0, #0x7F               ; CHECK FOR UNDERFLOW
        BCC     unfl 	                ; IF UNDERFLOW, RETURN ZERO
 
        MOV     tmp, #0x1F              ;
        SUB     e0, tmp, e0             ;
        BCC     ovfl    	        ; CHECK FOR OVERFLOW
 
	LSL     r0, r0, #8              ; PUT MANTISSA IN r0
        MOV     tmp, #1                 ;
        LSL     tmp, tmp, #31           ;
        ORR     r0, tmp                 ; SET IMPLIED ONE IN MANTISSA
 
	LSR	r0, e0			; COMPUTE THE INTEGER VALUE
	POP	{r1, r2, pc}		;

unfl:   MOV     r0, #0                  ; UNDERFLOW
        POP     {r1, r2, pc}		;
 
ovfl:	MOV	r0, #0x0		; IF OVERFLOW, RETURN INFINITY
	SUB	r0, r0, #0x1		;
        POP     {r1, r2, pc}		;

	.endasmfunc

	.end

fs_tou32.asm/   1202506628  0     0     0       2738      `
;******************************************************************************
;* FS_TOU32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS_TOU - CONVERT AN IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	    POINT NUMBER TO A 32 BIT UNSIGNED INTEGER
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0xFFFFFFFF
;*   o UNDERFLOW RETURNS ZERO (0x00000000)
;*   o NEGATIVE VALUE RETURNS ZERO
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global FS_TOU, FS_TOI

e0	.set	lr


FS_TOU:	STMFD   sp!, {lr}               ; SAVE CONTEXT
	CMP	r0, #0			; CHECK FOR A NEGATIVE VALUE
	BPL     pos
        BL      FS_TOI                  ; CAST TO INT
        LDMFD   sp!, {pc}               ;

pos:	MOV	e0, r0, LSL #1		; PUT EXPONENT IN e0
	MOV	e0, e0, LSR #24		;

	SUBS	e0, e0, #0x7F		; CHECK FOR UNDERFLOW
	MOVCC	r0, #0			; IF UNDERFLOW, RETURN ZERO
	LDMCCFD sp!, {pc}		;

	RSBS	e0, e0, #0x1F		; CHECK FOR OVERFLOW
	BCC	ovfl			; IF OVERFLOW, RETURN 0xFFFFFFFF

	MOV	r0, r0, LSL #8		; PUT MANTISSA IN r0
	ORR	r0, r0, #0x80000000	; SET IMPLIED ONE IN MANTISSA

        MOV     r0, r0, LSR e0          ; COMPUTE THE INTEGER VALUE

	LDMFD	sp!, {pc}		;

ovfl:	MOV	r0, #0x0		; IF OVERFLOW, RETURN 0xFFFFFFFF
	SUB	r0, r0, #0x1		;
	LDMFD	sp!, {pc}		;

	.end
fs_toull16.asm/ 1202506628  0     0     0       3824      `
;******************************************************************************
;* FS_TOULL16.ASM  - 16 BIT STATE -  v2.70                                    *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS$TOULL - CONVERT AN IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	      POINT NUMBER TO A 64 BIT UNSIGNED INTEGER
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0xFFFFFFFF:FFFFFFFF
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o NEGATIVE VALUE RETURNS ZERO
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global FS$TOULL, FS$TOLL

e0      .set    r2
tmp     .set    r3

FS$TOULL: .asmfunc stack_usage(12)
	PUSH	{r2-r3, lr}		; SAVE CONTEXT

	CMP	r0, #0			; CHECK FOR A NEGATIVE VALUE
        BPL     pos
        BL      FS$TOLL                 ; CAST TO INT
        POP     {r2, r3, pc}

pos:    LSL     e0, r0, #1              ; PUT EXPONENT IN e0
        LSR     e0, e0, #24             ;
 
        SUB     e0, #0x7F               ; CHECK FOR UNDERFLOW
        BCC     unfl 	                ; IF UNDERFLOW, RETURN ZERO
 
        MOV     tmp, #0x3F              ;
        SUB     e0, tmp, e0             ;
        BCC     ovfl    	        ; CHECK FOR OVERFLOW
 
	LSL     r0, r0, #8              ; PUT MANTISSA IN r0
        MOV     tmp, #1                 ;
        LSL     tmp, tmp, #31           ;
        ORR     r0, tmp                 ; SET IMPLIED ONE IN MANTISSA
 
        MOV     tmp, e0                 ;
        SUB     tmp, #32                ;
        BCC     $1                      ;
        MOV     r1, r0                  ;
        MOV     r0, #0                  ;
	LSR	r1, tmp		        ; COMPUTE THE INTEGER VALUE
	B	return
$1:
        MOV     r1, r0                  ;
        LSR     r0, e0                  ;
        NEG     tmp, tmp                ;
        LSL     r1, tmp                 ;
return:
	; IN LITTLE ENDIAN MODE THE OUTPUT LONG LONG VALUE SHOULD BE IN R1:R0.
	; SO SWAP THE REGISTER VALUES BEFORE RETURN.

	.if .TMS470_LITTLE
	MOV	lr, r0			;
	MOV	r0, r1			;
	MOV	r1, lr			;
	.endif

	POP	{r2-r3, pc}		;

unfl:   MOV     r0, #0                  ; UNDERFLOW
        MOV     r1, #0
        POP     {r2-r3, pc}		;
 
ovfl:	MOV	r0, #0x0		; IF OVERFLOW, RETURN INFINITY
	SUB	r0, r0, #0x1		;
        MOV     r1, r0                  ; 
        POP     {r2-r3, pc}		;

	.endasmfunc
	.end
fs_toull32.asm/ 1202506628  0     0     0       3519      `
;******************************************************************************
;* FS_TOULL32.ASM  - 32 BIT STATE -  v2.70                                    *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* FS_TOULL - CONVERT AN IEEE 754 FORMAT SINGLE PRECISION FLOATING 
;* 	      POINT NUMBER TO A 64 BIT UNSIGNED INTEGER
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*
;*   o SIGNALLING NOT-A-NUMBER (SNaN) AND QUIET NOT-A-NUMBER (QNaN)
;*     ARE TREATED AS INFINITY
;*   o OVERFLOW RETURNS 0xFFFFFFFF:FFFFFFFF
;*   o UNDERFLOW RETURNS ZERO (0x00000000:00000000)
;*   o NEGATIVE VALUE RETURNS ZERO
;*   o ROUNDING MODE:  ROUND TO ZERO
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global FS_TOULL, FS_TOLL

tmp     .set    r2
e0	.set	lr

FS_TOULL: .asmfunc stack_usage(8)
	STMFD	sp!, {r2, lr}		; SAVE CONTEXT
        CMP	r0, #0			; CHECK FOR A NEGATIVE VALUE
	BPL     pos
        BL      FS_TOLL                 ; CAST TO INT
	LDMFD	sp!, {r2, pc}

pos:	MOV	e0, r0, LSL #1		; PUT EXPONENT IN e0
	MOV	e0, e0, LSR #24		;

	SUBS	e0, e0, #0x7F		; CHECK FOR UNDERFLOW
	MOVCC	r0, #0			; IF UNDERFLOW, RETURN ZERO
	LDMCCFD sp!, {r2, pc}		;

	RSBS	e0, e0, #0x3F		; CHECK FOR OVERFLOW
	BCC	ovfl			; IF OVERFLOW, RETURN 0xFFFFFFFF

	MOV	r0, r0, LSL #8		; PUT MANTISSA IN r0
	ORR	r0, r0, #0x80000000	; SET IMPLIED ONE IN MANTISSA

        ; COMPUTE THE INTEGER VALUE
        CMP     e0, #0x20               ; IF e0 GREATER OR EQUAL TO 32, PERFORM
        MOVCS   r1, r0                  ; RIGHT SHIFT IN TWO STEPS.
        MOVCS   r0, #0                  ;    r0:r1 >>= 32 
        SUBCS   e0, e0, #0x20           ;    and 
        MOV     r1, r1, LSR e0          ;    r0:r1 >>= e0 - 32
        RSBCC   tmp, e0, #0x20          ;
        ORRCC   r1, r1, r0, LSL tmp     ;
        MOVCC   r0, r0, LSR e0          ; 

	; IN LITTLE ENDIAN MODE THE OUTPUT LONG LONG VALUE SHOULD BE IN R1:R0.
	; SO SWAP THE REGISTER VALUES BEFORE RETURN.

	.if .TMS470_LITTLE
	MOV	lr, r0			;
	MOV	r0, r1			;
	MOV	r1, lr			;
	.endif

	LDMFD	sp!, {r2, pc}		;

ovfl:	MOV	r0, #0x0		; IF OVERFLOW, RETURN 
	SUB	r0, r0, #0x1		; 0xFFFFFFFF:FFFFFFFF
        MOV     r1, r0                  ;
	LDMFD	sp!, {r2, pc}		;

	.endasmfunc
	.end

fscanf.c/       1202506628  0     0     0       5661      `
/*****************************************************************************/
/*  FSCANF.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSCANF      -  Read formatted input from a stream                      */
/*    SCANF       -  Read formatted input from stdin                         */
/*    _INPCHAR    -  Get a character from the stream                         */
/*    _UNINPCHAR  -  Put a character back onto the stream                    */
/*    _CHKMBC     -  Check that the characters match the input               */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

static int _inpchar(void **inp);
static void _uninpchar(void **inp, int outchar);
static int _chkmbc(void **inp, char **_format, int *num_read);

/*****************************************************************************/
/* FSCANF   -  Read formatted input from a stream                            */
/*                                                                           */
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */ 
/*****************************************************************************/
_CODE_ACCESS int fscanf(FILE *_fp, const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if (_fp->fd == -1) return (EOF);

   return (_scanfi((void *)_fp, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
   
}

/*****************************************************************************/
/* SCANF -  Read formatted input from stdin                                  */
/*                                                                           */ 
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */ 
/*****************************************************************************/ 
int scanf(const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if (stdin->fd == -1) return (EOF);

   return (_scanfi((void *)stdin, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
 
}

/*****************************************************************************/
/* _INPCHAR -  Get a character from the stream                               */
/*****************************************************************************/
static int _inpchar(void **inp) { return (fgetc((FILE *)(*inp))); }

/*****************************************************************************/
/* _UNINPCHAR  -  Put a character back onto the stream                       */
/*****************************************************************************/
static void _uninpchar(void **inp, int outchar)
{ 
   ungetc(outchar, (FILE *)*inp);
}

/*****************************************************************************/
/* _CHKMBC  -  Check that the characters match the input                     */
/*                                                                           */
/*    Check that all characters in the format string that are not part of a  */
/*    conversion specification match the input, until the next '%' or the    */
/*    end of the format string is reached.  The function returns an EOF if   */
/*    the end of the file is reached prematurely, a 0 upon reaching the end  */
/*    of the format string, or a 1 if a '%' is encountered.                  */
/*                                                                           */
/*****************************************************************************/
static int _chkmbc(void **inp, char **_format, int *num_read)
{
   FILE        *_fp = (FILE *)*inp;
   signed char  c;

   /*------------------------------------------------------------------------*/
   /* If there is a white space character in the format statement, skip to   */
   /* the next non-white space character in the input.                       */
   /*------------------------------------------------------------------------*/
   while (isspace(**_format))
   {
      for(c = fgetc(_fp);isspace(c);c = fgetc(_fp)) (*num_read)++;
      ungetc(c, _fp);
      (*_format)++;
   }

   for(;(**_format != '%') && (**_format != '\0');)
      if (*((*_format)++) != (c = fgetc(_fp))) 
      {
         ungetc(c, _fp);
         return ((c == EOF) ? EOF : 0);
      }
      else (*num_read)++;

   if (**_format == '%') return 1;
   else return (0);
}


fseek.c/        1202506628  0     0     0       2342      `
/*****************************************************************************/
/*  FSEEK.C v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSEEK -  Reposition the file pointer of a stream                       */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"

extern int _doflush(FILE *_fp);




/*****************************************************************************/ 
/* FSEEK -  Reposition the file pointer of a stream                          */
/*                                                                           */ 
/*    This funtion flushes stream _FP, clears the EOF and I/O Error flags,   */
/*    repositions the file pointer of the stream.  It returns a 0 upon       */
/*    success, and an EOF upon failure.                                      */
/*                                                                           */ 
/*****************************************************************************/ 
_CODE_ACCESS int fseek(register FILE *_fp, long _offset, int _ptrname)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* When positioning to a location relative to the current location,       */
   /* adjust for the fact that there may be something in the buffer.         */
   /*------------------------------------------------------------------------*/
   if(_ptrname == SEEK_CUR && _STCHK(_fp, _MODER) && _fp->buff_stop)
      _offset -= (_fp->buff_stop - _fp->pos);

   _doflush(_fp);

   _UNSET(_fp, (_STATEOF | _UNGETC));
   
   if((lseek(_fp->fd, _offset, _ptrname)) == -1) return (EOF);
   
   return (0);
}
   
fsetpos.c/      1202506628  0     0     0       1044      `
/*****************************************************************************/
/*  FSETPOS.C v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FSETPOS  -  Position the file indicator for stream _FP                 */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"


/*****************************************************************************/
/* FSETPOS  -  Position the file indicator for stream _FP                    */
/*****************************************************************************/
_CODE_ACCESS int fsetpos(FILE *_fp, const fpos_t *_pos)
{
   return (fseek(_fp, *_pos, SEEK_SET));
}

ftell.c/        1202506628  0     0     0       3089      `
/*****************************************************************************/
/*  FTELL.C v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <errno.h>
#include <stdio.h>
#include "file.h"

/*****************************************************************************/
/* FTELL -  Get the location of the file pointer in a stream                 */
/*                                                                           */
/*    This function gets the current location of the file pointer for the    */
/*    given stream, and returns it after adjusting it for any inaccuracies   */
/*    that buffering might have caused.                                      */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS long ftell(FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   fpos_t  _pos;
   int   adjust   = 0;

   /*------------------------------------------------------------------------*/
   /* If the stream pointer given is not currently open, return a -1.        */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) { errno = 5; return (-1L);}

   /*------------------------------------------------------------------------*/
   /* For files in read mode, we must subtract the unread data in the buffer */
   /* from the location of the file pointer.  For files in write mode, we    */
   /* must add the data in the buffer that has not yet gone to disk.         */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODER) && _fp->buff_stop > _fp->pos)
      adjust = -(_fp->buff_stop - _fp->pos);
   if(_STCHK(_fp, _MODEW)) adjust = (_fp->pos - _fp->buf); 
 
   /*------------------------------------------------------------------------*/
   /* Get the file pointer's position                                        */
   /*------------------------------------------------------------------------*/
   _pos = lseek(_fp->fd, 0L, SEEK_CUR);

   /*------------------------------------------------------------------------*/
   /* If the call to lseek was unsuccessful, return an -1                    */
   /*------------------------------------------------------------------------*/
   if(_pos < 0) { errno = 5; return (-1L);}

   /*------------------------------------------------------------------------*/
   /* Make the necessary adjustment, and return the value                    */
   /*------------------------------------------------------------------------*/
   _pos += adjust;
   return (_pos);
}


fwrite.c/       1202506628  0     0     0       7512      `
/*****************************************************************************/
/*  FWRITE.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    FWRITE   -  Write a block of bytes to a stream                         */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <stdlib.h>
#include <string.h>
 
extern int _doflush(FILE *_fp);
extern int _wrt_ok(FILE *_fp);

 
/*****************************************************************************/
/* FWRITE   -  Write a block of bytes to a stream                            */
/*                                                                           */
/*    This function reads _COUNT blocks of size _SIZE from a buffer          */
/*    pointed to by _PTR, and writes them to stream _FP.  It returns the     */
/*    number of blocks successfully written.                                 */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS size_t fwrite(const void *_ptr, size_t _size, size_t _count,
                           register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   unsigned char    *fpos       = (unsigned char *)_ptr;
   unsigned char    *nl_pos;
            size_t   buffer_size = (_fp->bufend - _fp->buf),
                     next_nl,
                     room_left;
            size_t   num_left    = _size * _count,
                     num_to_write,
                     num_written  = 0;

   /*------------------------------------------------------------------------*/
   /* Make sure that the stream is writeable.                                */
   /*------------------------------------------------------------------------*/
   if(! _wrt_ok(_fp) || _size == 0 || _count == 0) return (0);
 
   /*------------------------------------------------------------------------*/
   /* If the stream is non-buffered, call the lowlevel WRITE function.       */
   /*------------------------------------------------------------------------*/
   if(_BUFFMODE(_fp) == _IONBF) 
   {
       int num_written = 0;

       while (num_left > 0)
       {
	   int write_return = write(_fp->fd, 
				    (char *)fpos + num_written, num_left);
	   if (write_return <= 0) 
	   { 
	       _SET(_fp, _STATERR); 
	       return (num_written / _size);
	   }
	   else
	   {
	       num_written += write_return;
	       num_left    -= write_return;
	   }
       }

       return (num_written / _size);
   }
 
   room_left   = (_fp->bufend - _fp->pos);
   if (_STCHK(_fp, _IOLBF))
       next_nl = (char *)memchr(fpos, '\n', num_left) - (char *)fpos + 1;
 
   while (num_left > 0)
   {
      /*---------------------------------------------------------------------*/
      /* Determine how many characters should be written based on buffering  */
      /* mode.  For non-buffered streams, call the lowlevel WRITE function.  */
      /* For fully buffered streams, put as many characters in the buffer as */
      /* possible.  For line buffered streams, put characters into the       */
      /* util the buffer is full, the last character is reached, or a        */
      /* newline character is reached.                                       */
      /*---------------------------------------------------------------------*/
      switch (_BUFFMODE(_fp))
      {
         case _IOFBF : num_to_write = (room_left > num_left) ? 
                       num_left : room_left;
                       break;
 
         case _IOLBF : num_to_write = (room_left > next_nl) ? next_nl :
                       (room_left > num_left) ? num_left : room_left;
                       break;
 
         default     : return (0);
      }
 
      /*---------------------------------------------------------------------*/
      /* Write the data to the buffer, and update the buffer pointer and the */
      /* ROOM_LEFT coutner.                                                  */
      /*---------------------------------------------------------------------*/
      memcpy(_fp->pos, fpos, num_to_write);
      _fp->pos += num_to_write;
      room_left = (_fp->bufend - _fp->pos);

      /*---------------------------------------------------------------------*/
      /* If the buffer is full, or a newline character has been encountered  */
      /* on a line-buffered stream, flush it.                                */
      /*---------------------------------------------------------------------*/
      if (room_left == 0 || (_STCHK(_fp, _IOLBF) && num_to_write == next_nl))
      {
         if(_doflush(_fp))
         {
            _SET(_fp, _STATERR); 
            return (num_written / _size);
         }
         room_left = buffer_size;

         /*------------------------------------------------------------------*/
         /* The _DOFLUSH function clears the write flag on streams opened in */
         /* update mode.  Make sure that the write flag is still set here.   */
         /*------------------------------------------------------------------*/
         _SET(_fp, _MODEW);
      }

      /*---------------------------------------------------------------------*/
      /* Update pointers and counters.                                       */
      /*---------------------------------------------------------------------*/
      num_written += num_to_write;
      fpos += num_to_write;
      num_left -= num_to_write;
 
      /*---------------------------------------------------------------------*/
      /* For line-buffered streams, find the next occurance of a newline     */
      /* character.  If there are no more, and the remaining data will fit   */
      /* in the buffer, exit the loop where the remaining data will be moved */
      /* there.  Otherwise loop until this condition is true.                */
      /*---------------------------------------------------------------------*/
      if (_STCHK(_fp, _IOLBF))
      {
         nl_pos = (unsigned char *)memchr((fpos + 1), '\n', 
					  (num_left > 0) ? (num_left-1) : 0);
         if (! nl_pos)
         {
            if (num_left < room_left) break;
            else next_nl = buffer_size + 1;
         }
         else next_nl = (nl_pos - fpos) + 1;
      }
   }

   /*------------------------------------------------------------------------*/
   /* Copy the rest of the characters into the buffer for line-buffered      */
   /* streams.                                                               */
   /*------------------------------------------------------------------------*/
   if (_STCHK(_fp, _IOLBF))
   {
      memcpy(_fp->pos, fpos, num_left);
      num_written += num_left;
      _fp->pos += num_left;
   }
 
   return (num_written / _size);
}
 
gmtime.c/       1202506629  0     0     0       600       `
/****************************************************************************/
/*  gmtime v2.70                                                            */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>

_CODE_ACCESS struct tm *gmtime(const time_t *timer)
{
    time_t gtime = _tz.timezone; /* DIFFERENCE BETWEEN CURRENT TIME ZONE    */
				 /* AND GMT IN SECONDS                      */

    if (timer) gtime += *timer;
    return (localtime(&gtime));
}
i_div16.asm/    1202506629  0     0     0       3492      `
;******************************************************************************
;* I_DIV16.ASM  - 16 BIT STATE -  V1.16                                       *
;* Copyright (c) 1995-1997 Texas Instruments Incorporated                     *
;******************************************************************************

	.if $$isdefed("__small_divide__")
;****************************************************************************
;* I$DIV/I$MOD - DIVIDE TWO SIGNED 32 BIT NUMBERS.
;*
;****************************************************************************
;*
;*   o DIVIDEND IS IN r0
;*   o DIVISOR IS IN r1
;*
;*   o QUOTIENT IS PLACED IN r1
;*   o REMAINDER IS PLACED IN r0
;*
;*   o DIVIDE BY ZERO RETURNS ZERO
;*   o SIGN OF REMAINDER IS THE SIGN OF THE DIVIDEND
;*
;****************************************************************************
	.state16

	.global I$DIV
	.global I$MOD
	
dvs     .set    r2              ; WORK COPY OF THE DIVISOR (SHIFTED)
quo     .set    r3              ; WORK COPY OF THE QUOTIENT
negs    .set    r4              ; SAVED COPY OF THE SIGNS

I$DIV:	.asmfunc stack_usage(16)
I$MOD:
        PUSH    {r2-r4, lr}             ; SAVE CONTEXT

        CMP     r1, #0                  ; CHECK FOR DIVISION BY ZERO
        BEQ     _div_by_zero_           ;

        LSR     negs, r1, #1            ; MOVE THE SIGN OF THE DIVISOR TO negs
        CMP     r1, #0                  ;
        BPL     _ct1_                   ;
        NEG     r1, r1                  ; ABSOLUTE SIGN OF THE DIVISOR
_ct1_:  ASR     dvs, r0, #1             ;
        EOR     negs, dvs               ; MOVE THE SIGN OF THE DIVIDEND TO negs
        CMP     r0, #0                  ;
        BPL     _ct2_                   ;
        NEG     r0, r0                  ; ABSOLUTE SIGN OF THE DIVIDEND

_ct2_:  MOV     quo, #0                 ; INITIALIZE THE QUOTIENT
        MOV     dvs, r1                 ; INITIALIZE THE DIVISOR (SHIFTED)

_sdvs_loop_:
        CMP     r0, dvs                 ; 
        BLS     _sdiv_                  ;
        LSL     dvs, dvs, #1            ; CALCULATE THE MAXIMUM DIVISOR
        B       _sdvs_loop_             ; SHIFT AMOUNT

_sdiv_:
        CMP     r0, dvs                 ; IF DIVIDEND IS LARGER THAN DIVISOR,
        ADC     quo, quo                ;  SHIFT A 1 INTO THE QUOTIENT, ELSE 0
        CMP     r0, dvs                 ; IF DIVIDEND IS LARGER THAN DIVISOR,
        BCC     _cc1_                   ;  SUBTRACT THE DIVISOR,
        SUB     r0, r0, dvs             ; 
_cc1_:  CMP     r1, dvs                 ; IF THERE IS SHIFTED DIVISOR, THEN
        BCS     _cc2_                   ;
        LSR     dvs, dvs, #1            ; CONTINUE THE LOOP.
        B       _sdiv_                  ; 
_cc2_:  MOV     r1, quo                 ; ELSE DONE. PLACE THE QUOTIENT
                                        ; IT ITS RIGHT PLACE.
        CMP     negs, #0                ;
        BPL     _ct3_                   ;
        NEG     r0, r0                  ; SET THE SIGN OF THE REMAINDER AND
_ct3_:  LSL     negs, negs, #1          ;
        BPL     _ct4_                   ;
        NEG     r1, r1                  ; SET THE SIGN OF THE QUOTIENT.
_ct4_:  POP     {r2-r4, pc}             ;

_div_by_zero_:
        MOV     r0, #0                  ; DIVIDE BY ZERO RETURNS ZERO
        POP     {r2-r4, pc}             ;

	.endasmfunc

	.endif

        .end
i_div32.asm/    1202506629  0     0     0       3764      `
;******************************************************************************
;* I_DIV32.ASM  - 32 BIT STATE -  v2.70                                       *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* I_DIV/I_MOD - DIVIDE TWO SIGNED 32 BIT NUMBERS.
;* I$DIV/I$MOD - 16 BIT STATE INTERFACE TO I_DIV/I_MOD.
;*  
;****************************************************************************
;*
;*   o DIVIDEND IS IN r0
;*   o DIVISOR IS IN r1
;*
;*   o QUOTIENT IS PLACED IN r1
;*   o REMAINDER IS PLACED IN r0
;*
;*   o DIVIDE BY ZERO RETURNS ZERO
;*   o SIGN OF REMAINDER IS THE SIGN OF THE DIVIDEND
;*
;****************************************************************************
	.global I_DIV
	.global I_MOD

dvs	.set	r2		; WORK COPY OF THE DIVISOR (SHIFTED)
quo	.set	r3		; WORK COPY OF THE QUOTIENT
negs	.set	lr		; SAVED COPY OF THE SIGNS

	.if !$$isdefed("__small_divide__")
	.global I$DIV
	.global I$MOD

	.align
	.state16
I$DIV:	.asmfunc 
I$MOD:	BX	pc			; CHANGE TO 32-BIT STATE
	NOP
	.endasmfunc
	.endif
	
	.state32
I_DIV:	.asmfunc stack_usage(12)
I_MOD:	STMFD	sp!, {dvs, quo, lr}	; SAVE CONTEXT
	
	MOV	negs, r1, LSR #1	; MOVE THE SIGN OF THE DIVISOR TO negs
	EORS	negs, negs, r0, ASR #1	; MOVE THE SIGN OF THE DIVIDEND TO negs
	RSBMI	r0, r0, #0		; ABSOLUTE SIGN OF THE DIVIDEND

	ANDS	quo, r1, #0x80000000	; INITIALIZE THE QUOTIENT
	RSBNE	r1, r1, #0		; ABSOLUTE SIGN OF THE DIVISOR
	MOVS	dvs, r1			; CHECK FOR DIVISION BY ZERO, AND
	BEQ	div_by_zero		; INITIALIZE THE DIVISOR (SHIFTED)

	CMP	dvs, r0,  LSR #16	; CALCULATE THE MAXIMUM DIVISOR
	MOVLS	dvs, dvs, LSL #16	; SHIFT AMOUNT WITH PSEUDO BINARY
	CMP	dvs, r0,  LSR #8	; SEARCH.
	MOVLS	dvs, dvs, LSL #8	;

	CMP	dvs, r0, LSR #1		; NOW FIND EXACTLY WHERE THE SHIFTED
	BHI	mod1			; DIVISOR SHOULD BE SO THAT WE CAN
	CMP	dvs, r0, LSR #2		; JUMP INTO THE CORRECT LOCATION
	BHI	mod2			; OF THE UNROLLED DIVIDE LOOP.
	CMP	dvs, r0, LSR #3		;
	BHI	mod3			;
	CMP	dvs, r0, LSR #4		;
	BHI	mod4			;
	CMP	dvs, r0, LSR #5		;
	BHI	mod5			;
	CMP	dvs, r0, LSR #6		;
	BHI	mod6			;
	CMP	dvs, r0, LSR #7		;
	BHI	mod7			;

divl:					; DIVIDE LOOP UNROLLED 8 TIMES
	CMP	r0, dvs, LSL #7		; IF DIVIDEND IS LARGER THAN DIVISOR,
	ADC	quo, quo, quo		; SHIFT A 1 INTO THE QUOTIENT AND 
	SUBCS	r0, r0, dvs, LSL #7	; SUBTRACT THE DIVISOR, ELSE SHIFT A 0.
	CMP	r0, dvs, LSL #6		;

mod7:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #6	;
	CMP	r0, dvs, LSL #5		;

mod6:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #5	;
	CMP	r0, dvs, LSL #4		;

mod5:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #4	;
	CMP	r0, dvs, LSL #3		;

mod4:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #3	;
	CMP	r0, dvs, LSL #2		;

mod3:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #2	;
	CMP	r0, dvs, LSL #1		;

mod2:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #1	;

mod1:	CMP	r0, dvs			;
	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs		;

	CMP	r1, dvs			; IF THERE IS SHIFTED DIVISOR, THEN
	MOVCC	dvs, dvs, LSR #8	; CONTINUE THE LOOP.
	BCC	divl			;

	MOV	r1, quo			; ELSE DONE. PLACE THE QUOTIENT
	MOVS	negs, negs, LSL #1	; IT ITS RIGHT PLACE, AND
	RSBMI	r1, quo, #0		; SET THE SIGN OF THE QUOTIENT AND
	RSBCS	r0, r0, #0		; REMAINDER.
	.if !$$isdefed("__small_divide__")
	LDMFD	sp!, {dvs, quo, lr}
	BX	lr
	.else
	LDMFD	sp!, {dvs, pc}
	.endif

div_by_zero:
	MOV	r0, #0			; DIVIDE BY ZERO RETURNS ZERO
	.if !$$isdefed("__small_divide__")
	LDMFD	sp!, {dvs, quo, lr}
	BX	lr
	.else
	LDMFD	sp!, {dvs, pc}
	.endif

	.endasmfunc

	.end

i_tofd16.asm/   1202506629  0     0     0       3218      `
;******************************************************************************
;* I_TOFD16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* I$TOFD - CONVERT AN SIGNED 32 BIT INTEGER INTO AN IEEE 754 FORMAT
;*          DOUBLE PRECISION FLOATING POINT                 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0:r1
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global I$TOFD

e0	.set	r2

I$TOFD:	.asmfunc stack_usage(4)
	PUSH	{r2}			; SAVE CONTEXT

	MOV	e0, #0x4		; PRESETUP FOR EXPONENT FIELD

	CMP	r0, #0			; IF ZERO, RETURN ZERO
	BNE	$1			;
	MOV	r1, #0			;
	POP	{r2}			;
	MOV	pc, lr			;

$1:	BPL	$2			; IF NEGATIVE, ENCODE SIGN IN THE
	ADD	e0, #0x8		; EXPONENT FIELD
	NEG	r0, r0			;

$2:	LSL	e0, e0, #8		; SETUP REMAINDER OF THE EXPONENT FIELD
	ADD	e0, #0x1F		;

loop:	SUB	e0, e0, #0x1		; NORMALIZE THE MANTISSA
	LSL	r0, r0, #1		; ADJUSTING THE EXPONENT, ACCORDINGLY
	BCC	loop			;

done:	LSL	r1, r0, #20		; SETUP LOW HALF OF RESULT
	LSR	r0, r0, #12		; SETUP HIGH HALF OF RESULT
	LSL	e0, e0, #20		;
	ORR	r0, e0			;

	POP	{r2}			;
	MOV	pc, lr			;

	.endasmfunc

	.end
i_tofd32.asm/   1202506629  0     0     0       3092      `
;******************************************************************************
;* I_TOFD32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* I_TOFD - CONVERT AN SIGNED 32 BIT INTEGER INTO AN IEEE 754 FORMAT
;*          DOUBLE PRECISION FLOATING POINT                 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0:r1
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global	I_TOFD

I_TOFD:	.asmfunc
	CMP	r0, #0			; IF ZERO, RETURN ZERO
	MOVEQ	r1, #0			;
	MOVEQ	pc, lr			;

	RSBMI	r1, r0, #0		; MOVE INPUT AND IF NEGATIVE,
	MOVPL	r1, r0			; NEGATE IT

	MOV	r0, #0x1F		; SETUP THE EXPONENT
	ORRMI	r0, r0, #0x00000C00	; AND ENCODE SIGN INTO IT
	ORRPL	r0, r0, #0x00000400	;

loop:	MOVS	r1, r1, LSL #1		; NORMALIZE THE MANTISSA
	SUB	r0, r0, #0x1		; ADJUSTING THE EXPONENT, ACCORDINGLY
	BCC	loop			;

	MOV	r0, r0, LSL #20		; SETUP HIGH HALF OF RESULT
	ORR	r0, r0, r1, LSR #12	;
	MOV	r1, r1, LSL #20		; SETUP LOW HALF OF RESULT

	MOV	pc, lr			;

	.endasmfunc

	.end
i_tofs16.asm/   1202506629  0     0     0       2671      `
;******************************************************************************
;* I_TOFS16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* I$TOFS - CONVERT A 32 BIT SIGNED INTEGER TO AN IEEE 754 FORMAT 
;*          SINGLE PRECISION FLOATING POINT NUMBER
;****************************************************************************
;*
;*   o INPUT OP IS IN R0
;*   o RESULT IS RETURNED IN R0
;*
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global I$TOFS


m0	.set	r1
e0	.set	r2

I$TOFS:	.asmfunc stack_usage(8)
	PUSH	{r1, r2}		; SAVE CONTEXT

	MOV	e0, #0x9E		; SET THE EXPONENT FIELD

	CMP	r0, #0			; IF ZERO, RETURN ZERO
	BMI	$1			;
	BNE	$2			;
	POP	{r1, r2}		;
	MOV	pc, lr			; 

$1:	NEG	m0, r0			; IF NEGATIVE, NEGATE IT
	BMI	cont			;
	B	loop			;
$2:	MOV	m0, r0			;

loop:	SUB	e0, #1			; NORMALIZE THE MANTISSA
	LSL	m0, m0, #1		; ADJUSTING THE EXPONENT, ACCORDINGLY
	BPL	loop			;

cont:	ADD	m0, #0x80		; ADD 1/2 TO ROUND
	BCC	$3			;
	ADD	e0, #0x1		; AND ADJUST THE EXPONENT ACCORDINGLY
	B	$4			;

$3:	LSL	m0, m0, #1		; MASK IMPLIED 1 OUT OF THE MANTISSA

$4:	LSR	m0, m0, #9		; PACK THE MANTISSA
	LSL	e0, e0, #23		;
	ORR	m0, e0			; PACK THE EXPONENT
	CMP	r0, #0			; IF THE INPUT WAS NEGATIVE
	BPL	$5			;
	MOV	e0, #1			;
	LSL	e0, e0, #31		;
	ORR	m0, e0			;  THEN SET THE SIGN FIELD
$5:	MOV	r0, m0			;
	POP 	{r1, r2}		; RESTORE CONTEXT
	MOV	pc, lr			;

	.endasmfunc

	.end

i_tofs32.asm/   1202506629  0     0     0       2566      `
;******************************************************************************
;* I_TOFS32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* I_TOFS - CONVERT A 32 BIT SIGNED INTEGER TO AN IEEE 754 FORMAT
;*          SINGLE PRECISION FLOATING POINT NUMBER
;****************************************************************************
;*
;*   o INPUT OP IS IN R0
;*   o RESULT IS RETURNED IN R0
;*
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global I_TOFS


m0	.set	r1
e0	.set	lr

I_TOFS:	.asmfunc stack_usage(8)
	CMP	r0, #0			; 
	MOVEQ	pc, lr			; IF ZERO, RETURN ZERO

	STMFD	sp!, {m0, lr}		; SAVE CONTEXT

	MOVPL	m0, r0			;
	RSBMIS	m0, r0, #0		; IF NEGATIVE, NEGATE IT

	MOV	e0, #0x9E		; SET THE EXPONENT FIELD

	BMI	$1			;		
loop:	MOVS	m0, m0, LSL #1		; NORMALIZE THE MANTISSA
	SUB	e0, e0, #1		; ADJUSTING THE EXPONENT, ACCORDINGLY
	BPL	loop			;

$1:	ADDS	m0, m0, #0x00000080	; ADD 1/2 TO ROUND
	ADDCS	e0, e0, #0x1		; AND ADJUST THE EXPONENT ACCORDINGLY

	MOVCC	m0, m0, LSL #1		; MASK IMPLIED 1 OUT OF THE MANTISSA
	MOV	m0, m0, LSR #9		; PACK THE MANTISSA
	ORR	m0, m0, e0, LSL #23	; PACK THE EXPONENT
	CMP	r0, #0			; IF THE INPUT WAS NEGATIVE
	ORRMI	r0, m0, #0x80000000	;  THEN SET THE SIGN FIELD
	MOVPL	r0, m0			;

	LDMFD 	sp!, {m0, pc}		; RESTORE CONTEXT

	.endasmfunc

	.end
icall16.asm/    1202506629  0     0     0       1182      `
;******************************************************************************
;* ICALL16.ASM  - 16 BIT STATE -  v2.70                                       *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* IND$CALL - PERFORM INDIRECT CALL, SUPPORTING DUAL STATE INTERWORKING
;*
;****************************************************************************
;*
;*   o ADDRESS OF CALLED FUNCTION IS IN r4
;*   o r4 GETS DESTROYED
;*
;****************************************************************************
	.state16

	.global IND$CALL

IND$CALL: .asmfunc
	MOV	ip, r4			; SAVE OFF DESTINATION ADDRESS
	LSR	r4, r4, #1		; TEST STATE OF DESTINATION
	BCC	ep_32                   ;
	BX	ip                      ; INDIRECT CALL TO 16BIS ENTRY POINT
	NOP				;

ep_32:	MOV	r4, lr			; STORE RETURN ADDRESS IN r4
	MOV	lr, pc			; SETUP NEW RETURN ADDRESS
	BX	ip			; INDIRECT CALL TO 32BIS ENTRY POINT
	.state32
	BX	r4			; RETURN
	.state16

	.endasmfunc

	.end

icall32.asm/    1202506629  0     0     0       1186      `
;******************************************************************************
;* ICALL32.ASM  - 32 BIT STATE -  v2.70                                       *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* IND_CALL - PERFORM INDIRECT CALL, SUPPORTING DUAL STATE INTERWORKING
;*
;****************************************************************************
;*
;*   o ADDRESS OF CALLED FUNCTION IS IN r4
;*   o r4 GETS DESTROYED
;*
;****************************************************************************
	.state32

	.global IND_CALL

IND_CALL: .asmfunc
	TST	r4, #1			; TEST STATE OF DESTINATION
	BNE	ep_16	                ;
	BX	r4                      ; INDIRECT CALL TO 32BIS ENTRY POINT

ep_16:	MOV	ip, r4			; FREE r4 BY STORING ITS VALUE IN ip
	MOV	r4, lr			; STORE RETURN ADDRESS IN r4
	ADD	lr, pc, #1		; SETUP NEW RETURN ADDRESS
	BX	ip			; INDIRECT CALL TO 16BIS ENTRY POINT
	.state16
	BX	r4			; RETURN
	NOP				;
	.state32

	.endasmfunc

	.end

inttypes.h/     1202506629  0     0     0       5645      `
/*****************************************************************************/
/* INTTYPES.H v2.70                                                          */
/* Copyright (c) 2002-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _INTTYPES_H_
#define _INTTYPES_H_

#include <stdint.h>

/* 7.8 Format conversion of integer types */

typedef struct { intmax_t quot, rem; } imaxdiv_t;

/* 
   According to footnotes in the 1999 C standard, "C++ implementations
   should define these macros only when __STDC_FORMAT_MACROS is defined
   before <inttypes.h> is included." 
*/
#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS)

/* 7.8.1 Macros for format specifiers */

#define PRId8 		"d"
#define PRIi8 		"i"
#define PRIo8 		"o"
#define PRIu8 		"u"
#define PRIx8 		"x"
#define PRIX8 		"X"
#define SCNd8 		"hhd"
#define SCNi8 		"hhi"
#define SCNo8 		"hho"
#define SCNu8 		"hhu"
#define SCNx8 		"hhx"
#define SCNX8 		"hhX"

#define PRIdLEAST8     	"d"
#define PRIiLEAST8     	"i"
#define PRIoLEAST8     	"o"
#define PRIuLEAST8     	"u"
#define PRIxLEAST8     	"x"
#define PRIXFAST8     	"X"
#define PRIdFAST8     	"d"
#define PRIiFAST8     	"i"
#define PRIoFAST8     	"o"
#define PRIuFAST8     	"u"
#define PRIxFAST8     	"x"
#define PRIXFAST8     	"X"
#define PRId16		"d"
#define PRIi16		"i"
#define PRIo16		"o"
#define PRIu16		"u"
#define PRIx16		"x"
#define PRIX16		"X"
#define PRIdLEAST16    	"d"
#define PRIiLEAST16    	"i"
#define PRIoLEAST16    	"o"
#define PRIuLEAST16    	"u"
#define PRIxLEAST16    	"x"
#define PRIXFAST16    	"X"
#define PRIdFAST16    	"d"
#define PRIiFAST16    	"i"
#define PRIoFAST16    	"o"
#define PRIuFAST16    	"u"
#define PRIxFAST16    	"x"
#define PRIXFAST16    	"X"

#define SCNdLEAST8 	"hhd"
#define SCNiLEAST8 	"hhi"
#define SCNoLEAST8 	"hho"
#define SCNuLEAST8 	"hhu"
#define SCNxLEAST8 	"hhx"
#define SCNXLEAST8 	"hhX"
#define SCNdFAST8 	"d"
#define SCNiFAST8 	"i"
#define SCNoFAST8 	"o"
#define SCNuFAST8 	"u"
#define SCNxFAST8 	"x"
#define SCNXFAST8 	"X"
#define SCNdLEAST16 	"hd"
#define SCNiLEAST16 	"hi"
#define SCNoLEAST16 	"ho"
#define SCNuLEAST16 	"hu"
#define SCNxLEAST16 	"hx"
#define SCNXLEAST16 	"hX"
#define SCNdFAST16 	"d"
#define SCNiFAST16 	"i"
#define SCNoFAST16 	"o"
#define SCNuFAST16 	"u"
#define SCNxFAST16 	"x"
#define SCNXFAST16 	"X"

#define PRId32		"d"
#define PRIi32		"i"
#define PRIo32		"o"
#define PRIu32		"u"
#define PRIx32		"x"
#define PRIX32		"X"
#define PRIdLEAST32    	"d"
#define PRIiLEAST32    	"i"
#define PRIoLEAST32    	"o"
#define PRIuLEAST32    	"u"
#define PRIxLEAST32    	"x"
#define PRIXFAST32    	"X"
#define PRIdFAST32    	"d"
#define PRIiFAST32    	"i"
#define PRIoFAST32    	"o"
#define PRIuFAST32    	"u"
#define PRIxFAST32    	"x"
#define PRIXFAST32    	"X"
#define SCNd32		"d"
#define SCNi32		"i"
#define SCNo32		"o"
#define SCNu32		"u"
#define SCNx32		"x"
#define SCNX32		"X"
#define SCNdLEAST32    	"d"
#define SCNiLEAST32    	"i"
#define SCNoLEAST32    	"o"
#define SCNuLEAST32    	"u"
#define SCNxLEAST32    	"x"
#define SCNXFAST32    	"X"
#define SCNdFAST32    	"d"
#define SCNiFAST32    	"i"
#define SCNoFAST32    	"o"
#define SCNuFAST32    	"u"
#define SCNxFAST32    	"x"
#define SCNXFAST32    	"X"


#define PRId64		"lld"
#define PRIi64		"lli"
#define PRIo64		"llo"
#define PRIu64		"llu"
#define PRIx64		"llx"
#define PRIX64		"llX"
#define PRIdLEAST64    	"lld"
#define PRIiLEAST64    	"lli"
#define PRIoLEAST64    	"llo"
#define PRIuLEAST64    	"llu"
#define PRIxLEAST64    	"llx"
#define PRIXFAST64    	"llX"
#define PRIdFAST64    	"lld"
#define PRIiFAST64    	"lli"
#define PRIoFAST64    	"llo"
#define PRIuFAST64    	"llu"
#define PRIxFAST64    	"llx"
#define PRIXFAST64    	"llX"
#define SCNd64		"lld"
#define SCNi64		"lli"
#define SCNo64		"llo"
#define SCNu64		"llu"
#define SCNx64		"llx"
#define SCNX64		"llX"
#define SCNdLEAST64    	"lld"
#define SCNiLEAST64    	"lli"
#define SCNoLEAST64    	"llo"
#define SCNuLEAST64    	"llu"
#define SCNxLEAST64    	"llx"
#define SCNXFAST64    	"llX"
#define SCNdFAST64    	"lld"
#define SCNiFAST64    	"lli"
#define SCNoFAST64    	"llo"
#define SCNuFAST64    	"llu"
#define SCNxFAST64    	"llx"
#define SCNXFAST64    	"llX"

#define PRIdPTR		"d"
#define PRIiPTR		"i"
#define PRIoPTR		"o"
#define PRIuPTR		"u"
#define PRIxPTR		"x"
#define PRIXPTR		"X"
#define SCNdPTR		"d"
#define SCNiPTR		"i"
#define SCNoPTR		"o"
#define SCNuPTR		"u"
#define SCNxPTR		"x"
#define SCNXPTR		"X"

#define PRIdMAX		"lld"
#define PRIiMAX		"lli"
#define PRIoMAX		"llo"
#define PRIuMAX		"llu"
#define PRIxMAX		"llx"
#define PRIXMAX		"llX"
#define SCNdMAX		"lld"
#define SCNiMAX		"lli"
#define SCNoMAX		"llo"
#define SCNuMAX		"llu"
#define SCNxMAX		"llx"
#define SCNXMAX		"llX"

#endif /* !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) */

/* 7.8.2 Functions for greatest-width integer types */

intmax_t  imaxabs(intmax_t j);
imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
intmax_t  strtoimax(const char * restrict nptr, 
		    char ** restrict endptr, int base);
uintmax_t strtoumax(const char * restrict nptr, 
		    char ** restrict endptr, int base);
intmax_t  wcstoimax(const unsigned short * restrict nptr, 
		    unsigned short ** restrict endptr, int base);
uintmax_t wcstoumax(const unsigned short * restrict nptr, 
		    unsigned short ** restrict endptr, int base);

#endif /* _INTTYPES_H_ */

isalnum.c/      1202506629  0     0     0       426       `
/****************************************************************************/
/*  isalnum v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isalnum(int c)
{
    return(_isalnum(c));
}

isalpha.c/      1202506629  0     0     0       426       `
/****************************************************************************/
/*  isalpha v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isalpha(int c)
{
    return(_isalpha(c));
}

isascii.c/      1202506629  0     0     0       426       `
/****************************************************************************/
/*  isascii v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isascii(int c)
{
    return(_isascii(c));
}

iscntrl.c/      1202506629  0     0     0       426       `
/****************************************************************************/
/*  iscntrl v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int iscntrl(int c)
{
    return(_iscntrl(c));
}

isdigit.c/      1202506629  0     0     0       426       `
/****************************************************************************/
/*  isdigit v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isdigit(int c)
{
    return(_isdigit(c));
}

isgraph.c/      1202506629  0     0     0       426       `
/****************************************************************************/
/*  isgraph v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isgraph(int c)
{
    return(_isgraph(c));
}

islower.c/      1202506629  0     0     0       426       `
/****************************************************************************/
/*  islower v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int islower(int c)
{
    return(_islower(c));
}

iso646.h/       1202506629  0     0     0       528       `
/*****************************************************************************/
/* ISO646.H v2.70                                                            */
/* Copyright (c) 2000-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#define and    &&
#define and_eq &=
#define bitand &
#define bitor  |
#define compl  ~
#define not    !
#define not_eq !=
#define or     ||
#define or_eq  |=
#define xor    ^
#define xor_eq ^=
isprint.c/      1202506629  0     0     0       426       `
/****************************************************************************/
/*  isprint v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isprint(int c)
{
    return(_isprint(c));
}

ispunct.c/      1202506629  0     0     0       426       `
/****************************************************************************/
/*  ispunct v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int ispunct(int c)
{
    return(_ispunct(c));
}

isspace.c/      1202506629  0     0     0       426       `
/****************************************************************************/
/*  isspace v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isspace(int c)
{
    return(_isspace(c));
}

isupper.c/      1202506629  0     0     0       426       `
/****************************************************************************/
/*  isupper v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isupper(int c)
{
    return(_isupper(c));
}

isxdigit.c/     1202506629  0     0     0       428       `
/****************************************************************************/
/*  isxdigit v2.70                                                          */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int isxdigit(int c)
{
    return(_isxdigit(c));
}

ldexp.c/        1202506629  0     0     0       996       `
/****************************************************************************/
/*  ldexp  v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <errno.h>

double ldexp(double x, int exp)
{
     int *ptr = (int *) &x;
     int texp = exp + ((*ptr >> 20) & 0x7FF);

     /***********************************************************************/
     /* IF RESULT UNDERFLOWS, RETURN 0.0.  IF RESULT OVERFLOWS, RETURN      */
     /* +- INFINITY.                                                        */
     /***********************************************************************/
     if (texp < 1) return 0.0; 
     if (texp > 0x7FF) { errno = ERANGE; return (x < 0) ? -HUGE_VAL:HUGE_VAL;}

     *ptr = (*ptr & 0x800FFFFF) | ((texp << 20) & (0x7FF << 20));
     return x;
}
limits.h/       1202506629  0     0     0       1922      `
/*****************************************************************************/
/* limits.h   v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _LIMITS
#define _LIMITS

#define MB_LEN_MAX               1    /* MAX # BYTES IN MULTI-BYTE    */
#define CHAR_BIT                 8    /* NUMBER OF BITS IN TYPE CHAR  */
#define SCHAR_MIN             -128    /* MIN VALUE FOR SIGNED CHAR    */
#define SCHAR_MAX              127    /* MAX VALUE FOR SIGNED CHAR    */
#define UCHAR_MAX              255    /* MAX VALUE FOR UNSIGNED CHAR  */

#ifdef __signed_chars__
#define CHAR_MIN         SCHAR_MIN    /* MIN VALUE FOR CHAR           */
#define CHAR_MAX         SCHAR_MAX    /* MAX VALUE FOR CHAR           */
#else
#define CHAR_MIN                 0
#define CHAR_MAX         UCHAR_MAX
#endif
 
#define SHRT_MIN            -32768    /* MIN VALUE FOR SHORT          */
#define SHRT_MAX             32767    /* MAX VALUE FOR SHORT          */
#define USHRT_MAX            65535    /* MAX VALUE FOR UNSIGNED SHORT */

#define INT_MIN         (-INT_MAX-1)  /* MIN VALUE FOR INT            */
#define INT_MAX         2147483647    /* MAX VALUE FOR INT            */
#define UINT_MAX        4294967295    /* MAX VALUE FOR UNSIGNED INT   */

#define LONG_MIN        (-LONG_MAX-1) /* MIN VALUE FOR LONG           */
#define LONG_MAX        2147483647    /* MAX VALUE FOR LONG           */
#define ULONG_MAX       4294967295    /* MAX VALUE FOR UNSIGNED LONG  */

#define LLONG_MIN         (-LLONG_MAX-1) /* MIN VALUE FOR LONG LONG          */
#define LLONG_MAX    9223372036854775807 /* MAX VALUE FOR LONG LONG          */
#define ULLONG_MAX  18446744073709551615 /* MAX VALUE FOR UNSIGNED LONG LONG */

#endif
linkage.h/      1202506629  0     0     0       959       `
/*****************************************************************************/
/* linkage.h   v2.70                                                         */
/* Copyright (c) 1998-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _LINKAGE
#define _LINKAGE

/* No modifiers are needed to access code or data */

#define _CODE_ACCESS
#define _DATA_ACCESS

/*--------------------------------------------------------------------------*/
/* Define _IDECL ==> how inline functions are declared                      */
/*--------------------------------------------------------------------------*/
#ifdef _INLINE
#define _IDECL static __inline
#define _IDEFN static __inline
#define __INLINE static __inline
#else
#define _IDECL extern _CODE_ACCESS
#define _IDEFN _CODE_ACCESS
#define __INLINE __EXTERN
#endif

#endif /* ifndef _LINKAGE */

ll_asr16.asm/   1202506629  0     0     0       1678      `
;******************************************************************************
;* LL_ASR16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL$ASR - RIGHT SHIFT A 64 BIT SIGNED LONG LONG NUMBER BY 1 to 64 bits
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IS IN r2   
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IN r2 IS NOT DESTROYED
;*
;****************************************************************************
	.state16

	.global	LL$ASR

	.if .TMS470_LITTLE

hi	.set r1
lo	.set r0

	.else

hi	.set r0
lo	.set r1

	.endif

shft	.set r2

LL$ASR:	.asmfunc stack_usage(12)
	PUSH	{r3-r4, lr}  		;
        MOV     r3, #32                 ;
        SUB     r3, r3, shft            ;
        BHI     $1                      ;
        MOV     lo, hi                  ;
        ASR     hi, hi, #31
        NEG     r3, r3                  ;
        ASR     lo, r3                  ;
        B       return                  ;
$1:      
        MOV     r4, hi                  ;
        LSR     lo, shft                ;
        LSL     r4, r3                  ;
        ORR     lo, r4                  ;
        ASR     hi, shft                ;

return:
        POP     {r3-r4, pc}             ;

	.endasmfunc
        .end


ll_asr32.asm/   1202506629  0     0     0       1317      `
;******************************************************************************
;* LL_ASR32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL_ASR - RIGHT SHIFT A 64 BIT SIGNED LONG LONG NUMBER BY 1 to 64 bits
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IS IN r2   
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IN r2 IS NOT DESTROYED
;*
;****************************************************************************
	.state32

	.global	LL_ASR

	.if .TMS470_LITTLE

hi	.set r1
lo	.set r0

	.else

hi	.set r0
lo	.set r1

	.endif

shft	.set r2


LL_ASR:	.asmfunc stack_usage(8)
        STMFD   SP!, {r3, lr}           ;

	SUBS	r3, shft, #32		;
	MOVCS	lo, hi, ASR r3		;
	MOVCS	hi, hi, ASR #31		;
	RSBCC   r3, r3, #0		;
	MOVCC	lo, lo, LSR shft	;
	ORRCC	lo, lo, hi, LSL r3	;
	MOVCC	hi, hi, ASR shft

        LDMFD   SP!, {r3, pc}           ;

	.endasmfunc
        .end



ll_div16.asm/   1202506629  0     0     0       1327      `
;******************************************************************************
;* LL_DIV16.ASM  - 16 BIT STATE -  V1.16                                      *
;* Copyright (c) 1995-1997 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL$DIV/LL$MOD - DIVIDE TWO SIGNED 64 BIT NUMBERS.
;*
;****************************************************************************
;*
;*   o DIVIDEND IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o DIVISOR IS IN r2:r3  (r3:r2 IF LITTLE ENDIAN)
;*
;*   o QUOTIENT IS PLACED IN r2:r3  (r3:r2 IF LITTLE ENDIAN)
;*   o REMAINDER IS PLACED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*
;*   o DIVIDE BY ZERO RETURNS ZERO
;*   o SIGN OF REMAINDER IS THE SIGN OF THE DIVIDEND
;*
;****************************************************************************
	.state16

	.global LL$DIV
	.global LL$MOD
    .global LL_DIV
    .global LL_MOD

LL$DIV:	
LL$MOD: .asmfunc stack_usage(4)
        PUSH {lr}
	NOP
	BX  pc		        ; Change to 32-bit state
	NOP
	.align
	.state32
	BL  LL_MOD              ; and call 32-bit DIV/MOD routine.
	ADD lr, pc, #0x1        
	BX  lr
	.state16
	POP {pc}

	.endasmfunc
	.end

ll_div32.asm/   1202506629  0     0     0       14152     `
;******************************************************************************
;* LL_DIV32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL_DIV/LL_MOD - DIVIDE TWO SIGNED 64 BIT NUMBERS.
;*  
;****************************************************************************
;*
;*   o DIVIDEND IS IN r0:r1  (r1:r0 IN LITTLE ENDIAN MODE)
;*   o DIVISOR IS IN r2:r3   (r3:r2 IN LITTLE ENDIAN MODE)
;*
;*   o QUOTIENT IS PLACED IN r2:r3   (r3:r2 IN LITTLE ENDIAN MODE)
;*   o REMAINDER IS PLACED IN r0:r1  (r1:r0 IN LITTLE ENDIAN MODE)
;*
;*   o DIVIDE BY ZERO RETURNS ZERO
;*   o SIGN OF REMAINDER IS THE SIGN OF THE DIVIDEND
;*
;****************************************************************************
	.state32

	.global LL_DIV
	.global LL_MOD

	.if .TMS470_LITTLE

dvnd_hi .set    r1                                  ; HIGH WORD OF DIVIDEND
dvnd_lo .set    r0                                  ; LOW WORD OF DIVIDEND
idvs_hi .set    r3				    ; HIGH WORD OF DIVISOR
idvs_lo .set    r2				    ; LOW WORD OF DIVISOR
rq_hi   .set    r3			  	    ; HIGH WORD OF RESULT QUO
rq_lo   .set    r2			  	    ; LOW WORD OF RESULT QUO
rr_hi   .set    r1				    ; HIGH WORD OF RESULT REM
rr_lo   .set    r0				    ; HIGH WORD OF RESULT REM

	.else

dvnd_hi .set    r0                                  ; HIGH WORD OF DIVIDEND
dvnd_lo .set    r1                                  ; LOW WORD OF DIVIDEND
idvs_hi .set    r2				    ; HIGH WORD OF DIVISOR
idvs_lo .set    r3				    ; LOW WORD OF DIVISOR
rq_hi   .set    r2			  	    ; HIGH WORD OF RESULT QUO
rq_lo   .set    r3			  	    ; LOW WORD OF RESULT QUO
rr_hi   .set    r0				    ; HIGH WORD OF RESULT REM
rr_lo   .set    r1				    ; HIGH WORD OF RESULT REM

	.endif


q_hi    .set    LR                                  ; HIGH WORD OF QUOTIENT
q_lo    .set    r9                                  ; LOW WORD OF QUOTIENT
dvsr_hi .set    r4                                  ; HIGH WORD OF DIVISOR COPY
dvsr_lo .set    r5                                  ; LOW WORD OF DIVISOR COPY
tmp_hi  .set    r6                                  ; HIGH WORD OF TEMP
tmp_lo  .set    r7                                  ; LOW WORD OF TEMP
sign    .set    r8                                  ; SAVED COPY OF SIGNS

LL_DIV:	 .asmfunc stack_usage(28)
LL_MOD:
        STMFD     SP!, {r4-r9, lr}                  ;

        ; STORE THE SIGN OF REMAINDER WHICH IS THE SIGN OF THE DIVIDEND IN 
        ; BIT 31 OF SIGN. AND STORE THE SIGN OF THE QUOTIENT WHICH IS SIGN
        ; OF DIVISOR XORED WITH SIGN OF DIVIDEND IN BIT 30 OF SIGN.

        MOV       sign, idvs_hi, LSR #1             ; 
        EORS      sign, sign, dvnd_hi, ASR #1       ; 
        BPL       $pos_dvnd                         ; 
        RSBS      dvnd_lo, dvnd_lo, #0              ; DVND = ABS(DVND)
        RSC       dvnd_hi, dvnd_hi, #0              ;
$pos_dvnd:
        MOV       q_lo, #0                          ; INITIALIZE THE QUOTIENT
        ANDS      q_hi, idvs_hi, #0x80000000        ;
        BEQ       $pos_dvsr                         ;
        RSBS      idvs_lo, idvs_lo, #0              ; DVSR = ABS(DVSR)
        RSC       idvs_hi, idvs_hi, #0              ;
$pos_dvsr:
        MOV       dvsr_hi, idvs_hi                  ; MAKE A COPY OF THE   
        MOV       dvsr_lo, idvs_lo                  ; DIVISOR (R2:R3) INTO DVSR

        CMP       dvsr_hi, #0                       ; IF DVSR IS 0,
        CMPEQ     dvsr_lo, #0                       ; RETURN Q=0, R=0 
        MOVEQ     rr_lo, #0                         ;
        MOVEQ     rr_hi, #0                         ;
        LDMEQFD   SP!, {r4-r9, pc}                  ;

        ; CALCULATE THE MAXIMUM DIVISOR SHIFT AMOUNT WITH PSEUDO BINARY SEARCH
        ; IF DVND >> 32 > DVSR THEN DVSR = DVSR << 32

        CMP       dvsr_hi, #0                       ; IF (DVSR_HI == 0 AND 
        CMPEQ     dvsr_lo, dvnd_hi                  ;          DVSRLO < DVND_HI)
        MOVLS     dvsr_hi, dvsr_lo                  ;    DVSR_HI = DVSRLO
        MOVLS     dvsr_lo, #0                       ;    DVSR_LO = 0

        ; IF DVND >> 16 > DVSR THEN DVSR = DVSR << 16
        MOV       tmp_lo, dvnd_lo, LSR #16          ; SHIFT DVND BY 16 INTO
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #16  ; TMP                   
        MOV       tmp_hi, dvnd_hi, LSR #16          ; 
        CMP       dvsr_hi, tmp_hi                   ; COMPARE DVSR WITH TMP
        CMPEQ     dvsr_lo, tmp_lo                   ;
        MOVLS     dvsr_hi, dvsr_hi, LSL #16         ; SET DVSR = DVSR << 16
        ORRLS     dvsr_hi, dvsr_hi, dvsr_lo, LSR #16;
        MOVLS     dvsr_lo, dvsr_lo, LSL #16         ;

        ; IF DVND >> 16 > DVSR THEN DVSR = DVSR << 16
        MOV       tmp_lo, dvnd_lo, LSR #8           ; SHIFT DVND BY 16 INTO
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #24  ; TMP
        MOV       tmp_hi, dvnd_hi, LSR #8           ; 
        CMP       dvsr_hi, tmp_hi                   ; COMPARE DVSR WITH TMP
        CMPEQ     dvsr_lo, tmp_lo                   ;
        MOVLS     dvsr_hi, dvsr_hi, LSL #8          ; SET DVSR = DVSR << 8
        ORRLS     dvsr_hi, dvsr_hi, dvsr_lo, LSR #24;
        MOVLS     dvsr_lo, dvsr_lo, LSL #8          ;

        ; NOW FIND EXACTLY WHERE THE SHIFTED DIVISOR SHOULD BE SO THAT WE CAN
        ; JUMP INTO THE CORRECT LOCATION OF THE UNROLLED DIVIDE LOOP.
        MOV       tmp_lo, dvnd_lo, LSR #1           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #31  ;
        MOV       tmp_hi, dvnd_hi, LSR #1           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod1                              ;

        MOV       tmp_lo, dvnd_lo, LSR #2           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #30  ;
        MOV       tmp_hi, dvnd_hi, LSR #2           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod2                              ; BRANCHING INTO DIVIDE LOOP

        MOV       tmp_lo, dvnd_lo, LSR #3           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #29  ;
        MOV       tmp_hi, dvnd_hi, LSR #3           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod3                              ;

        MOV       tmp_lo, dvnd_lo, LSR #4           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #28  ;
        MOV       tmp_hi, dvnd_hi, LSR #4           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod4                              ;

        MOV       tmp_lo, dvnd_lo, LSR #5           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #27  ;
        MOV       tmp_hi, dvnd_hi, LSR #5           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod5                              ;

        MOV       tmp_lo, dvnd_lo, LSR #6           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #26  ;
        MOV       tmp_hi, dvnd_hi, LSR #6           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod6                              ;

        MOV       tmp_lo, dvnd_lo, LSR #7           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #25  ;
        MOV       tmp_hi, dvnd_hi, LSR #7           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod7                              ;

        ; THE DIVIDE LOOP IS UNROLLED 8 TIMES.
        ; IF DIVIDEND IS LARGER THAN DIVISOR, SHIFT A 1 INTO THE QUOTIENT
        ; AND SUBTRACT THE DIVISOR, ELSE SHIFT A 0 INTO THE QUOTIENT.
divll:
        MOV       tmp_hi, dvsr_hi, LSL #7           ; LEFT SHIFT DVSR BY 7 
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #25  ; INTO TMP
        MOV       tmp_lo, dvsr_lo, LSL #7           ;
        CMP       dvnd_hi, tmp_hi                   ; IF (DVND >= TMP)      
        CMPEQ     dvnd_lo, tmp_lo                   ; 
        BCC       $1                                ; 
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;    DVND = DVND - TMP
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$1:
        ADCS      q_lo, q_lo, q_lo                  ; SHIFT THE CARRY BIT DEFED
        ADC       q_hi, q_hi, q_hi                  ; BY CMP OR SBCS INTO THE 
                                                    ; QUOTIENT

mod7:
        MOV       tmp_hi, dvsr_hi, LSL #6           ; UNROLLED LOOP 
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #26  ;
        MOV       tmp_lo, dvsr_lo, LSL #6           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $2                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$2:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;
        
mod6:
        MOV       tmp_hi, dvsr_hi, LSL #5           ;
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #27  ;
        MOV       tmp_lo, dvsr_lo, LSL #5           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $3                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$3:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;
        
mod5:
        MOV       tmp_hi, dvsr_hi, LSL #4           ;
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #28  ;
        MOV       tmp_lo, dvsr_lo, LSL #4           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $4                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$4:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;
        
mod4:
        MOV       tmp_hi, dvsr_hi, LSL #3           ;
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #29  ;
        MOV       tmp_lo, dvsr_lo, LSL #3           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $5                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$5:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;
        
mod3:
        MOV       tmp_hi, dvsr_hi, LSL #2           ;
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #30  ;
        MOV       tmp_lo, dvsr_lo, LSL #2           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $6                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$6:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;
        
mod2:
        MOV       tmp_hi, dvsr_hi, LSL #1           ;
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #31  ;
        MOV       tmp_lo, dvsr_lo, LSL #1           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $7                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$7:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;

mod1:
        CMP       dvnd_hi, dvsr_hi                  ;
        CMPEQ     dvnd_lo, dvsr_lo                  ;
        
        BCC       $8                                ;
        SUBS      dvnd_lo, dvnd_lo, dvsr_lo         ;
        SBCS      dvnd_hi, dvnd_hi, dvsr_hi         ;
$8:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;

        ; IF THERE IS SHIFTED DIVISOR, THEN UNSHIFT THE DIVISOR BY 8 AND
        ; CONTINUE THE LOOP
        CMP       idvs_hi, dvsr_hi                  ; 
        CMPEQ     idvs_lo, dvsr_lo                  ;
        MOVCC     dvsr_lo, dvsr_lo, LSR #8          ;
        ORRCC     dvsr_lo, dvsr_lo, dvsr_hi, LSL #24;
        MOVCC     dvsr_hi, dvsr_hi, LSR #8          ;
        BCC       divll                             ;

        ; ELSE WE ARE DONE. 
	; PLACE THE QUOTIENT INTO rq_hi:rq_lo AND SET THE SIGN.
        ; rr_hi:rr_lo ALREADY CONTAINS THE REMAINDER; SET THE CORRECT SIGN.
        MOV       rq_hi, q_hi                       ;
        MOV       rq_lo, q_lo                       ;
        MOVS      sign, sign                        ;
        BPL       $chk_q_sign                       ;
        RSBS      rr_lo, rr_lo, #0                  ;
        RSC       rr_hi, rr_hi, #0                  ;
$chk_q_sign:
        MOVS      sign, sign, LSL #1                ;
        BPL       return                            ;
        RSBS      rq_lo, rq_lo, #0                  ;
        RSC       rq_hi, rq_hi, #0                  ;
return:

        LDMFD   SP!, {r4-r9, pc}                    ;
	.endasmfunc
        .end

ll_lsl16.asm/   1202506629  0     0     0       1684      `
;******************************************************************************
;* LL_LSL16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL$LSL - LEFT SHIFT A 64 BIT LONG LONG NUMBER BY 1 to 64 bits
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IS IN r2   
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IN r2 IS NOT DESTROYED
;*
;****************************************************************************
	.state16

	.global	LL$LSL

	.if .TMS470_LITTLE

hi	.set r1
lo	.set r0

	.else

hi	.set r0
lo	.set r1

	.endif

shft	.set r2

LL$LSL:	.asmfunc stack_usage(12)
	PUSH	{r3-r4, lr}  		;
        MOV     r3, #32                 ;
        SUB     r3, r3, shft            ;
        BHI     $1                      ;
        MOV     hi, lo                  ;
        MOV     lo, #0                  ;
        NEG     r3, r3                  ;
        LSL     hi, r3                  ;
        B       return                  ;
$1:      
        MOV     r4, lo                  ;
        LSL     hi, shft                ;
        LSR     r4, r3                  ;
        ORR     hi, r4                  ;
        LSL     lo, shft                ;

return:
        POP     {r3-r4, pc}             ;

	.endasmfunc
        .end


ll_lsl32.asm/   1202506629  0     0     0       1301      `
;******************************************************************************
;* LL_LSL32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL_LSL - LEFT SHIFT A 64 BIT LONG LONG NUMBER BY 1 to 64 bits
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IS IN r2   
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IN r2 IS NOT DESTROYED
;*
;****************************************************************************
	.state32

	.global	LL_LSL

	.if .TMS470_LITTLE

hi	.set r1
lo	.set r0

	.else

hi	.set r0
lo	.set r1

	.endif

shft	.set r2

LL_LSL:	.asmfunc stack_usage(8)
        STMFD   SP!, {r3, lr}           ;

	SUBS	r3, shft, #32		;
	MOVCS	hi, lo, LSL r3		;
	MOVCS	lo, #0			;
	RSBCC   r3, r3, #0		;
	MOVCC	hi, hi, LSL shft	;
	ORRCC	hi, hi, lo, LSR r3	;
	MOVCC	lo, lo, LSL shft	;

        LDMFD   SP!, {r3, pc}           ;

	.endasmfunc
        .end



ll_lsr16.asm/   1202506629  0     0     0       1696      `
;******************************************************************************
;* LL_LSR16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL$LSR - RIGHT SHIFT A 64 BIT UNSIGNED LONG LONG NUMBER BY 1 to 64 bits
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IS IN r2   
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IN r2 IS NOT DESTROYED
;*
;****************************************************************************
	.state16

	.global	LL$LSR

	.if .TMS470_LITTLE

hi	.set r1
lo	.set r0

	.else

hi	.set r0
lo	.set r1

	.endif

shft	.set r2

LL$LSR:	.asmfunc stack_usage(12)
	PUSH	{r3-r4, lr}  		;

        MOV     r3, #32                 ;
        SUB     r3, r3, shft            ;
        BHI     $1                      ;
        MOV     lo, hi                  ;
        MOV     hi, #0                  ;
        NEG     r3, r3                  ;
        LSR     lo, r3                  ;
        B       return                  ;
$1:      
        MOV     r4, hi                  ;
        LSR     lo, shft                ;
        LSL     r4, r3                  ;
        ORR     lo, r4                  ;
        LSR     hi, shft                ;

return:
        POP     {r3-r4, pc}             ;

	.endasmfunc
        .end


ll_lsr32.asm/   1202506629  0     0     0       1309      `
;******************************************************************************
;* LL_LSR32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL_LSR - RIGHT SHIFT A 64 BIT UNSIGNED LONG LONG NUMBER BY 1 to 64 bits
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IS IN r2   
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IN r2 IS NOT DESTROYED
;*
;****************************************************************************
	.state32

	.global	LL_LSR

	.if .TMS470_LITTLE

hi	.set r1
lo	.set r0

	.else

hi	.set r0
lo	.set r1

	.endif

shft	.set r2

LL_LSR:	.asmfunc stack_usage(8)
        STMFD   SP!, {r3, lr}           ;

	SUBS	r3, shft, #32		;
	MOVCS	lo, hi, LSR r3		;
	MOVCS	hi, #0			;
	RSBCC   r3, r3, #0		;
	MOVCC	lo, lo, LSR shft	;
	ORRCC	lo, lo, hi, LSL r3	;
	MOVCC	hi, hi, LSR shft

        LDMFD   SP!, {r3, pc}           ;

	.endasmfunc
        .end



ll_mul16.asm/   1202506629  0     0     0       1958      `
;******************************************************************************
;* LL_MUL16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL$MUL - MULTIPLY TWO 64 BIT SIGNED LONG LONG NUMBERS
;****************************************************************************
;*
;*   o INPUT OP1 IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IS IN r2:r3 (r3:r2 IF LITTLE ENDIAN)
;*   o RESULT IS RETURNED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o INPUT OP2 IN r2:r3 IS NOT DESTROYED
;*
;*   o THE UPPER 64 BITS OF THE 64 X 64 MULTIPLICATION RESULT IS IGNORED.
;*
;****************************************************************************
	.state16

	.global	LL$MUL

	.if .TMS470_LITTLE

l1_hi	.set r1
l1_lo	.set r0
l2_hi	.set r3
l2_lo	.set r2

	.else

l1_hi	.set r0
l1_lo	.set r1
l2_hi	.set r2
l2_lo	.set r3

	.endif

LL$MUL:	.asmfunc stack_usage(12)
	PUSH	{r4-r5, lr}		;

	NOP				; 
	BX	pc			; CHANGE TO 32 BIT STATE FOR MULTIPLY
	NOP				;

	.state32

        ; r4:r5 = l1_hi:l1_lo * l2_hi:l2_lo = 
	;	LO32(l1_hi*l2_lo):0 + LO32(l1_lo*l2_hi):0 + ALL64(l1_lo*l2_lo)
        MUL     r4, l2_lo, l1_hi        ;  r4 = LO32(l1_hi*l2_lo)
        MLA     r4, l2_hi, l1_lo, r4    ;  r4 = LO32(l1_hi*l2_lo) + 
					;		LO32(l1_lo*l2_hi)
        MOV     r5, #0                  ;  r4:r5 = r4:0
        UMLAL   r5, r4, l2_lo, l1_lo    ;  r4:r5 = ALL64(l1_lo*l2_lo) + r4:0
        MOV     l1_hi, r4               ;  RETURN THE RESULT IN l1_hi:l1_lo 
        MOV     l1_lo, r5               ;

	ADD	lr, pc, #0x1		; CHANGE BACK TO 16 BIT STATE
	BX	lr			;

	.state16

        POP     {r4-r5, pc}             ;

	.endasmfunc
        .end


ll_tofd16.asm/  1202506629  0     0     0       4074      `
;******************************************************************************
;* LL_TOFD16.ASM  - 16 BIT STATE -  v2.70                                     *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL$TOFD - CONVERT AN SIGNED 64 BIT INTEGER INTO AN IEEE 754 FORMAT
;*           DOUBLE PRECISION FLOATING POINT                 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o RESULT IS RETURNED IN r0:r1
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global LL$TOFD

e0	.set	r2
tmp     .set    r3
tmp2    .set    r4

LL$TOFD: .asmfunc stack_usage(16)
	CMP	r0, #0			; IF ZERO, RETURN ZERO
	BNE	$1			;
        CMP     r1, #0                  ;
        BNE     $1
	MOV	pc, lr			;

$1:	
        PUSH	{r2-r4, lr}		; SAVE CONTEXT

	; IN LITTLE ENDIAN MODE THE INPUT LONG LONG VALUE IS IN R1:R0. SWAP THE
	; WORDS SO THAT WE HAVE THE LONG LONG VAULUE IN R0:R1.

	.if .TMS470_LITTLE
	MOV	tmp, r0			;
	MOV	r0, r1			;
	MOV	r1, tmp			;
	.endif

	MOV	e0, #0x4		; PRESETUP FOR EXPONENT FIELD

        CMP     r0, #0                  ;
        BPL	$2			; IF NEGATIVE, ENCODE SIGN IN THE
	ADD	e0, #0x8		; EXPONENT FIELD

        MOV     tmp, #0                 ;
	NEG	r1, r1			; AND NEGATE THE INPUT VALUE 
        SBC     tmp, r0                 ;
        MOV     r0, tmp                 ;

$2:	
        LSL	e0, e0, #8		; SETUP REMAINDER OF THE EXPONENT FIELD
	ADD	e0, #0x3F		;

loop:	SUB	e0, e0, #0x1		; NORMALIZE THE MANTISSA
        MOV     tmp2, r0                ;
	LSL	r0, r0, #1		; ADJUSTING THE EXPONENT, ACCORDINGLY
        LSR     tmp, r1, #31            ;
        ORR     r0, tmp                 ;
        LSL     r1, r1, #1              ;
        CMP     tmp2, #0                ;
	BPL	loop			;

done:	
        LSR     r1, r1, #12             ;
        LSL	tmp, r0, #20		; SETUP LOW HALF OF RESULT
        ORR     r1, tmp                 ;
	LSR	r0, r0, #12		; SETUP HIGH HALF OF RESULT
	LSL	e0, e0, #20		;
	ORR	r0, e0			;

	POP	{r2-r4, pc}		;

	.endasmfunc
	.end
ll_tofd32.asm/  1202506629  0     0     0       3754      `
;******************************************************************************
;* LL_TOFD32.ASM  - 32 BIT STATE -  v2.70                                     *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL_TOFD - CONVERT AN SIGNED 64 BIT INTEGER INTO AN IEEE 754 FORMAT
;*           DOUBLE PRECISION FLOATING POINT                 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o RESULT IS RETURNED IN r0:r1 
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global	LL_TOFD

LL_TOFD: .asmfunc stack_usage(4)
        STMFD   sp!, {lr}               ;
        CMP	r0, #0			; IF ZERO, RETURN ZERO
        CMPEQ   r1, #0                  ;
	LDMEQFD sp!, {pc}               ;

	; IN LITTLE ENDIAN MODE THE INPUT LONG LONG VALUE IS IN R1:R0. SWAP THE
	; WORDS SO THAT WE HAVE THE LONG LONG VAULUE IN R0:R1.

	.if .TMS470_LITTLE
	MOV	lr, r0			;
	MOV	r0, r1			;
	MOV	r1, lr			;
	.endif

        CMP     r0, #0                  ;
	MOV	lr, #0x3F		; SETUP THE EXPONENT
	ORRMI	lr, lr, #0x00000C00	; AND ENCODE SIGN INTO IT
	ORRPL	lr, lr, #0x00000400	;

        BPL     loop
	RSBS 	r1, r1, #0		; TAKE THE ABS VALUE OF INPUT
        RSC     r0, r0, #0              ;

loop:	MOVS	r0, r0, LSL #1		; NORMALIZE THE MANTISSA
        ORR     r0, r0, r1, LSR #31     ;
        MOV     r1, r1, LSL #1          ;
	SUB	lr, lr, #0x1		; ADJUSTING THE EXPONENT, ACCORDINGLY
	BCC	loop			;

        MOV     r1, r1, LSR #12         ; SETUP LOW HALF OF MANTISSA
        ORR     r1, r1, r0, LSL #20     ;
        MOV     r0, r0, LSR #12         ; SETUP HIGH HALF OF MANTISSA
        ORR     r0, r0, lr, LSL #20     ; SETUP THE EXPONENT AND SIGN 

	LDMFD	sp!, {pc}               ;

	.endasmfunc
	.end
ll_tofs16.asm/  1202506629  0     0     0       3445      `
;******************************************************************************
;* LL_TOFS16.ASM  - 16 BIT STATE -  v2.70                                     *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL$TOFS - CONVERT A 64 BIT SIGNED INTEGER TO AN IEEE 754 FORMAT 
;*           SINGLE PRECISION FLOATING POINT NUMBER
;****************************************************************************
;*
;*   o INPUT OP IS IN R0:R1 (r1:r0 IF LITTLE ENDIAN)
;*   o RESULT IS RETURNED IN R0
;*   o THE VALUE IN R1 IS DESTROYED
;*
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global LL$TOFS


e0	.set	r2
tmp	.set	r3

LL$TOFS: .asmfunc stack_usage(12)
        PUSH	{r2, r3, lr}		; SAVE CONTEXT

	; IN LITTLE ENDIAN MODE THE INPUT LONG LONG VALUE IS IN R1:R0. SWAP THE
	; WORDS SO THAT WE HAVE THE LONG LONG VAULUE IN R0:R1.

	.if .TMS470_LITTLE
	MOV	tmp, r0			;
	MOV	r0, r1			;
	MOV	r1, tmp			;
	.endif

	MOV	e0, #0xBE		; SET THE EXPONENT FIELD
        MOV     lr, r0                  ; SAVE THE SIGN

	CMP	r0, #0			; IF ZERO, RETURN ZERO
	BMI	$1			;
	BNE	loop			;
        CMP     r1, #0                  ;
	BNE	loop            	;
	POP	{r2, r3, pc}		;

$1:	
        MOV     tmp, #0                 ;
        NEG     r1, r1                  ;
        SBC     tmp, r0                 ;
        MOV     r0, tmp                 ;
	BMI	cont			;

loop:   SUB     e0, #1                  ; NORMALIZE THE MANTISSA
        LSL     r0, r0, #1              ; ADJUSTING THE EXPONENT, ACCORDINGLY
        LSR     tmp, r1, #31            ;
        ORR     r0, tmp                 ;
        LSL     r1, r1, #1              ;
        CMP     r0, #0                  ;
        BPL     loop                    ;

cont:	ADD	r0, #0x80		; ADD 1/2 TO ROUND
	BCC	$2			;
	ADD	e0, #0x1		; AND ADJUST THE EXPONENT ACCORDINGLY
	B	$3			;

$2:	LSL	r0, r0, #1		; MASK IMPLIED 1 OUT OF THE MANTISSA

$3:	LSR	r0, r0, #9		; PACK THE MANTISSA
	LSL	e0, e0, #23		;
	ORR	r0, e0			; PACK THE EXPONENT
	MOV	tmp, lr			; IF THE INPUT WAS NEGATIVE
        CMP     tmp, #0                 ;
	BPL	$4			;
	MOV	e0, #1			;
	LSL	e0, e0, #31		;
	ORR	r0, e0			;  THEN SET THE SIGN FIELD
$4:	
	POP 	{r2, r3, pc}		; RESTORE CONTEXT

	.endasmfunc
	.end

ll_tofs32.asm/  1202506629  0     0     0       3135      `
;******************************************************************************
;* LL_TOFS32.ASM  - 32 BIT STATE -  v2.70                                     *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* LL_TOFS - CONVERT A 64 BIT SIGNED INTEGER TO AN IEEE 754 FORMAT
;*           SINGLE PRECISION FLOATING POINT NUMBER
;****************************************************************************
;*
;*   o INPUT OP IS IN R0:R1 (R1:R0 IF LITTLE ENDIAN)
;*   o RESULT IS RETURNED IN R0
;*   o R1 IS DESTROYED
;*
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global LL_TOFS


sign	.set	r2
e0	.set	lr

LL_TOFS: .asmfunc stack_usage(8)
        CMP	r0, #0			; 
        CMPEQ	r1, #0			; 
	MOVEQ	pc, lr			; IF ZERO, RETURN ZERO

	STMFD	sp!, {r2, lr}		; SAVE CONTEXT

	; IN LITTLE ENDIAN MODE THE INPUT LONG LONG VALUE IS IN R1:R0. SWAP THE
	; WORDS SO THAT WE HAVE THE LONG LONG VAULUE IN R0:R1.

	.if .TMS470_LITTLE
	MOV	r2, r0			;
	MOV	r0, r1			;
	MOV	r1, r2			;
	.endif

        MOV     sign, r0                ;
	MOV	e0, #0xBE		; SET THE EXPONENT FIELD

        CMP     r0, #0                  ;
        BPL     loop                    ;
	RSBS  	r1, r1, #0		; IF NEGATIVE, NEGATE IT
        RSCS    r0, r0, #0              ;
	BMI	cont			; HANDLE THE SPACIAL CASE 0x8000:0:0:0

loop:	MOVS	r0, r0, LSL #1		; NORMALIZE THE MANTISSA
        ORR     r0, r0, r1, LSR #31     ;
        MOV     r1, r1, LSL #1          ;
	SUB	e0, e0, #1		; ADJUSTING THE EXPONENT, ACCORDINGLY
	BPL	loop			;
cont:
   	ADDS	r0, r0, #0x00000080	; ADD 1/2 TO ROUND
	ADDCS	e0, e0, #0x1		; AND ADJUST THE EXPONENT ACCORDINGLY

	MOVCC	r0, r0, LSL #1		; MASK IMPLIED 1 OUT OF THE MANTISSA
	MOV	r0, r0, LSR #9		; PACK THE MANTISSA
	ORR	r0, r0, e0, LSL #23	; PACK THE EXPONENT
	CMP	sign, #0		; IF THE INPUT WAS NEGATIVE
	ORRMI	r0, r0, #0x80000000	;  THEN SET THE SIGN FIELD

	LDMFD 	sp!, {r2, pc}		; RESTORE CONTEXT

	.endasmfunc
	.end

lldiv.c/        1202506629  0     0     0       520       `
/****************************************************************************/
/*  lldiv    v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>

lldiv_t lldiv(long long num, long long den)
{
    lldiv_t rv;
    
    rv.quot = num / den;
    rv.rem  = num - (rv.quot * den);

    return rv;
}
localtim.c/     1202506630  0     0     0       3058      `
/****************************************************************************/
/*  localtime v2.70                                                         */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>
#include <limits.h>

#define SECS_IN_MIN (time_t)60
#define MINS_IN_HR  (time_t)60
#define HRS_IN_DAY  (time_t)24
#define SECS_IN_HR  (SECS_IN_MIN * MINS_IN_HR)
#define SECS_IN_DAY (SECS_IN_HR * HRS_IN_DAY)
 
#define LEAPYEAR(y) (    (y+1900) % 4   == 0                               \
			 && ((y+1900) % 100 != 0 || (y+1900) % 400 == 0))

#define DAYS_IN_YR(y) ((time_t)365 + LEAPYEAR(y))
 
_CODE_ACCESS struct tm *localtime(const time_t *timer)
{
    static _DATA_ACCESS struct tm local;
    time_t ltime  = timer ? *timer : 0;
 
    local.tm_sec  = 0;
    local.tm_min  = 0;
    local.tm_hour = 0;
    local.tm_mday = 1;
    local.tm_mon  = 0;
    local.tm_year = 0;
 
    if (timer == 0 || ltime == (time_t)-1) return &local;
 
#if INT_MAX <= 32767
    /*------------------------------------------------------------------*/
    /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */
    /* REPRESENTED IN SIGNED INTS.                                      */
    /*------------------------------------------------------------------*/
    local.tm_sec   =  ltime % SECS_IN_MIN;
    local.tm_min   = (ltime / SECS_IN_MIN) % MINS_IN_HR;
    local.tm_hour  = (ltime / SECS_IN_HR)  % HRS_IN_DAY;
 
    /*------------------------------------------------------------------*/
    /* CONVERT ltime TO NUMBER OF DAYS                                  */
    /*------------------------------------------------------------------*/
    ltime /= SECS_IN_DAY;
 
    /*------------------------------------------------------------------*/
    /* TO DETERMINE THE YEAR, INSTEAD OF DIVIDING BY 365, DO A SUBTRACT */
    /* LOOP THAT ACCOUNTS FOR LEAP YEARS.                               */
    /*------------------------------------------------------------------*/
    {
	int year = 0;
	while (ltime >= DAYS_IN_YR(year))
	{
	    ltime -= DAYS_IN_YR(year);
	    ++year;
	}
     
	local.tm_year  = year;
	local.tm_mday += ltime;
    }
 
#else
    /*------------------------------------------------------------------*/
    /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */
    /* REPRESENTED IN SIGNED INTS.                                      */
    /*------------------------------------------------------------------*/
    if ((int)ltime < 0)
    {
	local.tm_sec  = ltime % 60; 
	local.tm_min  = ltime / 60; 
    }
    else local.tm_sec = ltime;
#endif
 
    /*------------------------------------------------------------------*/
    /* MAKE VALUES IN local INTO A VALID TIME.                          */
    /*------------------------------------------------------------------*/
    mktime(&local);
    return &local;
}
log.c/          1202506630  0     0     0       3562      `
/****************************************************************************/
/*  log    v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  LOG() - natural log							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 5.              */
/*									    */
/*  N = exponent x							    */
/*  f = mantissa x, 0.5 <= f < 1					    */
/*  if f < sqrt(0.5), znum = f - 0.5, zden = znum * 0.5 + 0.5		    */
/*  if f > sqrt(0.5), znum = f - 1, zden = f * 0.5 + 0.5		    */
/*  z = znum / zden							    */
/*  w = z * z								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = R + N * ln(2)						    */
/****************************************************************************/
double log(double x)
{
    double a, b, f, r, w, z, znum;
    int n;

    /************************************************************************/
    /* check for errors in domain and range                                 */
    /************************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /************************************************************************/
    /* f = mantissa(x), n = exponent(x)            			    */
    /************************************************************************/
    f = frexp(x, &n);

    /************************************************************************/
    /* for numbers <= sqrt(0.5)                                             */
    /************************************************************************/
    if (f <= SQRTHALF)
    {
	--n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /************************************************************************/
    /* for numbers > sqrt(0.5)                                              */
    /************************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /************************************************************************/
    /* determine polynomial expression                                      */
    /************************************************************************/
    w = z * z;

#if BITS<=24
    a = A0;
    b = w + B0;
#elif BITS>=25 && BITS<=32
    a = A1 * w + A0;
    b = w + B0;
#elif BITS>=33 && BITS<=48
    a = (A2 * w + A1) * w + A0;
    b = (w + B1) * w + B0;
#else
    a = (A2 * w + A1) * w + A0;
    b = ((w + B2) * w + B1) * w + B0;
#endif

    /************************************************************************/
    /* calculate the natural log of (mant x) / 2                            */
    /************************************************************************/
    r = z + z * w * (a / b);

    /************************************************************************/
    /* ln(x) = ln (mant x) + 2 * (exp x) (but more mathematically stable)   */
    /************************************************************************/
    return ((n * C4 + r) + n * C3);
}
log10.c/        1202506630  0     0     0       3076      `
/****************************************************************************/
/*  log10  v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  LOG10() - Logarithm							    */
/*									    */
/*  result = log10(e) * log(x)						    */
/****************************************************************************/
double log10(double x)
{
    double a, b, f, r, w, z, znum;
    int n;

    /*********************************************************************/
    /* check for domain and range errors                                 */
    /*********************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /*********************************************************************/
    /* f = mantissa(x), n = exponent(x)                                  */
    /*********************************************************************/
    f = frexp(x, &n);

    /*********************************************************************/
    /* for numbers < sqrt(0.5)                                           */
    /*********************************************************************/
    if (f <= SQRTHALF)
    {
	--n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /*********************************************************************/
    /* for numbers > sqrt(0.5)                                           */
    /*********************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /*********************************************************************/
    /* determine polynomial expression                                   */
    /*********************************************************************/
    w = z * z;

#if BITS<=24
    a = A0;
    b = w + B0;
#elif BITS>=25 && BITS<=32
    a = A1 * w + A0;
    b = w + B0;
#elif BITS>=33 && BITS<=48
    a = (A2 * w + A1) * w + A0;
    b = (w + B1) * w + B0;
#else
    a = (A2 * w + A1) * w + A0;
    b = ((w + B2) * w + B1) * w + B0;
#endif

    /*********************************************************************/
    /* calculate the natural log of (mant x) / 2		         */
    /*********************************************************************/
    r = z + z * w * (a / b);

    /*********************************************************************/
    /* log10(x) = (ln (mant x) + 2 * (exp x)) * log10(e) (but more       */
    /* mathematically stable)	                                         */
    /*********************************************************************/
    return (((n * C4 + r) + n * C3) * LOG10e);
}
lowlev.c/       1202506630  0     0     0       15184     `
/*****************************************************************************/
/*  LOWLEV.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Low level I/O routines                                                    */
/*                                                                           */
/* Functions:                                                                */
/*   getnexfildes()    - Allocate next entry in stream table.                */
/*   tabinit()         - Initialize the stream and device tables.            */
/*   finddevice()      - Search the device table for a device name.          */
/*   getdevice()       - Extract the device name and <find> it.              */
/*   add_device()      - Add a device record to the device table.            */
/*   removedevice()    - Remove the specified device record from the device  */
/*                              table.                                       */
/*   open()            - Open file/device and assign file descriptor.        */
/*   read()            - Read data from an open file/device.                 */
/*   write()           - Write to an open file/device.                       */
/*   lseek()           - Perform lseek on open file/device.                  */
/*   close()           - Close an open file/device.                          */
/*   unlink()          - Perform unlink on file/device.                      */
/*   rename()          - Rename file                                         */
/*****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <_lock.h>
#include <file.h>

typedef struct {
   char           name[9];
   unsigned short flags;
   int 	  	  (*OPEN) (const char *path, unsigned flags, int llv_fd);
   int 	  	  (*CLOSE) (int dev_fd);
   int 	  	  (*READ) (int dev_fd, char *buf, unsigned count);
   int 	  	  (*WRITE) (int dev_fd, const char *buf, unsigned count);
   off_t 	  (*LSEEK) (int dev_fd, off_t offset, int origin);
   int 	  	  (*UNLINK) (const char *path);
   int 	  	  (*RENAME) (const char *old_name, const char *new_name);
} _DEVICE;

extern _CODE_ACCESS int HOSTopen(const char *path, unsigned flags, int llv_fd),
                        HOSTclose(int dev_fd),
                        HOSTread(int dev_fd, char *buf, unsigned count),
                        HOSTwrite(int dev_fd, const char *buf, unsigned count),
                        HOSTunlink(const char *path),
                        HOSTrename(const char *old_name, const char *new_name);
extern _CODE_ACCESS off_t HOSTlseek(int dev_fd, off_t offset, int origin);

static _CODE_ACCESS void tabinit(void);
static _CODE_ACCESS _DEVICE *finddevice(const char *devname);
static _CODE_ACCESS _DEVICE *getdevice (const char **path);

static _DEVICE  
_device[_NDEVICE] = { { "", _MSA, HOSTopen, HOSTclose, HOSTread,
			HOSTwrite, HOSTlseek, HOSTunlink, HOSTrename } };

#define stdevice (&_device[0]) /* Default device (host) */

static struct stream_info { _DEVICE *dev; int dfd; } 
_stream[_NSTREAM] =  { { stdevice, 0 },  
		       { stdevice, 1 }, 
		       { stdevice, 2 } };

/*****************************************************************************/
/*  TABINIT() - initialize the stream table and the device table             */
/*****************************************************************************/

static _CODE_ACCESS void tabinit(void)
{
   struct stream_info *st;
   _DEVICE            *dt;

   static _DATA_ACCESS int init = 0;

   _lock();

   if (!init)
   {
       /*--------------------------------------------------------------------*/
       /* STEP THROUGH THE TABLES SETTING NAME AND DEVICE ENTRIES TO NULL    */
       /* (SKIP PREDEFINED DEVICE AND STREAMS)				     */
       /*--------------------------------------------------------------------*/
       for (st = &_stream[3]; st != &_stream[_NSTREAM]; (st++)->dev = NULL);
       for (dt = &_device[1]; dt != &_device[_NDEVICE]; *(dt++)->name = '\0');
       init = 1;
   }

   _unlock();
}

/*****************************************************************************/
/*  FINDDEVICE() - find the device record that matches devname in the device */
/*                     table                                                 */
/*****************************************************************************/

static _CODE_ACCESS _DEVICE *finddevice(const char *devname)
{
   _DEVICE *dt;

   if (devname[0] == '\0') return NULL;

   /*------------------------------------------------------------------------*/
   /* SEARCH THE STREAM TABLE FOR THE DEVICE NAME - RETURN NULL IF NOT FOUND */
   /*------------------------------------------------------------------------*/
   for (dt = &_device[1]; dt != &_device[_NDEVICE]; ++dt)
       if (!strcmp(dt->name, devname)) return dt;

   return NULL;
}


/*****************************************************************************/
/*  GETDEVICE() - extract the device name and call finddevice                */
/*****************************************************************************/

static _CODE_ACCESS _DEVICE *getdevice (const char **path)
{
   char devname[9];
   char *colon = strchr(*path, ':');
   _DEVICE *dev;

   if (colon != NULL)
   {
       int devnamlen = colon - *path;
       if (devnamlen > 8) devnamlen = 8;

       strncpy(devname, *path, devnamlen);
       devname[devnamlen] = '\0';
       dev = finddevice(devname);

       if (dev) { *path = colon + 1; return dev; }
   }

   return stdevice; /* the "standard" device - host I/O */
}


/*****************************************************************************/
/*  ADDEVICE() - add a device record to the device table                     */
/*****************************************************************************/

_CODE_ACCESS
int add_device(char     *name,
               unsigned  flags,
               int     (*dopen)  (const char *path, unsigned flags, int llv_fd),
               int     (*dclose) (int dev_fd),
               int     (*dread)  (int dev_fd, char *buf, unsigned count),
               int     (*dwrite) (int dev_fd, const char *buf, unsigned count),
               off_t   (*dlseek) (int dev_fd, off_t offset, int origin),
               int     (*dunlink)(const char *path),
               int     (*drename)(const char *old_name, const char *new_name))
{
   _DEVICE *dt;

   tabinit();

   _lock();

   /*-------------------------------------------------------------------------*/
   /* SEARCH THE DEVICE TABLE FOR AN EMPTY SLOT, RETURN -1 IF NONE FOUND      */
   /*-------------------------------------------------------------------------*/
   for (dt = &_device[1]; dt != _device+_NDEVICE && dt->name[0] != '\0'; ++dt);
   if (dt == &_device[_NDEVICE]) { _unlock(); return -1; }

   strncpy(dt->name,name,8);
   dt->name[8] = '\0';
   dt->flags   = flags;
   dt->OPEN    = dopen;
   dt->CLOSE   = dclose;
   dt->READ    = dread;
   dt->WRITE   = dwrite;
   dt->LSEEK   = dlseek;
   dt->UNLINK  = dunlink;
   dt->RENAME  = drename;

   _unlock();

   return 0;
}

/******************************************************************************/
/*  REMOVEDEVICE() - remove the specified device record from the device table */
/******************************************************************************/

_CODE_ACCESS int remove_device(char *name)
{
   _DEVICE *ptr;

   _lock();

   /*------------------------------------------------------------------------*/
   /* FIND RECORD AND SET NAME TO NULL					     */
   /*------------------------------------------------------------------------*/
   if ( !(ptr = finddevice(name)) ) { _unlock(); return -1; }

   ptr->name[0] = '\0';

   _unlock();

   return 0;
}


/*****************************************************************************/
/*  OPEN() - open file/device specified by path and assign file descriptor   */
/*****************************************************************************/

_CODE_ACCESS int open(const char *path, unsigned flags, int mode)
{
   struct stream_info *ptr;
   _DEVICE    	      *dev;
   int        	      dev_fd;
   int        	      llv_fd;

   /*-------------------------------------------------------------------------*/
   /* INITIALIZE STREAM AND DEVICE TABLE FIRST TIME AROUND                    */
   /*-------------------------------------------------------------------------*/
   tabinit();

   _lock();

   /*-------------------------------------------------------------------------*/
   /* GET THE NEXT AVAILABLE FILE DESCRIPTOR - RETURN -1 IF NONE AVAILABLE    */
   /*-------------------------------------------------------------------------*/
   for (ptr = &_stream[3]; ptr != &_stream[_NSTREAM] && ptr->dev; ++ptr);
   if (ptr == &_stream[_NSTREAM]) { _unlock(); return -1; }
   llv_fd = ptr - &_stream[0];

   /*------------------------------------------------------------------------*/
   /* GET DEVICE AND PEFORM OPEN - SET STREAM TABLE ENTRY AND FLAGS          */
   /*------------------------------------------------------------------------*/
   dev    = getdevice(&path);
   dev_fd = (dev->flags & _BUSY) ? -1 : (*(dev->OPEN))(path,flags,llv_fd);

   if (dev_fd < 0) { _unlock(); return dev_fd; }
   
   _stream[llv_fd].dev = dev;
   _stream[llv_fd].dfd = dev_fd;
   if ( !(dev->flags & _MSA) ) dev->flags |= _BUSY;

   _unlock();

   return llv_fd;
}

/*****************************************************************************/
/*  READ() - read data from an open device/file                              */
/*****************************************************************************/

_CODE_ACCESS int read(int llv_fd, char *bufptr, unsigned cnt)
{
   int result;

   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;

   _lock();

   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM READ FOR THIS DEVICE/FILE   */
   /*------------------------------------------------------------------------*/
   result = (*(_stream[llv_fd].dev->READ)) (_stream[llv_fd].dfd,bufptr,cnt);

   _unlock();

   return result;
}

/*****************************************************************************/
/*  WRITE() - write data to an open device/file                              */
/*****************************************************************************/

_CODE_ACCESS int write(int llv_fd, const char *bufptr, unsigned cnt)
{
   int result;

   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;

   _lock();

   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM WRITE FOR THIS DEVICE/FILE  */
   /*------------------------------------------------------------------------*/
   result = (*(_stream[llv_fd].dev->WRITE)) (_stream[llv_fd].dfd,bufptr,cnt);

   _unlock();

   return result;
}

/*****************************************************************************/
/*  LSEEK() - lseek on an open device/file                                   */
/*****************************************************************************/

_CODE_ACCESS off_t lseek(int llv_fd, off_t offset, int origin)
{
   off_t result;

   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;

   _lock();

   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM LSEEK FOR THIS DEVICE/FILE  */
   /*------------------------------------------------------------------------*/
   result = (*(_stream[llv_fd].dev->LSEEK)) (_stream[llv_fd].dfd,offset,origin);

   _unlock();

   return result;
}

/*****************************************************************************/
/*  CLOSE() - close an open device/file                                      */
/*****************************************************************************/

_CODE_ACCESS int close(int llv_fd)
{
   int result;

   if (llv_fd < 0 || llv_fd >= _NSTREAM) return -1;

   _lock();

   if (_stream[llv_fd].dev == NULL) { _unlock(); return -1; }

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM CLOSE FOR THIS DEVICE/FILE  */
   /* CLEAR STREAM TABLE ENTRY AND DEVICE FLAGS                              */
   /*------------------------------------------------------------------------*/
   if ( (result = (*(_stream[llv_fd].dev->CLOSE))(_stream[llv_fd].dfd)) != -1 )
   {
      _stream[llv_fd].dev->flags &= ~_BUSY;
      _stream[llv_fd].dev = NULL;
   }

   _unlock();

   return result;
}

/*****************************************************************************/
/*  UNLINK() - unlink an open device/file                                    */
/*****************************************************************************/

_CODE_ACCESS int unlink(const char *path)
{
   _DEVICE *dev;
   int      result;

   _lock();

   dev = getdevice(&path);

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM UNLINK FOR THIS DEVICE/FILE */
   /*------------------------------------------------------------------------*/
   result = (*(dev->UNLINK)) (path);

   _unlock();

   return result;
}

/*****************************************************************************/
/*  RENAME() - rename a device/file                                          */
/*****************************************************************************/

_CODE_ACCESS int rename(const char *old_name, const char *new_name)
{
   _DEVICE *old_dev, *new_dev;
   int result;

   _lock();

   old_dev = getdevice(&old_name);
   new_dev = getdevice(&new_name);

   /*------------------------------------------------------------------------*/
   /* IF THE DEVICES ARE NOT THE SAME, RENAME WOULD REQUIRE A FILE COPY.     */
   /*------------------------------------------------------------------------*/
   if (old_dev != new_dev) { _unlock(); return -1; }

   /*------------------------------------------------------------------------*/
   /* CALL FUNCTION FROM DEVICE TABLE TO PERFORM RENAME FOR THIS DEVICE/FILE */
   /*------------------------------------------------------------------------*/
   result = (*(old_dev->RENAME)) (old_name, new_name);

   _unlock();
   
   return result;
}
ltoa.c/         1202506630  0     0     0       762       `
/****************************************************************************/
/*  ltoa v2.70 								    */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>
#define BUFLEN 20

_CODE_ACCESS int ltoa(long val, char *buffer)
{
    char           tempc[BUFLEN];
    register char *bufptr;
    register int   neg = val < 0;
    register long  uval = val;

    *(bufptr = &tempc[BUFLEN - 1]) = 0;

    do {*--bufptr = abs(uval % 10) + '0';}  while(uval /= 10);
    if (neg) *--bufptr = '-';

    memcpy(buffer,bufptr, uval = (tempc + BUFLEN) - bufptr);
    return uval - 1;    /* DON'T COUNT NULL TERMINATION */
}

math.h/         1202506630  0     0     0       3155      `
/*****************************************************************************/
/* math.h     v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _MATH
#define _MATH

#include <linkage.h>

#include <float.h>
#define HUGE_VAL   DBL_MAX
#define HUGE_VALL  LDBL_MAX

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cmath> IS RECOMMENDED OVER <math.h>.  <math.h> IS PROVIDED FOR 
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
#include <cmath>
using std::modf;
using std::asin;
using std::acos;
using std::atan;
using std::atan2;
using std::ceil;
using std::cos;
using std::cosh;
using std::exp;
using std::fabs;
using std::floor;
using std::fmod;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::pow;
using std::sin;
using std::sinh;
using std::tan;
using std::tanh;
using std::sqrt;

#else /* !__cplusplus */

/***************************************************************/
/* FUNCTION DEFINITIONS.                                       */
/***************************************************************/
         double modf(double x, double *y); 
         double asin(double x);
         double acos(double x);
         double atan(double x);
         double atan2(double y, double x);
#if defined(_OPTIMIZE_FOR_SPACE) && 1
         double ceil(double x);
#else
  _IDECL double ceil(double x);
#endif
         double cos(double x);
         double cosh(double x);
         double exp(double x);
         double fabs(double x);
#if defined(_OPTIMIZE_FOR_SPACE) && 1
         double floor(double x);
#else
  _IDECL double floor(double x);
#endif
         double fmod(double x, double y);
         double frexp(double x, int *exp);
         double ldexp(double x, int exp);
         double log(double x);
         double log10(double x);
         double pow(double x, double y);
         double sin(double x);
         double sinh(double x);
         double tan(double x);
         double tanh(double x);
         double sqrt(double x);

#if defined(_CEIL) ||						\
    (defined(_INLINE) && 					\
     !(defined(_OPTIMIZE_FOR_SPACE) && 1))
#if defined(_OPTIMIZE_FOR_SPACE) && 1
       double ceil(double x)
#else
_IDEFN double ceil(double x)
#endif
{
     double y; 
     return (modf(x, &y) > 0 ? y + 1.0 : y);
}
#endif /* (_CEIL || (_INLINE && !(_OPTIMIZE_FOR_SPACE && __TMS470))) */

#if defined(_FLOOR) ||						\
    (defined(_INLINE) && 					\
     !(defined(_OPTIMIZE_FOR_SPACE) && 1))
#if defined(_OPTIMIZE_FOR_SPACE) && 1
    double floor(double x)
#else
_IDEFN double floor(double x)
#endif
{
     double y; 
     return (modf(x, &y) < 0 ? y - 1.0 : y);
}
#endif /* (_FLOOR || (_INLINE && !(_OPTIMIZE_FOR_SPACE && __TMS470))) */

#endif /* __cplusplus */
#endif /* _MATH */

memccpy.c/      1202506630  0     0     0       964       `
/*****************************************************************************/
/*  MEMCCPY.C  v2.70                                                         */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include "stdlib.h"

extern _CODE_ACCESS char *memccpy(char *dest, const char *src, int ch, int cnt);

/*--------------------------------------------------------------------------*/
/* PERFORM SAME OPERATION AS MEMCPY, ABORT IF "ch" is COPIED.               */
/* RETURN POINTER TO BYTE AFTER ch IS FOUND, OR NULL IF NOT FOUND           */
/*--------------------------------------------------------------------------*/
_CODE_ACCESS char *memccpy(char *dest, const char *src, int ch, int cnt)
{
   if (cnt <= 0) return NULL;
   do
      if ((*dest++ = *src++) == ch) return (dest);
   while (--cnt != 0);

   return NULL;
}
memchr.c/       1202506630  0     0     0       411       `
/****************************************************************************/
/*  memchr v2.70                                                            */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _MEMCHR

#include <string.h>

memcmp.c/       1202506630  0     0     0       363       `
/****************************************************************************/
/*  memcmp v2.70 							    */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _MEMCMP

#include <string.h>

memcpy.c/       1202506630  0     0     0       488       `
/****************************************************************************/
/*  memcpy.c  v2.70                                                         */
/*  Copyright (c) 1996-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

void *memcpy(void *s1, const void *s2, register size_t n)
{
   return memcpy(s1, s2, n);       /* NOTE:  MEMCPY() IS A BUILTIN FUNCTION */
}
memcpy16.asm/   1202506630  0     0     0       3535      `
;******************************************************************************
;* MEMCPY16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************
 
;****************************************************************************
;* C$MEMCPY - COPY CHARACTERS FROM SOURCE TO DEST
;*
;****************************************************************************
;*
;*   o DESTINATION LOCATION IS IN r0
;*   o SOURCE LOCATION IS IN r1
;*   o NUMBER OF CHARACTERS TO BE COPIED IS IN r2
;****************************************************************************
        .state16
 
        .global C$MEMCPY
C$MEMCPY: .asmfunc
        CMP     r2, #0                  ; CHECK FOR n == 0
        BEQ     _ret2_			;
 
        MOV	r12, r0			; SAVE RETURN VALUE

	LSL	r3, r1, #30		; CHECK ADDRESS ALIGNMENT
	BNE	_unaln			; IF NOT WORD ALIGNED, HANDLE SPECIALLY
	LSL	r3, r0, #30		;
	BNE	_saln			;

_aln:	CMP	r2, #16			; ADDRESSES AND LENGTH ARE WORD ALIGNED
	BCC	_udr16			; IF n < 16, SKIP 16 BYTE COPY CODE

_ovr16:	PUSH	{r4 - r6}		; COPYING 16 BYTES OR MORE.
	SUB	r2, #16			;
_lp16:	LDMIA	r1!, {r3 - r6}		;
	STMIA	r0!, {r3 - r6}		;
	SUB	r2, #16			;
	BCS	_lp16			;
	POP	{r4 - r6}		; RESTORE THE SAVED REGISTERS AND
	ADD	r2, #16			; CONTINUE THE COPY IF THE REMAINDER
	BEQ	_ret_			; IS NONZERO.
	
_udr16: CMP	r2, #4			; IF UNDER 16, THEN COMPUTE 
	BCC	_off1			; THE COPY CODE TO EXECUTE, AND
	CMP	r2, #8			; GO THERE
	BCC	_c4			;
	CMP	r2, #12			;
	BCC	_c8			;

_c12:	LDMIA	r1!, {r3}		; COPY 12 BYTES
	STMIA	r0!, {r3}		; 
_c8:	LDMIA	r1!, {r3} 		; COPY 8 BYTES
	STMIA	r0!, {r3}		;
_c4:	LDMIA	r1!, {r3} 		; COPY 4 BYTES
	STMIA	r0!, {r3}		;

_oddsz:	LSL	r2, r2, #30		; HANDLE THE TRAILING BYTES
	BEQ	_ret_			;
	LSR	r2, r2, #30		;
	B	_lp1			;

_unaln:	LDRB	r3, [r1]		; THE ADDRESSES ARE NOT WORD ALIGNED.
	STRB	r3, [r0]		; COPY BYTES UNTIL THE SOURCE IS
	ADD	r1, r1, #1		;
	ADD	r0, r0, #1		;
	SUB	r2, r2, #1		; WORD ALIGNED OR THE COPY SIZE
	BEQ	_ret_			; BECOMES ZERO
	LSL	r3, r1, #30		;
	BNE	_unaln			;

_saln:	LSL	r3, r0, #31		; IF THE ADDRESSES ARE OFF BY 1 BYTE
	BNE	_off1			; JUST BYTE COPY

	LSL	r3, r0, #30		; IF THE ADDRESSES ARE NOW WORD ALIGNED
	BEQ	_aln			; GO COPY.  ELSE THEY ARE OFF BY 2, SO
					; GO SHORT WORD COPY

_off2:	SUB	r2, r2, #4		; COPY 2 BYTES AT A TIME...
	BCC	_oddb			;
_cp4s:	LDMIA	r1!, {r3}		; LOAD IN CHUNKS OF 4
	.if	.TMS470_BIG
	STRH	r3, [r0, #2]		;
	LSR	r3, r3, #16		;
	STRH	r3, [r0]		;
	.else
	STRH	r3, [r0]		;
	LSR	r3, r3, #16		;
	STRH	r3, [r0, #2]		;
	.endif
	ADD	r0, r0, #4		;
	SUB	r2, r2, #4		;
	BCS	_cp4s			;
	B	_oddb			;

_cp4:	LDMIA	r1!, {r3}		; COPY 1 BYTE AT A TIME, IN CHUNKS OF 4
	.if	.TMS470_BIG
	STRB	r3, [r0, #3]		;
	LSR	r3, r3, #8		;
	STRB	r3, [r0, #2]		;
	LSR	r3, r3, #8		;
	STRB	r3, [r0, #1]		;
	LSR	r3, r3, #8		;
	STRB	r3, [r0]		;
	.else
	STRB	r3, [r0]		;
	LSR	r3, r3, #8		;
	STRB	r3, [r0, #1]		;
	LSR	r3, r3, #8		;
	STRB	r3, [r0, #2]		;
	LSR	r3, r3, #8		;
	STRB	r3, [r0, #3]		;
	.endif
	ADD	r0, r0, #4		;
_off1:	SUB	r2, r2, #4		;
	BCS	_cp4			;

_oddb:	ADD	r2, r2, #4		; THEN COPY THE ODD BYTES.
	BEQ	_ret_			;
	
_lp1:	LDRB	r3, [r1]		;
	STRB	r3, [r0]		;
	ADD	r1, r1, #1		;
	ADD	r0, r0, #1		;
	SUB	r2, r2, #1		;
	BNE	_lp1			;
_ret_:	MOV	r0, r12			;
_ret2_:	MOV	pc, lr

	.endasmfunc

	.end




memcpy32.asm/   1202506630  0     0     0       4130      `
;******************************************************************************
;* MEMCPY32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************
 
;****************************************************************************
;* C_MEMCPY - COPY CHARACTERS FROM SOURCE TO DEST
;*
;****************************************************************************
;*
;*   o DESTINATION LOCATION IS IN r0
;*   o SOURCE LOCATION IS IN r1
;*   o NUMBER OF CHARACTERS TO BE COPIED IS IN r2
;****************************************************************************
        .state32
 
        .global C_MEMCPY
C_MEMCPY: .asmfunc stack_usage(12)
	CMP	r2, #0			; CHECK FOR n == 0
	BXEQ	lr			;

	STMFD	sp!, {r0, lr}		; SAVE RETURN VALUE AND ADDRESS

	TST	r1, #0x3		; CHECK ADDRESS ALIGNMENT
	BNE	_unaln			; IF NOT WORD ALIGNED, HANDLE SPECIALLY
	TST	r0, #0x3		;
	BNE	_saln			;

_aln:	CMP	r2, #16			; CHECK FOR n >= 16
	BCC	_l16			;

	STMFD	sp!, {r4}		;
	SUB	r2, r2, #16		;
_c16:	LDMIA	r1!, {r3, r4, r12, lr}	; COPY 16 BYTES
	STMIA	r0!, {r3, r4, r12, lr}	;
	SUBS	r2, r2, #16		;
	BCS	_c16			;
	LDMFD	sp!, {r4}		;
	ADDS	r2, r2, #16		; RETURN IF DONE
	LDMEQFD	sp!, {r0, pc}		;
	
_l16:	ANDS	r3, r2, #0xC		;
	BEQ	_cp1			;
	BICS	r2, r2, #0xC		;
	ADR	r12, _4line - 16	;
	ADD	pc, r12, r3, LSL #2	;

_4line:	LDR	r3, [r1], #4		; COPY 4 BYTES
	STR	r3, [r0], #4		;
	LDMEQFD	sp!, {r0, pc} 		; CHECK FOR n == 0
	B	_cp1			;

	LDMIA	r1!, {r3, r12}		; COPY 8 BYTES
	STMIA	r0!, {r3, r12}		;
	LDMEQFD	sp!, {r0, pc} 		; CHECK FOR n == 0
	B	_cp1			;

	LDMIA	r1!, {r3, r12, lr}	; COPY 12 BYTES
	STMIA	r0!, {r3, r12, lr}	;
	LDMEQFD	sp!, {r0, pc} 		; CHECK FOR n == 0

_cp1:	SUBS	r2, r2, #1		;
	ADRNE	r3, _1line - 4		; SETUP TO COPY 1 - 3 BYTES...
	ADDNE	pc, r3, r2, LSL #4	;

_1line:	LDRB	r3, [r1], #1		; COPY 1 BYTE
	STRB	r3, [r0], #1		;
	LDMFD	sp!, {r0, pc}		;

	LDRH	r3, [r1], #2		; COPY 2 BYTES
	STRH	r3, [r0], #2		;
	LDMFD	sp!, {r0, pc}		;
	NOP				;

	LDRH	r3, [r1], #2		; COPY 3 BYTES
	STRH	r3, [r0], #2		;
	LDRB	r3, [r1], #1		;
	STRB	r3, [r0], #1		;
	LDMFD	sp!, {r0, pc}		;

_unaln:	LDRB	r3, [r1], #1		; THE ADDRESSES ARE NOT WORD ALIGNED.
	STRB	r3, [r0], #1		; COPY BYTES UNTIL THE SOURCE IS
	SUBS	r2, r2, #1		; WORD ALIGNED OR THE COPY SIZE
	LDMEQFD	sp!, {r0, pc}		; BECOMES ZERO
	TST	r1, #0x3		;
	BNE	_unaln			;

_saln:	TST	r0, #0x1		; IF THE ADDRESSES ARE OFF BY 1 BYTE
	BNE	_off1			; JUST BYTE COPY

	TST	r0, #0x2		; IF THE ADDRESSES ARE NOW WORD ALIGNED
	BEQ	_aln			; GO COPY.  ELSE THEY ARE OFF BY 2, SO
					; GO SHORT WORD COPY

_off2:	SUBS	r2, r2, #4		; COPY 2 BYTES AT A TIME...
	BCC	_c1h			;
_c2:	LDR	r3, [r1], #4		; START BY COPYING CHUNKS OF 4,
	.if	.TMS470_BIG
	STRH	r3, [r0, #2]		;
	MOV	r3, r3, LSR #16		;
	STRH	r3, [r0], #4		;
	.else
	STRH	r3, [r0], #4		;
	MOV	r3, r3, LSR #16		;
	STRH	r3, [r0, #-2]		;
	.endif
	SUBS	r2, r2, #4		;
	BCS	_c2			;
	CMN	r2, #4			;
	LDMEQFD	sp!, {r0, pc}		;

_c1h:	ADDS	r2, r2, #2		; THEN COPY THE ODD BYTES.
	LDRCSH	r3, [r1], #2		;
	STRCSH	r3, [r0], #2		;
	SUBCS	r2, r2, #2		;
	ADDS	r2, r2, #1		;
	LDRCSB	r3, [r1], #1		;
	STRCSB	r3, [r0], #1		;
	LDMFD	sp!, {r0, pc}		;

_off1:	SUBS	r2, r2, #4		; COPY 1 BYTE AT A TIME...
	BCC	_c1b			;
_c1:	LDR	r3, [r1], #4		; START BY COPYING CHUNKS OF 4,
	.if	.TMS470_BIG
	STRB	r3, [r0, #3]		;
	MOV	r3, r3, LSR #8		;
	STRB	r3, [r0, #2]		;
	MOV	r3, r3, LSR #8		;
	STRB	r3, [r0, #1]		;
	MOV	r3, r3, LSR #8		;
	STRB	r3, [r0], #4		;
	.else
	STRB	r3, [r0], #4		;
	MOV	r3, r3, LSR #8		;
	STRB	r3, [r0, #-3]		;
	MOV	r3, r3, LSR #8		;
	STRB	r3, [r0, #-2]		;
	MOV	r3, r3, LSR #8		;
	STRB	r3, [r0, #-1]		;
	.endif
	SUBS	r2, r2, #4		;
	BCS	_c1			;

_c1b:	ADDS	r2, r2, #4		; THEN COPY THE ODD BYTES.
	LDMEQFD	sp!, {r0, pc}		;
_lp1:	LDRB	r3, [r1], #1		;
	STRB	r3, [r0], #1		;
	SUBS	r2, r2, #1		;
	BNE	_lp1			;
	LDMFD	sp!, {r0, pc}		;

	.endasmfunc

	.end




memmov.c/       1202506630  0     0     0       702       `
/****************************************************************************/
/*  memmov.c  v2.70                                                         */
/*  Copyright (c) 1996-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

void *memmove(void *s1, const void *s2, size_t n)
{
   if (s2 > s1)
      return memcpy(s1, s2, n);
   else
   {
      unsigned char *st1 = (unsigned char *)s1;
      unsigned char *st2 = (unsigned char *)s2;
      size_t         ln;
 
      st1 += n;
      st2 += n;
      for (ln = 0; ln < n; ln++) *--st1 = *--st2;
   }

   return s1;
}

memory.c/       1202506630  0     0     0       24799     `
/*****************************************************************************/
/*  memory.c  v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/
/*									     */
/*  This module contains the functions which implement the dynamic memory    */
/*  management routines. The following assumptions/rules apply:              */
/*									     */
/*   1) Packets are allocated a minimum of MIN_BLOCK + BLOCK_OVERHEAD bytes. */
/*   2) The size of the heap is set at link time, using the -heap flag       */
/*      The allocation and sizing of the heap is a cooperative effort        */
/*      involving the linker, this file, and "sysmem.c".                     */
/*   3) The heap can be reset at any time by calling the function "minit"    */
/*									     */
/*  The following items are defined in this module :			     */
/*    minit()	 : Function to initialize dynamic memory management	     */
/*    malloc()	 : Function to allocate memory from mem mgmt system.	     */
/*    calloc()	 : Allocate an clear memory from mem mgmt system.	     */
/*    realloc()  : Reallocate a packet					     */
/*    free()	 : Function to free allocated memory.			     */
/*    memalign() : Function to allocate aligned memory from mem mgmt system. */
/*---------------------------------------------------------------------------*/
/*    minsert()  : Insert a packet into free list, sorted by size	     */
/*    mremove()  : Remove a packet from the free list.			     */
/*    sys_free	 : Pointer to free list 				     */
/*									     */
/*****************************************************************************/
#include <stdlib.h>
#include <string.h>
#include <_lock.h>

/*---------------------------------------------------------------------------*/
/* MIN_BLOCK MUST BE A MULTIPLE OF THE SIZEOF (LARGE_TYPE)                   */
/*---------------------------------------------------------------------------*/
#define LARGE_TYPE      long
#define MIN_BLOCK       sizeof(LARGE_TYPE)
#define BLOCK_OVERHEAD  MIN_BLOCK
#define BLOCK_USED      1
#define BLOCK_MASK      (MIN_BLOCK-1)

/*---------------------------------------------------------------------------*/
/* "PACKET" is the template for a data packet.  Packet size contains         */
/* the number of bytes allocated for the user, excluding the size required   */
/* for management of the packet (BLOCK_OVERHEAD bytes).  Packets are always  */
/* allocated memory in MIN_BLOCK byte chunks. The lowest order bit of the    */
/* size field is used to indicate whether the packet is free(0) or used(1).  */
/* The size_ptr field is used to manage the free list, and is a pointer      */
/* to the next element in the free list.  The free list is sorted by size.   */
/*---------------------------------------------------------------------------*/
typedef struct pack 
{
    size_t        packet_size;     /* number of bytes        */
    struct pack  *size_ptr;        /* next elem in free list */
} PACKET;


/*---------------------------------------------------------------------------*/
/* _SYSMEM_SIZE is a symbol whose *address* is set by the linker to the      */
/* size of the heap, via the -heap flag.                                     */
/*---------------------------------------------------------------------------*/
extern int _SYSMEM_SIZE;              /* address = size of heap */

/*---------------------------------------------------------------------------*/
/* Size of the heap area as defined by the linker.                           */
/*---------------------------------------------------------------------------*/
static int _memory_size = (int)&_SYSMEM_SIZE;

/*---------------------------------------------------------------------------*/
/* Define the heap memory area.  Note that allocated space is actually       */
/* (re)allocated in the linker.  The object must appear in the ".sysmem"     */
/* data section, and it must be aligned properly.                            */
/*---------------------------------------------------------------------------*/
/* Autoinitialize the first packet to indicate a single heap packet whose    */
/* size is equal to the total heap minus the size of the header (a PACKET).  */
/* This is equivalent to calling minit() at boot time.                       */
/*---------------------------------------------------------------------------*/
#pragma DATA_SECTION(_sys_memory, ".sysmem")
PACKET _sys_memory[8] = { ((size_t)&_SYSMEM_SIZE) - BLOCK_OVERHEAD, 0 };

#define heap_mem ((char *)_sys_memory)

/*---------------------------------------------------------------------------*/
/* SYS_FREE - This variable is a pointer to the free list.                   */
/*---------------------------------------------------------------------------*/
static PACKET *sys_free = _sys_memory;

/*---------------------------------------------------------------------------*/
/* Function declarations                                                     */
/*---------------------------------------------------------------------------*/
static void minsert(PACKET *);         /* insert a packet into the free list */
static void mremove(PACKET *);         /* delete packet from the free list   */
void minit(void);         

/*****************************************************************************/
/*									     */
/*  MINSERT - Insert a packet into the free list.  This list is sorted by    */
/*	      size in increasing order. 				     */
/*									     */
/*****************************************************************************/
static void minsert(PACKET *ptr)
{
    register PACKET *current = (PACKET *) sys_free;
    register PACKET *last    = NULL;

    /*-----------------------------------------------------------------------*/
    /* CHECK SPECIAL CASE, EMPTY FREE LIST.				     */
    /*-----------------------------------------------------------------------*/
    if (current == NULL)
    {
        sys_free      = ptr;
        ptr->size_ptr = NULL;
        return;
    }

    /*-----------------------------------------------------------------------*/
    /* SCAN THROUGH LIST, LOOKING FOR A LARGER PACKET.			     */
    /*-----------------------------------------------------------------------*/
    while (current && current->packet_size < ptr->packet_size)
    {
	last	= current;
	current = current->size_ptr;
    }

    /*-----------------------------------------------------------------------*/
    /* LINK THE NEW PACKET INTO THE LIST. THERE ARE THREE CASES :	     */
    /*	 THE NEW POINTER WILL EITHER BE THE FIRST, THE LAST, OR IN THE	     */
    /*	 MIDDLE SOMEWHERE.						     */
    /*-----------------------------------------------------------------------*/
    if (current == NULL) 	        /* PTR WILL BE LAST IN LIST          */
    {
        last->size_ptr = ptr;
        ptr->size_ptr  = NULL;
    }
    else if (last == NULL)	        /* PTR WILL BE FIRST IN THE LIST     */
    {
        ptr->size_ptr  = sys_free;
        sys_free       = ptr;
    }
    else			        /* PTR IS IN THE MIDDLE OF THE LIST  */
    {
        ptr->size_ptr  = current;
        last->size_ptr = ptr;
    }
}


/*****************************************************************************/
/*									     */
/* MREMOVE - REMOVE AN ITEM FROM THE FREE LIST. 			     */
/*									     */
/*****************************************************************************/
static void mremove(PACKET *ptr)
{
    register PACKET *current = sys_free;
    register PACKET *last    = NULL;

    /*-----------------------------------------------------------------------*/
    /* SCAN THROUGH LIST, LOOKING FOR PACKET TO REMOVE                       */
    /*-----------------------------------------------------------------------*/
    while (current && current != ptr)
    {
	last	= current;
	current = current->size_ptr;
    }

    /*-----------------------------------------------------------------------*/
    /* REMOVE THE PACKET FROM THE LIST.   THERE ARE TWO CASES :              */
    /*   THE OLD POINTER WILL EITHER BE THE FIRST, OR NOT THE FIRST.         */
    /*-----------------------------------------------------------------------*/
    if      (current == NULL) sys_free       = NULL;          /* NOT FOUND   */
    else if (last    == NULL) sys_free       = ptr->size_ptr; /* 1ST IN LIST */
    else                      last->size_ptr = ptr->size_ptr; /* MID OF LIST */
}

/*****************************************************************************/
/*									     */
/*  MINIT - This function can be called by the user to completely reset the  */
/*	    memory management system.					     */
/*									     */
/*****************************************************************************/
void minit(void)
{
    _lock();

    /*-----------------------------------------------------------------------*/
    /* TO INITIALIZE THE MEMORY SYSTEM, SET UP THE FREE LIST TO POINT TO     */
    /* THE ENTIRE HEAP, AND INITIALIZE HEAP TO A SINGLE EMPTY PACKET.        */
    /*-----------------------------------------------------------------------*/
    sys_free = _sys_memory;

    sys_free->packet_size = _memory_size - BLOCK_OVERHEAD;
    sys_free->size_ptr	  = NULL;

    _unlock();
}

/*****************************************************************************/
/*									     */
/*  MALLOC - Allocate a packet of a given size, and return a pointer to it.  */
/*	     This function only allocates in multiples of MIN_BLOCK bytes.   */
/*									     */
/*****************************************************************************/
void *malloc(size_t size)
{
    register PACKET *current;
    register size_t  newsize = (size + BLOCK_MASK) & ~BLOCK_MASK;
    register size_t  oldsize;

    if (size <= 0) return NULL;

    _lock();

    current = sys_free;

    /*-----------------------------------------------------------------------*/
    /* SCAN THROUGH FREE LIST FOR PACKET LARGE ENOUGH TO CONTAIN PACKET      */
    /*-----------------------------------------------------------------------*/
    while (current && current->packet_size < newsize)
       current = current->size_ptr;

    if (!current)
    {
	_unlock();
	return NULL;
    }
    
    oldsize = current->packet_size;	    /* REMEMBER OLD SIZE	     */
    mremove(current);		            /* REMOVE PACKET FROM FREE LIST  */

    /*-----------------------------------------------------------------------*/
    /* IF PACKET IS LARGER THAN NEEDED, FREE EXTRA SPACE AT END	             */
    /* BY INSERTING REMAINING SPACE INTO FREE LIST.			     */
    /*-----------------------------------------------------------------------*/
    if (oldsize - newsize >= (MIN_BLOCK + BLOCK_OVERHEAD))
    {
       register PACKET *next = 
	       (PACKET *) ((char *) current + BLOCK_OVERHEAD + newsize);
 
       next->packet_size    = oldsize - newsize - BLOCK_OVERHEAD;
       minsert(next);
       current->packet_size = newsize;
    }

   current->packet_size |= BLOCK_USED;
   _unlock();
   return (char *)current + BLOCK_OVERHEAD;
}

/*****************************************************************************/
/*									     */
/*  CALLOC - Allocate a packet of a given size, set the data in the packet   */
/*	     to nulls, and return a pointer to it.			     */
/*									     */
/*****************************************************************************/
void *calloc(size_t num, size_t size)
{
    register size_t      i	 = size * num;
    register LARGE_TYPE *current = (LARGE_TYPE *)malloc(i);
    register void       *save    = current;

    if (current == 0) return NULL;

    i = ((i + BLOCK_MASK) & ~BLOCK_MASK) / sizeof(LARGE_TYPE);

    while (i--) *current++ = 0;
    return save;
}

/*****************************************************************************/
/*									     */
/*  REALLOC - Reallocate a packet to a new size.			     */
/*									     */
/*****************************************************************************/
void *realloc(void *packet, size_t size)
{
    register char    *pptr    = (char *) packet - BLOCK_OVERHEAD;
    register size_t   newsize = (size + BLOCK_MASK) & ~BLOCK_MASK;
    register size_t   oldsize;

    if (packet == 0)  return malloc(size);
    if (size   == 0)  { free(packet); return NULL; }

    _lock();

    oldsize = ((PACKET *)pptr)->packet_size;

    if (!(oldsize & BLOCK_USED)) { _unlock(); return NULL; }
    if (newsize == --oldsize)    { _unlock(); return packet; }

    /*-----------------------------------------------------------------------*/
    /* IF NEW SIZE IS LESS THAN CURRENT SIZE, TRUNCATE PACKET AND RETURN END */
    /* TO FREE LIST		                                             */
    /*-----------------------------------------------------------------------*/
    if (newsize < oldsize)
    {
       if (oldsize - newsize < (MIN_BLOCK + BLOCK_OVERHEAD))
       {
	  _unlock();
	  return packet;
       }
       ((PACKET *)pptr)->packet_size = newsize | BLOCK_USED;

       oldsize -= newsize + BLOCK_OVERHEAD;
       pptr    += newsize + BLOCK_OVERHEAD;
       ((PACKET *)pptr)->packet_size = oldsize | BLOCK_USED;
       free(pptr + BLOCK_OVERHEAD);
       _unlock();
       return packet;
    }

    /*-----------------------------------------------------------------------*/
    /* IF NEW SIZE IS BIGGER THAN CURRENT PACKET,		             */
    /*	1) CHECK NEXT PACKET IN LIST, SEE IF PACKET CAN BE EXPANDED          */
    /*	2) IF NOT, MOVE PACKET TO NEW LOCATION. 		             */
    /*-----------------------------------------------------------------------*/
    else
    {
	PACKET *next = (PACKET *)(pptr + oldsize + BLOCK_OVERHEAD);
	int     temp;

	if (((char *)next < &heap_mem[_memory_size - BLOCK_OVERHEAD]) &&
           (!(next->packet_size & BLOCK_USED))                        &&
           ((temp = oldsize +next->packet_size +BLOCK_OVERHEAD -newsize) >= 0))
	{
	    mremove(next);
	    if (temp < MIN_BLOCK + BLOCK_OVERHEAD)
	    {
	       ((PACKET *)pptr)->packet_size = newsize + temp | BLOCK_USED;
	       _unlock();
	       return packet;
	    }

	    ((PACKET *)pptr)->packet_size = newsize | BLOCK_USED;
	    pptr += newsize + BLOCK_OVERHEAD;
	    ((PACKET *)pptr)->packet_size = temp - BLOCK_OVERHEAD;
	    minsert((PACKET *)pptr);
	    _unlock();
	    return packet;
	}
	else
	{
            /*---------------------------------------------------------------*/
	    /* ALLOCATE NEW PACKET AND MOVE DATA INTO IT. 	             */
            /*---------------------------------------------------------------*/
	    register char *new_packet = (char *)malloc(size);
	    if (new_packet == 0) { _unlock(); return NULL; }
	    memcpy(new_packet, packet, oldsize);
	    free(packet);
	    _unlock();
	    return new_packet;
	}
    }
}

/*****************************************************************************/
/*									     */
/*  FREE - Return a packet allocated by malloc to free memory pool.	     */
/*	   Return NULL if successful, -1 if not successful.		     */
/*									     */
/*****************************************************************************/
void free(void *packet)
{
    register char   *ptr = (char *)packet;
    register PACKET *last;	      /* POINT TO PREVIOUS PACKET            */
    register PACKET *current;	      /* POINTER TO THIS PACKET              */
    register PACKET *next;	      /* POINTER TO NEXT PACKET              */

    if (ptr == NULL) return;

    last = next = NULL;		      /* INITIALIZE POINTERS                 */
    ptr -= BLOCK_OVERHEAD;	      /* ADJUST POINT TO BEGINNING OF PACKET */

    _lock();

    current = _sys_memory;

    /*-----------------------------------------------------------------------*/
    /* SEARCH FOR THE POINTER IN THE PACKET POINTED TO			     */
    /*-----------------------------------------------------------------------*/
    while (current < (PACKET *) ptr)
    {
        last    = current;
        current = (PACKET *)((char *)current + 
		  (current->packet_size & ~BLOCK_USED) + BLOCK_OVERHEAD);
    }

    /*-----------------------------------------------------------------------*/
    /* CHECK FOR POINTER OR PACKET ERRORS.				     */
    /*-----------------------------------------------------------------------*/
    if ((current != (PACKET *) ptr) || (!(current->packet_size & BLOCK_USED)))
    {
	 _unlock();
         return;
    }

    current->packet_size &= ~BLOCK_USED;   /* MARK PACKET AS FREE */

    /*-----------------------------------------------------------------------*/
    /* GET POINTER TO NEXT PACKET IN MEMORY, IF ANY.			     */
    /*-----------------------------------------------------------------------*/
    next = (PACKET *) ((char *)current + BLOCK_OVERHEAD +current->packet_size);
    if (next > (PACKET *) &heap_mem[_memory_size - BLOCK_OVERHEAD]) 
	next = NULL;

    if (last && last->packet_size & BLOCK_USED) last = NULL;
    if (next && next->packet_size & BLOCK_USED) next = NULL;

    /*-----------------------------------------------------------------------*/
    /* ATTEMPT TO COLLESCE THE THREE PACKETS (PREVIOUS, CURRENT, NEXT)	     */
    /*-----------------------------------------------------------------------*/
    if (last && next)
    {
	mremove(last);
	mremove(next);
	last->packet_size += current->packet_size + next->packet_size + 
			     BLOCK_OVERHEAD + BLOCK_OVERHEAD;
	minsert(last);
	_unlock();
	return;
    }

    /*-----------------------------------------------------------------------*/
    /* ATTEMPT TO COLLESCE THE CURRENT WITH LAST PACKET. (LAST, CURRENT)     */
    /*-----------------------------------------------------------------------*/
    if (last)
    {
	mremove(last);
	last->packet_size += current->packet_size + BLOCK_OVERHEAD;
	minsert(last);
	_unlock();
	return;
    }

    /*-----------------------------------------------------------------------*/
    /* ATTEMPT TO COLLESCE THE CURRENT WITH NEXT PACKET. (CURRENT, NEXT)     */
    /*-----------------------------------------------------------------------*/
    if (next)
    {
       mremove(next);
       current->packet_size += next->packet_size + BLOCK_OVERHEAD;
       minsert(current);
	_unlock();
       return;
    }

    /*-----------------------------------------------------------------------*/
    /* NO COLLESCENCE POSSIBLE, JUST INSERT THIS PACKET INTO LIST	     */
    /*-----------------------------------------------------------------------*/
    minsert(current);
    _unlock();
}

/*****************************************************************************/
/*                                                                           */
/*  MEMALIGN - Allocate a packet of a given size, and on a given boundary.   */
/*                                                                           */
/*****************************************************************************/
void *memalign(size_t alignment, size_t size)
{
    PACKET *aln_packet;
    PACKET *current;
    size_t  newsize  = (size + BLOCK_MASK) & ~BLOCK_MASK;
    size_t  aln_mask = alignment - 1;
    int     leftover = -1;
    char   *aln_start;
    char   *un_aln_start;
 
    if (size <= 0) return NULL;
      
    /*--------------------------------------------------------------------*/
    /* IF ALIGNMENT IS NOT A POWER OF TWO OR IS LESS THAN THE DEFAULT     */
    /* ALIGNMENT OF MALLOC, THEN SIMPLY RETURN WHAT MALLOC RETURNS.       */
    /*--------------------------------------------------------------------*/
    if (alignment <= BLOCK_OVERHEAD || (alignment & (alignment-1)))
	  return malloc(size);

    _lock();

    current = sys_free;

    /*-----------------------------------------------------------------------*/
    /* SCAN THROUGH FREE LIST FOR PACKET LARGE ENOUGH TO CONTAIN ALIGNED     */
    /* PACKET                                                                */
    /*-----------------------------------------------------------------------*/
    for ( ; current ; current = current->size_ptr)
    {
       un_aln_start = (char *) current + BLOCK_OVERHEAD;
       aln_start    = (char *)(((size_t) un_aln_start + aln_mask) & ~aln_mask);
       leftover     = un_aln_start + current->packet_size - aln_start -newsize;

       /*--------------------------------------------------------------------*/
       /* MAKE SURE THAT THE PRE BLOCK SPACE IS LARGE ENOUGH TO BE A BLOCK   */
       /* OF ITS OWN.                                                        */
       /*--------------------------------------------------------------------*/
       for ( ; (char *)current+sizeof(PACKET) > aln_start-BLOCK_OVERHEAD ;
	       aln_start += alignment, leftover -= alignment);

       if (leftover >= 0) break;
    }

    if (!current) { _unlock(); return NULL; }

    /*-----------------------------------------------------------------------*/
    /* SETUP NEW PACKET FOR ALIGNED MEMORY.                                  */
    /*-----------------------------------------------------------------------*/
    mremove(current);
    aln_packet              = (PACKET *) (aln_start - BLOCK_OVERHEAD);
    aln_packet->packet_size = newsize | BLOCK_USED;

    /*-----------------------------------------------------------------------*/
    /* HANDLE THE FREE SPACE BEFORE THE ALIGNED BLOCK.  IF THE ORIGINAL      */
    /* BLOCK WAS ALIGNED, THERE WON'T BE FREE SPACE BEFORE THE ALIGNED BLOCK.*/
    /*-----------------------------------------------------------------------*/
    if (aln_start != un_aln_start) 
    {
	current->packet_size = (char *)aln_packet - un_aln_start;
	minsert(current);
    }

    /*-----------------------------------------------------------------------*/
    /* HANDLE THE FREE SPACE AFTER THE ALIGNED BLOCK. IF IT IS LARGE ENOUGH  */
    /* TO BE A BLOCK OF ITS OWN, THEN MAKE IT ONE, OTHERWISE ADD THE         */
    /* LEFTOVER SIZE TO THE ALIGNED BLOCK.                                   */ 
    /*-----------------------------------------------------------------------*/ 
    if (leftover >= BLOCK_OVERHEAD + MIN_BLOCK)
    {
       register PACKET *next = (PACKET *) (aln_start + newsize);
       next->packet_size     = leftover - BLOCK_OVERHEAD;
       minsert(next);
    }
    else aln_packet->packet_size += leftover;

    _unlock();
    return aln_start;
}
       

#ifdef MALLOC_DEBUG
/*****************************************************************************/
/*									     */
/*  MEMMAP -  Print dynamic memory allocation statistics                     */
/*									     */
/*****************************************************************************/
#include <stdio.h>
#ifndef MAX
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#endif

void memmap()
{
    PACKET *current;
    int free_block_num		= 0;
    int free_block_space	= 0;
    int free_block_max		= 0;
    int used_block_num		= 0;
    int used_block_space	= 0;
    int used_block_max		= 0;

    _lock();

    current = _sys_memory;

    /*-----------------------------------------------------------------------*/
    /* LOOP THROUGH ALL PACKETS                                              */
    /*-----------------------------------------------------------------------*/
    while (current < (PACKET *) &heap_mem[_memory_size-BLOCK_OVERHEAD]) 
    {
	int size = current->packet_size & ~BLOCK_USED;
        int used = current->packet_size & BLOCK_USED;

        printf(">> Used:%1d size:%d addr:%x\n", used, size, current);

        if (used)
	{
	    used_block_num++;
	    used_block_space += size;
	    used_block_max   = MAX(used_block_max, size);
	}
	else
	{
	    free_block_num++;
	    free_block_space += size;
	    free_block_max   = MAX(free_block_max, size);
	}

        current = (PACKET *)((char *)current + size + BLOCK_OVERHEAD);
    }

    printf("fr_nm:%d fr_sp:%d fr_mx:%d us_nm:%d us_sp:%d us_mx:%d ovr:%d\n\n", 
	    free_block_num, free_block_space, free_block_max,
	    used_block_num, used_block_space, used_block_max,
	    (free_block_num + used_block_num) * BLOCK_OVERHEAD);

    _unlock();
    fflush(stdout);
}
#endif

memset16.asm/   1202506630  0     0     0       3198      `
;******************************************************************************
;* MEMSET16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* memset - INITIALIZE MEMORY WITH VALUE.
;* 
;*	C Prototype   : void *memset(void *s, int c, size_t n);
;*      C++ Prototype : void *std::memset(void *s, int c, std::size_t n);
;*
;****************************************************************************
;*
;*   o DESTINATION LOCATION IS IN r0
;*   o INITIALIZATION VALUE IS IN r1
;*   o NUMBER OF BYTES TO INITIALIZE IS IN r2
;*
;*   o ORIGINAL DESTINATION LOCATION RETURNED IN r0
;****************************************************************************
	.state16

	.global $memset

$memset: .asmfunc
	MOV	R12, R0			; save R0 also since original dst
					; address is returned.

	LSL	R3, R0, #30
	BEQ	_word_aligned

_unaligned_loop				; set bytes until there are no more
	CMP	R2, #0			; to set or until address is aligned
        BEQ	_done
	STRB	R1, [R0]
	ADD	R0, #1
	SUB	R2, #1
	LSL	R3, R0, #30
	BNE	_unaligned_loop
          
_word_aligned:
	CMP	R2,#4			; are at least 4 bytes being set
	BCC	_memset3

	LSL	R1, R1, #24		; be safe since prototype has value as
	LSR	R1, R1, #24		; as an int rather than unsigned char

	LSL	R3, R1, #8		; replicate byte in all 4 bytes of
	ORR	R1, R3			; register
	LSL	R3, R1, #16
	ORR	R1, R3

	CMP	R2,#8			; are at least 8 bytes being set
	BCC	_memset7
        
	MOV	R3,R1			; copy bits into another register so
					; 8 bytes at a time can be copied.

	CMP	R2,#16			; are at least 16 bytes being set
	BCC	_memset15

	PUSH	{R4, R5, R6}		; save regs needed by 16 byte copies

	MOV	R4, #15

	SUB	R6, R2, R4		; set up loop count
	AND	R2, R4			; determine number of bytes to set
					; after setting 16 byte blocks


	MOV	R4, R1			; copy bits into 2 other registers so
	MOV	R5, R1			; 16 bytes at a time can be copied
	

_memset16_loop:				; set blocks of 16 bytes
	STMIA	R0!, {R1, R3, R4, R5}
	SUB	R6, #16
	BHI	_memset16_loop

	POP	{R4, R5, R6}		; resotre regs used by 16 byte copies

_memset15:				; may still be as many as 15 bytes to 
					; set. the address in R0 is guaranteed
					; to be word aligned here.

	CMP	R2, #8
	BCC	_memset7	
	STMIA	R0!, {R1, R3}		; are at least 8 bytes being set
	SUB	R2, #8

_memset7:				; may still be as many as 7 bytes to 
					; set. the address in R0 is guaranteed
					; to be word aligned here.

	CMP	R2,#4			; are at least 4 bytes being set
	BCC	_memset3
	STMIA	R0!, {R1}
	SUB	R2, #4

_memset3:				; may still be as many as 3 bytes to 
					; set. the address in R0 is guaranteed
					; to be word aligned here.

	CMP	R2, #0
	BEQ	_done			; if 0 bytes left to set then done

	SUB	R2, #1
_memset1_loop:
	STRB	R1, [R0, R2]
	SUB	R2, #1
	BCS	_memset1_loop


_done:					; all done, restore regs and return
	MOV	R0, R12
	MOV	PC, LR

	.endasmfunc

	.end
memset32.asm/   1202506630  0     0     0       3510      `
;******************************************************************************
;* MEMSET32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* memset - INITIALIZE MEMORY WITH VALUE.
;*
;*	C Prototype   : void *memset(void *s, int c, size_t n);
;*      C++ Prototype : void *std::memset(void *s, int c, std::size_t n);
;*
;****************************************************************************
;*
;*   o DESTINATION LOCATION IS IN r0
;*   o INITIALIZATION VALUE IS IN r1
;*   o NUMBER OF BYTES TO INITIALIZE IS IN r2
;*
;*   o ORIGINAL DESTINATION LOCATION RETURNED IN r0
;****************************************************************************
	.state32

	.global _memset

_memset: .asmfunc stack_usage(8)
	STMFD	SP!, {R0, LR}		; save R0 also since original dst
					; address is returned.

	TST	R0, #3			; check for word alignment
	BEQ	_word_aligned

	CMP	R2, #0			; set bytes until there are no more
					; to set or until address is aligned
_unaligned_loop:
	STRHIB	R1, [R0], #1
	SUBHIS	R2, R2, #1
	TSTHI	R0, #3
	BNE	_unaligned_loop
          
	CMP	R2, #0			; return early if no more bytes
	LDMEQFD	SP!, {R0, PC}		; to set.

_word_aligned:
	AND	R1, R1, #255		; be safe since prototype has value as
					; as an int rather than unsigned char

	ORR	R1, R1, R1, LSL	#8      ; replicate byte in 2nd byte of
					; register

	CMP	R2,#4			; are at least 4 bytes being set
	BCC	_memset3

	ORR	R1, R1, R1, LSL	#16	; replicate byte in upper 2 bytes
					; of register. note that each of
					; the bottom 2 bytes already contain 
					; the byte value from above.

	CMP	R2,#8			; are at least 8 bytes being set
	BCC	_memset7
        
	MOV	LR,R1			; copy bits into another register so
					; 8 bytes at a time can be copied.
					; use LR since it is already being
					; saved/restored.

	CMP	R2,#16			; are at least 16 bytes being set
	BCC	_memset15

	STMFD	SP!, {R4}		; save regs needed by 16 byte copies

	MOV	R4, R1			; copy bits into 2 other registers so
	MOV	R12, R1			; 16 bytes at a time can be copied

	SUB	R3, R2, #15		; set up loop count
	AND	R2, R2, #15		; determine number of bytes to set
					; after setting 16 byte blocks

_memset16_loop:				; set blocks of 16 bytes
	STMIA	R0!, {R1, R4, R12, LR}
	SUBS	R3, R3, #16
	BHI	_memset16_loop

	LDMFD	SP!, {R4}		; resotre regs used by 16 byte copies

_memset15:				; may still be as many as 15 bytes to 
					; set. the address in R0 is guaranteed
					; to be word aligned here.

	TST	R2, #8			; are at least 8 bytes being set
	STMNEIA	R0!, {R1, LR}


_memset7:				; may still be as many as 7 bytes to 
					; set. the address in R0 is guaranteed
					; to be word aligned here.

	TST	R2, #4			; are at least 4 bytes being set
	STRNE	R1, [R0], #4

_memset3:				; may still be as many as 3 bytes to 
					; set. the address in R0 is guaranteed
					; to be word aligned here.

	TST	R2, #2			; are there at least 2 more bytes to 
	STRNEH	R1, [R0], #2		; set.  the address in R0 is guaranteed
					; to be half-word aligned here.
	
	TST	R2, #1			; is there one remaining byte to set
	STRNEB	R1, [R0]


	LDMFD     SP!, {R0, PC}		; restore regs and return

	.endasmfunc

	.end
mktime.c/       1202506630  0     0     0       4933      `
/****************************************************************************/
/*  mktime v2.70                                                            */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>
#include <limits.h>

static _DATA_ACCESS const unsigned int mon_len[] =
	{31,28,31,30,31,30,31,31,30,31,30,31 };
static _DATA_ACCESS const unsigned int mon_day[] =
	{0,31,59,90,120,151,181,212,243,273,304,334};

#define JAN11900    (time_t)1                   
#define DAYS_IN_YR  (time_t)365     
#define SECS_IN_MIN (time_t)60 
#define MINS_IN_HR  (time_t)60 
#define HRS_IN_DAY  (time_t)24 
#define SECS_IN_HR  (SECS_IN_MIN * MINS_IN_HR)
#define SECS_IN_DAY (SECS_IN_HR  * HRS_IN_DAY)
#define SECS_IN_YR  (DAYS_IN_YR  * SECS_IN_DAY)

/* THE FOLLOWING MACRO DETERINES IF ADDING k TO x CAUSES OVERFLOW */

#define OVERFLOW(x,k) (((x) > 0) == ((k) > 0) &&          \
                       ((unsigned)(x)       <= INT_MAX) != \
		       ((unsigned)((x)+(k)) <= INT_MAX))

#define LEAPYEAR(y)   ( ((y + 1900) % 4 == 0) &&      \
                       (((y + 1900) % 100 != 0) || ((y + 1900) % 400 == 0)) )

_CODE_ACCESS time_t mktime(register struct tm *tptr)
{
   time_t   result;
   time_t   daycount;
   int      mdays;
   int      adjust;
    
   /*-----------------------------------------------------------------*/
   /* HANDLE SECONDS.  IF TOO MANY OR TOO FEW, MODIFY MINUTES.        */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_sec < 0) ? -((unsigned)(-tptr->tm_sec + 59) / 60) 
			       : (tptr->tm_sec / 60);

   if (OVERFLOW(tptr->tm_min, adjust)) return((time_t) -1);
   tptr->tm_min += adjust;
   tptr->tm_sec -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE MINUTES.  IF TOO MANY OR TOO FEW, MODIFY HOURS           */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_min < 0) ? -((unsigned)(-tptr->tm_min + 59) / 60) 
			       : (tptr->tm_min / 60);

   if (OVERFLOW(tptr->tm_hour, adjust)) return((time_t) -1);
   tptr->tm_hour += adjust;
   tptr->tm_min  -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE HOURS.    IF TOO MANY OR TOO FEW, MODIFY DAYS            */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_hour < 0) ? -((unsigned)(-tptr->tm_hour + 23) / 24) 
			        : (tptr->tm_hour / 24);

   if (OVERFLOW(tptr->tm_mday, adjust)) return((time_t) -1);
   tptr->tm_mday += adjust;
   tptr->tm_hour -= adjust * 24;

   for (;;)
   {
      /*-----------------------------------------------------------------*/
      /* HANDLE MONTHS.   IF TOO MANY OR TOO FEW, MODIFY YEARS           */
      /*-----------------------------------------------------------------*/
      adjust = (tptr->tm_mon < 0) ? -((unsigned)(-tptr->tm_mon + 11) / 12) 
				  : (tptr->tm_mon / 12);

      if (OVERFLOW(tptr->tm_year, adjust)) return((time_t) -1);
      tptr->tm_year += adjust;
      tptr->tm_mon  -= adjust * 12;

      /*-----------------------------------------------------------------*/
      /* HANDLE DAYS.     IF TOO MANY OR TOO FEW, MODIFY MONTHS          */
      /*-----------------------------------------------------------------*/
      if (tptr->tm_mday <= 0)
      { 
	   tptr->tm_mon--;  
           tptr->tm_mday += mon_len[tptr->tm_mon < 0 ? 11 : tptr->tm_mon] + 
		        ((tptr->tm_mon == 1) && ((tptr->tm_year % 4) == 0));
	   continue;
      }

      /*-----------------------------------------------------------------*/
      /* CALCULATE NUMBER OF DAYS IN THIS MONTH.                         */
      /*-----------------------------------------------------------------*/
      mdays = mon_len[tptr->tm_mon] + 
		( (tptr->tm_mon == 1) && LEAPYEAR(tptr->tm_year) );

      if (tptr->tm_mday > mdays) 
	{ tptr->tm_mday -= mdays; tptr->tm_mon++; }
      else break;
   }

   /*--------------------------------------------------------------------*/
   /* WE CAN NOW BE SURE THAT ALL FIELDS IN THE TIME STRUCTURE ARE RIGHT */
   /*--------------------------------------------------------------------*/
   tptr->tm_yday = mon_day[tptr->tm_mon]  + tptr->tm_mday - 1 +
                   ( (tptr->tm_mon > 1) && LEAPYEAR(tptr->tm_year) );

   daycount      = tptr->tm_year * DAYS_IN_YR  + 
	           ((tptr->tm_year - 1) / 4)   + tptr->tm_yday;

   result        = daycount      * SECS_IN_DAY + 
	           tptr->tm_hour * SECS_IN_HR  +
	           tptr->tm_min  * SECS_IN_MIN + tptr->tm_sec;

   tptr->tm_wday  = (JAN11900 + daycount) % 7;
   tptr->tm_isdst = _tz.daylight;

   return result;
}


modf.c/         1202506630  0     0     0       2383      `
/****************************************************************************/
/*  modf   v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*									    */
/*  MODF() - break into integer and fractional parts			    */
/*									    */
/****************************************************************************/
double modf(double value, double *iptr)
{
    unsigned long *dptr = (unsigned long *)&value;
    double input        = value;   

    /************************************************************************/
    /* Get double precision exponent, subtract bias                         */
    /************************************************************************/
    int exp = ((*dptr >> 20) & 0x7FF) - 1023;

    /************************************************************************/
    /* IF VALUE HAS NO WHOLE PART, EASY.                                    */
    /************************************************************************/
    if (exp < 0)   { *iptr = 0.0; return value; }

    /************************************************************************/
    /* IF VALUE HAS NO FRACTIONAL PART, ALSO EASY                           */
    /************************************************************************/
    if (exp >= 52) { *iptr = value; return 0.0; }

    /************************************************************************/
    /* OTHERWISE, NOT SO EASY.                                              */
    /* MASK OFF FRACTIONAL BITS TO GET INTEGRAL PORTION OF VALUE.           */
    /************************************************************************/
    if (exp < 20)
        { dptr[1] = 0; dptr[0] &= ~((1 << (20 - exp)) - 1); }
    else
	{ dptr[1] &= ~((1 << (52 - exp)) - 1); }
   
    /************************************************************************/
    /* SUBTRACT INTEGRAL PORTION FROM ORIGINAL VALUE TO GET FRACTIONAL PART.*/
    /************************************************************************/
    *iptr = value;
    return input - value;
}

new/            1202506630  0     0     0       1793      `
/*****************************************************************************/
/* new   v2.70                                                               */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _NEW
#define _NEW

#include <cstdlib>      // for size_t
#include <exception>    // for exception

namespace std
{
   class bad_alloc {};
   struct nothrow_t {};
   extern const nothrow_t nothrow;
   typedef void (*new_handler)();
   new_handler set_new_handler(new_handler new_p); // throw();
}	

void *operator new(std::size_t size); // throw(std::bad_alloc)
void *operator new(std::size_t size, const std::nothrow_t&); // throw()
void  operator delete(void *ptr); // throw()
void  operator delete(void *ptr, const std::nothrow_t&); // throw()
void *operator new[](std::size_t size); // throw(std::bad_alloc)
void *operator new[](std::size_t size, const std::nothrow_t& nt_arg); //throw()
void  operator delete[](void *ptr); // throw()
void  operator delete[](void *ptr, const std::nothrow_t& nt_arg); // throw()
void *operator new  (std::size_t, void *ptr); // throw()
void *operator new[](std::size_t, void *ptr); // throw()
void  operator delete  (void *ptr, void*); // throw()
void  operator delete[](void *ptr, void*); // throw()

#ifdef __embedded_cplusplus
//----------------------------------------------------------------------------
// We cannot expect the embedded C++ user to use std namespace. So we include
// the using directive when compiled under embedded C++.
//----------------------------------------------------------------------------
using namespace std;
#endif /* __embedded_cplusplus */

#endif

new_.cpp/       1202506630  0     0     0       1996      `
/*****************************************************************************/
/* new     v2.70                                                             */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#if 0

/*****************************************************************************/
/* The name of this file is new_.cpp to avoid an implicit rule problem with  */
/* gmake when new.cpp has a timestamp later than new.                        */
/*****************************************************************************/

#endif
#include <cstdlib>
#include <new>

namespace std
{
   const nothrow_t nothrow;
   void default_new_handler();

   new_handler new_handler_fun = default_new_handler;
}

/****************************************************************************/
/*                                                                          */
/* SET_NEW_HANDLER() - ESTABLISHES THE GIVEN FUNCTION AS THE CURRENT NEW    */
/*                     HANDLER.  RETURNS THE PREVIOUS ONE.                  */
/*                                                                          */
/****************************************************************************/
std::new_handler std::set_new_handler(std::new_handler new_p) // throw()
{
   std::new_handler old_p = std::new_handler_fun;

   std::new_handler_fun = new_p;
   return old_p;
}

/****************************************************************************/
/*                                                                          */
/* DEFAULT_NEW_HANDLER() - THIS IMPLEMENTATION'S DEFAULT NEW HANDLER.       */
/*                                                                          */
/****************************************************************************/
void std::default_new_handler()
{
// throw std::bad_alloc;
   std::abort();
}
new_af.cpp/     1202506630  0     0     0       844       `
/*****************************************************************************/
/* new_af     v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <new>

/****************************************************************************/
/*                                                                          */
/* OPERATOR NEW[]() - DEFAULT GLOBAL ALLOCATION FUNCTION FOR ARRAYS.        */
/*                                                                          */
/****************************************************************************/
void *operator new[](std::size_t size) // throw(std::bad_alloc)
{
   return operator new(size);
}
new_afn.cpp/    1202506630  0     0     0       947       `
/*****************************************************************************/
/* new_afn     v2.70                                                         */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <new>

/****************************************************************************/
/*                                                                          */
/* OPERATOR NEW[]() - NO EXCEPTION VERSION OF THE DEFAULT GLOBAL ALLOCATION */
/*                    FUNCTION FOR ARRAYS.                                  */
/*                                                                          */
/****************************************************************************/
void *operator new[](std::size_t size, const std::nothrow_t& nt_arg) //throw()
{
   return operator new(size, nt_arg);
}

new_afp.cpp/    1202506630  0     0     0       901       `
/*****************************************************************************/
/* new_afp   v2.70                                                           */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <new>

/****************************************************************************/
/*                                                                          */
/* OPERATOR NEW[]() - PLACEMENT VERSION OF THE DEFAULT GLOBAL ALLOCATION    */
/*                    FUNCTION FOR ARRAYS.                                  */
/*                                                                          */
/****************************************************************************/
void *operator new[](std::size_t, void *ptr) // throw()
{
   return ptr;
}

new_sof.cpp/    1202506630  0     0     0       1883      `
/*****************************************************************************/
/* new_sof  v2.70                                                            */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <cstdlib>
#include <new>

namespace std
{
   extern new_handler new_handler_fun;
}

/****************************************************************************/
/*                                                                          */
/* OPERATOR NEW() - DEFAULT GLOBAL ALLOCATION FUNCTION FOR SINGLE OBJECTS.  */
/*                                                                          */
/****************************************************************************/
void *operator new(std::size_t size) // throw(std::bad_alloc)
{
   void *p;

   /*-----------------------------------------------------------------------*/
   /* IF SIZE IS ZERO, INCREASE TO ONE SO THAT A UNIQUE POINTER IS RETURNED.*/
   /*-----------------------------------------------------------------------*/
   if (size == 0) size = 1;

   /*-----------------------------------------------------------------------*/
   /* ATTEMPT TO ALLOCATE THE REQUESTED SPACE.                              */
   /* IF ATTEMPT FAILS, CALL new_handler() IF SET, ELSE THROW AN EXCEPTION. */
   /* THE LOOP TERMINATES WHEN ALLOCATION IS SUCCESSFUL, new_handler()      */
   /* NEVER RETURNS, OR AN EXCEPTION IS THROWN.                             */
   /*-----------------------------------------------------------------------*/
   while (!(p = std::malloc(size)))
   {
      if (std::new_handler_fun)  std::new_handler_fun();
//    else                       throw std::bad_alloc;
      else                       return p;
   }

   return p;
}

new_sofn.cpp/   1202506630  0     0     0       2004      `
/*****************************************************************************/
/* new_sofn  v2.70                                                           */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <cstdlib>
#include <new>

namespace std
{
   extern new_handler new_handler_fun;
}

/****************************************************************************/
/*                                                                          */
/* OPERATOR NEW() - NO EXCEPTION VERSION OF THE DEFAULT GLOBAL ALLOCATION   */
/*                  FUNCTION FOR SINGLE OBJECTS.                            */
/*                                                                          */
/****************************************************************************/
void *operator new(std::size_t size, const std::nothrow_t&) // throw()
{
   void *p;

   /*-----------------------------------------------------------------------*/
   /* IF SIZE IS ZERO, INCREASE TO ONE SO THAT A UNIQUE POINTER IS RETURNED.*/
   /*-----------------------------------------------------------------------*/
   if (size == 0) size = 1;

   /*-----------------------------------------------------------------------*/
   /* ATTEMPT TO ALLOCATE THE REQUESTED SPACE.                              */
   /* IF ATTEMPT FAILS, CALL new_handler() IF SET, ELSE RETURN NULL.        */
   /* IF THE CALL TO new_handler() THROWS A std::bad_alloc EXCEPTION,       */
   /* CATCH IT AND RETURN NULL.                                             */
   /*-----------------------------------------------------------------------*/
   while (!(p = std::malloc(size)))
   {
      if (!std::new_handler_fun)  return p;
      else
      {
//       try
//       {
	    std::new_handler_fun();
//       }
//       catch (std::bad_alloc) { return p; }
      }
   }

   return p;
}
new_sofp.cpp/   1202506630  0     0     0       900       `
/*****************************************************************************/
/* new_sofp  v2.70                                                           */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#include <new>

/****************************************************************************/
/*                                                                          */
/* OPERATOR NEW() - PLACEMENT VERSION OF THE DEFAULT GLOBAL ALLOCATION      */
/*                  FUNCTION FOR OBJECTS.                                   */
/*                                                                          */
/****************************************************************************/
void *operator new (std::size_t, void *ptr) // throw()
{
   return ptr;
}
perror.c/       1202506630  0     0     0       2043      `
/*****************************************************************************/
/*  PERROR.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PERROR   -  Report any system errors to stderr                         */
/*****************************************************************************/
#include <stdio.h>
#include <errno.h>


/*****************************************************************************/
/* PERROR   -  Report any system errors to stderr                            */
/*****************************************************************************/
_CODE_ACCESS void perror(const char *_s)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char *buf;

   /*------------------------------------------------------------------------*/
   /* If _s is not NULL, prepend it to any error message.                    */
   /*------------------------------------------------------------------------*/
   if (_s && *_s)
   {
      fputs(_s, stderr);
      fputs(": ", stderr);
   }

   switch(errno)
   {
      case 0      :  buf = "No error";                  break;
      case EDOM   :  buf = "Domain error";              break;
      case ERANGE :  buf = "Range error";               break;
      case ENOENT :  buf = "No such file or directory"; break;
      case EFPOS  :  buf = "File positioning error";    break;
      default     :  buf = "Unknown error";             break;
   }

   fputs(buf, stderr);
   fputc('\n', stderr);
}


pow.c/          1202506630  0     0     0       2437      `
/****************************************************************************/
/*  pow    v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

double _log(double x);                 /* Like log() with no error checking */

/****************************************************************************/
/*  POW() - Power							    */
/*									    */
/*  z = mantissa x							    */
/*  log2(z) = c1 * z ^ 9 + c2 * z ^ 7 + c3 * z ^ 5 + c4 * z ^ 3 + c5 * z    */
/*  log2(x) = exponent x + log2(z)					    */
/*  a = y * log2(x)							    */
/*  b = mantissa a							    */
/*  2 ^ b =  (((((d1 * b + d2) * b + d3) * b + d4) * b + d5) * b + d6)	    */
/*									    */
/*  result = 2 ^ exponent a * 2 ^ b					    */
/*	   = 2 ^ (y * log2(x))						    */
/****************************************************************************/
double pow(double x, double y)
{
    int z;

    if (x && y && y != 1.0)
    {
        int sign = 0;
	if (x < 0.0)
	{
	    z = (int) y;

	    /*****************************************************************/
	    /* if y is not an integer, a domain error occurs                 */
	    /*****************************************************************/
	    if (y - z) { errno = EDOM; return 0.0; }

	    /*****************************************************************/
	    /* if x < 0, compute the power of |x|                            */
	    /*****************************************************************/
	    x = -x;

	    /*****************************************************************/
	    /* for odd exponents, negate the answer                          */
	    /*****************************************************************/
	    sign = z % 2; 
	}

	x = exp(_log(x) * y);

	return (sign) ? -x : x;
    }

    if (y == 1.0) return (x);

    /**************************************************************************/
    /* if x = 0 and y < 0, return a domain error                              */
    /**************************************************************************/
    if (x == 0.0 && y <= 0.0) { errno = EDOM; return (0.0); }

    return (y == 0.0) ? 1.0 : 0.0;
}

printf.c/       1202506630  0     0     0       2875      `
/*****************************************************************************/
/*  PRINTF.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    PRINTF   -  Print formatted output to stdio                            */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 

/*****************************************************************************/
/* PRINTF   -  Print formatted output to stdio                               */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream stdio.            */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int printf(const char *_format, ...)
{
   va_list _ap;
   int rval;
   char *fptr = (char *)_format;
 
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(stdout->fd == -1) return (-1);

   va_start(_ap, _format);
   rval = _printfi(&fptr, _ap, (void *)stdout, _outc, _outs);
   va_end(_ap);
   return (rval);
}
 

/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


purev.cpp/      1202506630  0     0     0       860       `
/****************************************************************************/
/*  purev     v2.70                                                         */
/*  Copyright (c) 1996-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <cstdlib>

extern "C"
{
   void __pure_virtual_called(void);
}

/****************************************************************************/
/* __PURE_VIRTUAL_CALLED() - A PURE VIRTUAL FUNCTION HAS BEEN CALLED.       */
/*                           NOTIFY THE APPLICATION (WE JUST CALL ABORT FOR */
/*                           NOW).                                          */
/****************************************************************************/
void __pure_virtual_called(void)
{
   std::abort();
}

qsort.c/        1202506630  0     0     0       1830      `
/****************************************************************************/
/*  qsort v2.70                                                             */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>

static void swap_item(register char *src, 
                      register char *dest, 
                      register size_t size);

_CODE_ACCESS void qsort(void *base, size_t nmemb, size_t size, 
			int (*compar)(const void *, const void *))
{
   register char     *basep  = base;         /* POINTER TO ARRAY OF ELEMENTS */
   register unsigned  i      = 0;            /* left scan index  */
   register unsigned  j      = nmemb - 1;    /* right scan index */
   register unsigned  pivot  = (nmemb / 2);
   register char     *pivp   = basep + (pivot * size);

   if (nmemb <= 1) return;

   while( i < j )
   {
      while( (*compar) (basep + (i * size), pivp) < 0 ) ++i;
      while( (*compar) (basep + (j * size), pivp) > 0 ) --j;
      if( i < j )
      {
	 swap_item(basep + (i * size), basep + (j * size), size);
	 if     ( pivot == i ) { pivot = j; pivp = basep + (pivot * size); }
	 else if( pivot == j ) { pivot = i; pivp = basep + (pivot * size); } 
	 ++i; --j;
      }
      else if ( i == j ) { ++i; --j;  break; }
   }

   if( j > 0)       qsort(basep, j + 1, size, compar);
   if( i < nmemb-1) qsort(basep + (i * size), nmemb - i, size, compar);
}


static void swap_item(register char *src, 
                      register char *dest, 
                      register size_t size)
{
    while (size--)
    {
        register int temp = *src;       
        *src++            = *dest;
        *dest++           = temp;
    }
}

rand.c/         1202506630  0     0     0       928       `
/****************************************************************************/
/*  rand.c v2.70 							    */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <_lock.h>

/***************************************************************/
/* THIS IS AN IMPLEMENTATION WHICH IS INTENDED TO BE PORTABLE, */
/* AS PER THE ANSI STANDARD C SPECIFICATION                    */
/***************************************************************/
static _DATA_ACCESS unsigned long next = 1;

_CODE_ACCESS int rand(void)
{
     int r;
     _lock();
     next = next * 1103515245 + 12345;
     r = (int)((next/65536) % ((unsigned long)RAND_MAX + 1));
     _unlock();
     return r;
}

_CODE_ACCESS void srand(unsigned seed)
{
     _lock();
     next = seed;
     _unlock();
}
remove.c/       1202506630  0     0     0       1012      `
/*****************************************************************************/
/*  REMOVE.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    REMOVE   -  Erase a file                                               */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"


/*****************************************************************************/
/* REMOVE   -  Erase a file                                                  */
/*****************************************************************************/
_CODE_ACCESS int remove(const char *_file) { return (_remove(_file)); }

rewind.c/       1202506630  0     0     0       1080      `
/*****************************************************************************/
/*  REWIND.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    REWIND   -  Position a stream's file pointer to the beginning of a     */
/*                file                                                       */
/*****************************************************************************/
#include <stdio.h>


/*****************************************************************************/
/* REWIND   -  Position a stream's file pointer to the beginning of a file   */
/*****************************************************************************/
_CODE_ACCESS void  rewind(register FILE *_fp) { fseek(_fp, 0L, SEEK_SET); }


rtti.cpp/       1202506630  0     0     0       21359     `
/*****************************************************************************/
/* RTTI     v2.70                                                            */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef  __embedded_cplusplus

#include <cstdlib>
#include "rtti.h"


namespace {
/******************************************************************************/
/* D_TO_B_CONVERSION - Performs derived to base class conversions.            */
/*                                                                            */
/*  Converts objp from a pointer to a derived class (described by class_info) */
/*  to a pointer to a base class (described by base_info) and stores          */
/*  the resulting pointer in new_objp.  Returns TRUE if the base class was    */
/*  found and the conversion was done; otherwise returns FALSE.               */
/*                                                                            */
/*  objp may be NULL when this routine is called simply to determine whether  */
/*  the conversion is possible.  This is the case when exception              */
/*  specifications are being tested.                                          */
/*                                                                            */
/******************************************************************************/
int d_to_b_conversion(void**                     objp,
		      void**                     new_objp,
		      const std::TYPE_INFO_IMPL *class_info,
		      const std::TYPE_INFO_IMPL *base_info)
{
  bool                       found         = false;
  bool                       is_ambiguous  = false;
  bool                       is_accessible = false;
  bool                       last          = false;
  void                       *ptr           = objp ? *objp : NULL;
  const std::BASE_CLASS_SPEC *bcsp;

  /*--------------------------------------------------------------------------*/
  /* NO BASE CLASSES, THEN NO POSSIBILITY FOR CONVERSIONS.                    */
  /*--------------------------------------------------------------------------*/
  if (!class_info->bcs_entries)  return false;

  /*--------------------------------------------------------------------------*/
  /* LOOK THROUGH THE BASE CLASS LIST FOR A MATCH.  SEARCH FOR DIRECT BASES   */
  /* FIRST, SO THAT TOP LEVEL VIRTUAL BASE CLASSES ARE FOUND FIRST.           */
  /*--------------------------------------------------------------------------*/
  for (bcsp = class_info->bcs_entries, last = false;
       !last && !found && !is_ambiguous;
       last = bcsp->flags & BCS_LAST, bcsp++)
  {
     /*----------------------------------------------------------------------*/
     /* CHECK FOR A MATCH WITH THE DESIRED BASE CLASS.                       */
     /*----------------------------------------------------------------------*/
     if (std::matching_type_info(bcsp->type_info, base_info)) 
     {
	is_ambiguous  = bcsp->flags & BCS_AMBIGUOUS;
	is_accessible = bcsp->flags & BCS_PUBLIC;

	if (!is_ambiguous && is_accessible) 
	{
	   found = true;

	   if (ptr)
	   {
	      /*-------------------------------------------------------------*/
	      /* IF A VIRTUAL BASE CLASS, THE OFFSET PROVIDES THE LOCATION   */
	      /* OF A POINTER TO THE BASE CLASS.                             */
	      /*-------------------------------------------------------------*/
	      if (bcsp->flags & BCS_VIRTUAL)
		 *new_objp = *((void **)((char *)ptr + bcsp->offset));
	       
	      /*-------------------------------------------------------------*/
	      /* IF A NON-VIRTUAL BASE CLASS, THE OFFSET POINTS TO THE BASE  */
	      /* SUB-OBJECT.                                                 */
	      /*-------------------------------------------------------------*/
	      else
		 *new_objp = (void *)((char *)ptr + bcsp->offset);
	   }
	}
     }
  }

  /*--------------------------------------------------------------------------*/
  /* IF THE BASE CLASS WAS FOUND OR DETERMINED TO BE AMBIGUOUS, THEN RETURN   */
  /* THAT RESULT.                                                             */
  /*--------------------------------------------------------------------------*/
  if (is_ambiguous || found)  return found;

  /*--------------------------------------------------------------------------*/
  /* ELSE LOOK THROUGH INDIRECT BASE CLASSES FOR A MATCH.                     */
  /*--------------------------------------------------------------------------*/
  for (bcsp = class_info->bcs_entries, last = false;
       !last && !found;
       last = bcsp->flags & BCS_LAST, bcsp++)
  {
     void *b_objp     = ptr ? (void *)((char *)ptr + bcsp->offset) : NULL;
     void *new_b_objp = NULL;

     /*----------------------------------------------------------------------*/
     /* ENSURE THAT THE BASE CLASS HAS BASES AND THAT THE BASE CLASS IS      */
     /* ACCESSIBLE AND UNAMBIGUOUS.                                          */
     /*----------------------------------------------------------------------*/
     if (!bcsp->type_info->bcs_entries || (bcsp->flags & BCS_AMBIGUOUS) ||
	 !(bcsp->flags & BCS_PUBLIC))
	continue;

     /*---------------------------------------------------------------------*/
     /* NOW RECURSIVELY LOOK THROUGH THE BASE CLASSES OF THE BASE.          */
     /*---------------------------------------------------------------------*/
     if (d_to_b_conversion(&b_objp, &new_b_objp, bcsp->type_info, base_info))
     {	found = true;
	if (ptr)  *new_objp = new_b_objp;
     }
  }
     
  return found;
}

/******************************************************************************/
/* FIND_BASE_CLASS_AT_ADDR - Find base class for a given class pointer.       */
/*                                                                            */
/*  Find the base class specification entry that corresponds to the base      */
/*  class pointed to by "base_ptr", whose type is specified by "base_info"    */
/*  in the object pointed to by "obj_ptr".  The base class must be accessible,*/
/*  but need not be unambiguous.                                              */
/******************************************************************************/

static const std::BASE_CLASS_SPEC *find_base_class_at_addr(void  *obj_ptr,
                                       void                      *base_ptr,
                                       const std::TYPE_INFO_IMPL *obj_info,
                                       const std::TYPE_INFO_IMPL *base_info)
{
   const std::BASE_CLASS_SPEC *bcsp;
   void                 *new_ptr;
   bool                 done = false;

   for (bcsp = obj_info->bcs_entries; bcsp != NULL && !done;
                                done = (bcsp->flags & BCS_LAST) != 0, bcsp++)
   {
   /*-------------------------------------------------------------------------*/
   /* ADJUST THE POINTER BY THE OFFSET PROVIDED IN BASE CLASS SPECIFICATION   */
   /*-------------------------------------------------------------------------*/
       new_ptr = (void*) (((char *) obj_ptr) + bcsp->offset);

   /*-------------------------------------------------------------------------*/
   /* FOR A VIRTUAL BASE CLASS THE OFFSET PROVIDES THE LOCATION OF A POINTER  */
   /* TO THE BASE CLASS.  DEREFERENCE THE POINTER AND USE THAT VALUE.         */
   /*-------------------------------------------------------------------------*/
       if (bcsp->flags & BCS_VIRTUAL)
          new_ptr = *((void **)new_ptr);

   /*-------------------------------------------------------------------------*/
   /* IF BOTH THE ADDRESS AND TYPE MATCHES THEN WE FOUND A MATCH.             */
   /*-------------------------------------------------------------------------*/
       if (new_ptr == base_ptr &&
                                matching_type_info(bcsp->type_info, base_info))
          return bcsp;

   /*-------------------------------------------------------------------------*/
   /* NO MATCH, CHECK THE BASE CLASSES OF THIS BASE CLASS.                    */
   /*-------------------------------------------------------------------------*/

       if ((bcsp->flags & BCS_PUBLIC) != 0)
       {
           const std::BASE_CLASS_SPEC *result;
           result = find_base_class_at_addr(new_ptr, base_ptr,
                                       bcsp->type_info, base_info);
           if (result) return result;
       }
   }
   return NULL;
}

} // end namespace

/******************************************************************************/
/* DYN_CAST - Perform the dynamic_cast<> operation.                           */
/*                                                                            */
/*  This routine handles:                                                     */
/*    - casts of a polymorphic objects type to void*, which is defined as     */
/*      returning a pointer to the complete object type                       */
/*    - polymorphic base to derived casts                                     */
/*    - polymorphic cross casts                                               */
/*                                                                            */
/*  objp is the source operand of the cast.  If the source is                 */
/*  an object (and not a pointer) then a pointer to the source operand        */
/*  is used.  vtbl_ptr is a pointer to the virtual function table from        */
/*  the source operand.  class_info is a pointer to the TYPE_INFO_IMPL        */
/*  structure associated with the destination type.  If the source            */
/*  operand is being cast to void*, class_info will be NULL.                  */
/*                                                                            */
/*  srcp is the original pointer being cast.  It is different from objp if    */
/*  the original type did not have a virtual function table associated with   */
/*  it.  source_info is the type info pointer for the static type of the      */
/*  pointer being cast.  These parameters are used to check the access of the */
/*  base class associated with the pointer being cast.                        */
/*                                                                            */
/*  The information about the dynamic type of the source object is obtained   */
/*  from entry zero of the virtual function table.                            */
/*  Entry zero of the virtual function table is organized differently than the*/
/*  other table entries.  The information in that entry is provided to support*/
/*  the dynamic_cast and typeinfo operations.  Entry zero contains the        */
/*  following information:                                                    */
/*                                                                            */
/*  	delta:		The offset from the complete object pointer to        */
/*  			objp (i.e., the value to be subtracted from           */
/*  			objp to get the complete object pointer.              */
/*  	function:	Pointer to the typeinfo_impl structure that           */
/*  		        for the dynamic type of objp.                         */
/*                                                                            */
/******************************************************************************/
void *std::dyn_cast(void                 *objp,
		    const VTBL_ENTRY     *vtbl_ptr,
		    const TYPE_INFO_IMPL *class_info,
                    void                 *srcp,
                    const TYPE_INFO_IMPL *source_info)
{
   void                  *complete_objp;
   const TYPE_INFO_IMPL  *complete_class_info;

   /*-------------------------------------------------------------------------*/
   /* GET THE COMPLETE OBJECT.                                                */
   /*-------------------------------------------------------------------------*/
   complete_objp = (void *)((char *)objp - vtbl_ptr->first.delta);

   /*-------------------------------------------------------------------------*/
   /* GET THE TYPE OF THE COMPLETE OBJECT.                                    */
   /*-------------------------------------------------------------------------*/
   complete_class_info = (const TYPE_INFO_IMPL *)vtbl_ptr->first.class_info;

   /*-------------------------------------------------------------------------*/
   /* DO SOMETHING PREDICTABLE IF PARTS OF THE APPLICATION WERE COMPILED      */
   /* WITHOUT RTTI ENABLED.                                                   */
   /*-------------------------------------------------------------------------*/
   if (!complete_class_info)  throw_bad_cast();

   /*-------------------------------------------------------------------------*/
   /* IF class_info IS NULL, THE OBJECT POINTER IS BEING CAST TO VOID *, SO   */
   /* RETURN A POINTER TO THE COMPLETE OBJECT.                                */
   /*-------------------------------------------------------------------------*/
   if (!class_info)  return complete_objp;

   else 
   {
      bool      access_okay = true;
   /*-------------------------------------------------------------------------*/
   /* MAKE SURE THE BASE CLASS POINTED TO BY THE srcp IS AN ACCESSIBLE BASE   */
   /* CLASS. find_base_class_at_addr WILL RETURN NULL IF THE BASE CLASS IS AN */
   /* INDIRECT BASE CLASS OF A PRIVATE BASE CLASS.  IT WILL RETURN A POINTER  */
   /* TO THE BASE CLASS ENTRY IF IT IS A BASE CLASS OF AN ACCESSIBLE          */
   /* BASE CLASS (OR IF IT IS A DIRECT BASE CLASS).  CHECK THE RETURNED BASE  */
   /* CLASS ENTRY TO MAKE SURE THE BASE CLASS IS PUBLIC.  THE CONVERSIONS     */
   /* THAT FOLLOW ARE DONE ONLY IF THE SOURCE CLASS IS A PUBLIC BASE CLASS    */
   /*-------------------------------------------------------------------------*/
      if (class_info == source_info)
         access_okay = true;
      else
      {
         const std::BASE_CLASS_SPEC *bcsp;
         bcsp = find_base_class_at_addr (complete_objp, srcp,
                                          complete_class_info, source_info);
         access_okay = (bcsp != NULL) && ((bcsp->flags & BCS_PUBLIC) != 0);
      }

      if (access_okay)
      {
   /*-------------------------------------------------------------------------*/
   /* ELSE IF THE OBJECT POINTER IS BEING CAST TO THE TYPE OF THE COMPLETE    */
   /* OBJECT, RETURN A POINTER TO THE COMPLETE OBJECT.                        */
   /*-------------------------------------------------------------------------*/
         if (matching_type_info(complete_class_info, class_info))
            return complete_objp;

   /*-------------------------------------------------------------------------*/
   /* ELSE THE OBJECT POINTER IS BEING CAST TO THE TYPE OF A SUB-OBJECT OF    */
   /* THE OBJECT'S DYNAMIC TYPE.  IF THE TYPE IS ACCESSIBLE AND UNAMBIGUOUS,  */
   /* THEN RETURN A POINTER TO THE SUB-OBJECT OF THAT TYPE.                   */
   /*-------------------------------------------------------------------------*/
         else
         {
            void *new_objp = NULL;
            int   found    = d_to_b_conversion(&complete_objp, &new_objp,
                                         complete_class_info, class_info);

            return found ? new_objp : NULL;
         }
      }
   }
   return NULL;
}

/******************************************************************************/
/* DYN_CAST_REF - Interface to dyn_cast() for reference type casts.           */
/*                                                                            */
/*  An exception is thrown if the cast fails.                                 */
/*                                                                            */
/******************************************************************************/
void *std::dyn_cast_ref(void                 *objp,
			const VTBL_ENTRY     *vtbl_ptr,
			const TYPE_INFO_IMPL *class_info,
                        void                 *srcp,
                        const TYPE_INFO_IMPL *source_info)
{
   void *result = dyn_cast(objp, vtbl_ptr, class_info, srcp, source_info);

   if (!result) throw_bad_cast();

   return result;
}

/******************************************************************************/
/* GET_TYPEID - Returns the type_info object for a given polymorphic type.    */
/*                                                                            */
/******************************************************************************/
void *std::get_typeid(const VTBL_ENTRY *vtbl_ptr)
{
   const TYPE_INFO_IMPL *class_info;

   if (!vtbl_ptr)  throw_bad_typeid();

   class_info = (const TYPE_INFO_IMPL *)vtbl_ptr->first.class_info;

   /*-------------------------------------------------------------------------*/
   /* DO SOMETHING PREDICTABLE IF PARTS OF THE APPLICATION WERE COMPILED      */
   /* WITHOUT RTTI ENABLED.                                                   */
   /*-------------------------------------------------------------------------*/
   if (!class_info)  throw_bad_typeid();

   return (void*)&class_info->user_type_info;
}

/******************************************************************************/
/* THROW_BAD_CAST - Throws a bad cast exception.                              */
/******************************************************************************/
void std::throw_bad_cast(void)
{
   // throw bad_cast();
   abort();  // For now, just call abort
}

/******************************************************************************/
/* THROW_BAD_TYPEID - Throws a bad typeid exception.                          */
/******************************************************************************/
void std::throw_bad_typeid(void)
{
   // throw bad_typeid();
   abort();  // For now, just call abort
}

#include <cstdio>
/******************************************************************************/
/* DUMP_TYPE_INFO - Dumps debug info about the given type representation.     */
/******************************************************************************/
void std::dump_type_info(const type_info& info)
{
   /*-------------------------------------------------------------------------*/
   /* GET THE INTERNAL REPRESENTATION OF THE TYPE.  WE DEPEND UPON THE FACT   */
   /* THAT THE USER VISIBLE TYPE_INFO IS THE FIRST MEMBER OF THIS STRUCTURE.  */
   /*-------------------------------------------------------------------------*/
   const TYPE_INFO_IMPL *class_info = (const TYPE_INFO_IMPL *)&info;

   /*-------------------------------------------------------------------------*/
   /* NOW OUTPUT LOTS OF USEFUL INFORMATION.  START WITH THE TYPE ITSELF.     */
   /*-------------------------------------------------------------------------*/
   fprintf(stderr, "\n*********************************************\n");
   fprintf(stderr, "Type information for: %s\n",
	   class_info->name ? class_info->name : "<NULL>");
   fprintf(stderr, "  flags       :");
   if (class_info->flags & TIF_LOCAL)  fprintf(stderr, " local");
   fprintf(stderr, "\n");

   /*-------------------------------------------------------------------------*/
   /* AND THEN INFO ABOUT ITS BASE CLASSES, IF THERE ARE ANY.                 */
   /*-------------------------------------------------------------------------*/
   if (class_info->bcs_entries)
   {
      const BASE_CLASS_SPEC *bcsp;
      bool                   last;

      /*----------------------------------------------------------------------*/
      /* OUTPUT INFO ABOUT THE TYPE'S INHERITANCE.                            */
      /*----------------------------------------------------------------------*/
      fprintf(stderr, "  base classes:\n");

      for (bcsp = class_info->bcs_entries, last = false;
       !last;
       last = bcsp->flags & BCS_LAST, bcsp++)
      {
	 char	*name = bcsp->type_info->name;

	 fprintf(stderr, "    name=%s\n", name ? name : "<NULL>");
	 fprintf(stderr, "    offset=%0ld\n", (long)bcsp->offset);
	 fprintf(stderr, "    flags:");
	 if (bcsp->flags & BCS_VIRTUAL)   fprintf(stderr, " virtual");
	 if (bcsp->flags & BCS_LAST)      fprintf(stderr, " last");
	 if (bcsp->flags & BCS_PUBLIC)    fprintf(stderr, " public");
	 if (bcsp->flags & BCS_AMBIGUOUS) fprintf(stderr, " ambiguous");
	 if (bcsp->flags & BCS_DIRECT)    fprintf(stderr, " direct");
	 fprintf(stderr, "\n");
      }

      /*----------------------------------------------------------------------*/
      /* OUTPUT INFO ABOUT THE TYPE'S DIRECT BASE CLASSES.                    */
      /*----------------------------------------------------------------------*/
      for (bcsp = class_info->bcs_entries, last = false;
       !last;
       last = bcsp->flags & BCS_LAST, bcsp++)
	 if (bcsp->flags & BCS_DIRECT) 
	    dump_type_info(bcsp->type_info->user_type_info);
   }

   fprintf(stderr, "*********************************************\n");
}

#endif

rtti.h/         1202506630  0     0     0       4015      `
/*****************************************************************************/
/* RTTI.H     v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _RTTI
#define _RTTI

#ifndef  __embedded_cplusplus

#include <typeinfo>
#include <vtbl.h>

/******************************************************************************/
/* Definitions for the type_info_impl flags:                                  */
/*    TIF_LOCAL  - The type_info_impl variable was local                      */
/******************************************************************************/
#define TIF_LOCAL 0x01

/******************************************************************************/
/* Definitions for the base class specification flags:                        */
/*    BCS_NO_FLAGS   - No flags are set.                                      */
/*    BCS_VIRTUAL    - Base class is virtual.                                 */
/*    BCS_LAST       - This is the last base class in the array.              */
/*    BCS_PUBLIC     - Base class is public (Applies to non-direct bases).    */
/*    BCS_AMBIGUOUS  - Base class is ambiguous                                */
/*    BCS_DIRECT     - Base class is direct.                                  */
/******************************************************************************/
#define BCS_NO_FLAGS	0x00
#define BCS_VIRTUAL	0x01
#define BCS_LAST	0x02
#define BCS_PUBLIC      0x04
#define BCS_AMBIGUOUS	0x08
#define BCS_DIRECT	0x10

namespace std
{
   /***************************************************************************/
   /* Internal type information structure.                                    */
   /***************************************************************************/
   typedef struct type_info_impl
   {
      type_info               user_type_info;    /* User visible type_info    */
      char                   *name;              /* Name of the type          */
      unsigned int            flags;             /* Flags                     */
      const struct base_class_spec *bcs_entries; /* Array of base class specs */
   } TYPE_INFO_IMPL;

   /***************************************************************************/
   /* Base class specification, used in internal type information structure.  */
   /***************************************************************************/
   typedef struct base_class_spec
   {
      const TYPE_INFO_IMPL *type_info;  /* The type_info for the base class */
      short           offset;      /* Offset of base class in derived class */
      char            flags;       /* Base class specification flags        */
   } BASE_CLASS_SPEC;

   /***************************************************************************/
   /* PROTOTYPES FOR RTTI INTERNAL ROUTINES.                                  */
   /***************************************************************************/
   bool  matching_type_info (const TYPE_INFO_IMPL *cti1,
			     const TYPE_INFO_IMPL *cti2);
   void *dyn_cast           (void                 *objp,
			     const VTBL_ENTRY     *vtbl_ptr,
			     const TYPE_INFO_IMPL *class_info,
                             void                 *srcp,
                             const TYPE_INFO_IMPL *source_info);
   void *dyn_cast_ref       (void                 *objp,
			     const VTBL_ENTRY     *vtbl_ptr,
			     const TYPE_INFO_IMPL *class_info,
                             void                 *srcp,
                             const TYPE_INFO_IMPL *source_info);
   void *get_typeid         (const VTBL_ENTRY *vtbl_ptr);
   void  throw_bad_cast     (void);
   void  throw_bad_typeid   (void);
   void  dump_type_info     (const type_info& info);
}

#endif /* __embedded_cplusplus */
#endif /* _RTTI */

setbuf.c/       1202506630  0     0     0       1380      `
/*****************************************************************************/
/*  SETVBUF.C v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SETBUF   -  Set the default buffering mode for a stream                */
/*****************************************************************************/
#include <stdio.h>
 

/*****************************************************************************/
/* SETBUF   -  Set the default buffering mode for a stream                   */
/*                                                                           */
/*    This function calls SETVBUF, and sets the buffering mode to non-       */
/*    buffered if _BUF is NULL, or fully-buffered if _BUF is not NULL.       */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS void setbuf(register FILE *_fp, char *_buf)
{
   setvbuf(_fp, _buf, _buf ? _IOFBF : _IONBF, BUFSIZ);
   return;
}
 

setjmp.h/       1202506630  0     0     0       1015      `
/*****************************************************************************/
/* setjmp.h   v2.70                                                          */
/* Copyright (c) 1993-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _SETJMP
#define _SETJMP

#include <linkage.h>

#ifdef __cplusplus
extern "C" namespace std {
#endif

#define setjmp(x) _setjmp(x)

    typedef int jmp_buf[10];

_CODE_ACCESS int  _setjmp(jmp_buf env); 
_CODE_ACCESS void longjmp(jmp_buf env, int val);

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::jmp_buf;
using std::_setjmp;
using std::longjmp;
#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::jmp_buf;
using std::_setjmp;
using std::longjmp;
#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif /* _SETJMP */

setjmp16.asm/   1202506630  0     0     0       2615      `
;******************************************************************************
;* SETJMP - 16 BIT STATE -  v2.70                                             *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;*   setjmp
;*
;*     C syntax  : int setjmp(jmp_buf env)
;*
;*     Function  : Save callers current environment for a subsequent
;*                 call to longjmp.  Return 0.
;*
;*     The context save area is organized as follows:
;*
;*       env -->  .long  V1
;*                .long  V2
;*                .long  V3
;*                .long  V4
;*                .long  V5
;*                .long  V6
;*                .long  V7
;*                .long  V8
;*                .long  SP
;*                .long  LR
;*
;****************************************************************************
;*
;*  NOTE : ANSI specifies that "setjmp.h" declare "setjmp" as a macro. 
;*         In our implementation, the setjmp macro calls a function "_setjmp".
;*         However, since the user may not include "setjmp.h", we provide
;*         two entry-points to this function.
;*
;****************************************************************************
	.state16

	.global	$setjmp
	.global $_setjmp

$setjmp: .asmfunc stack_usage(40)
$_setjmp:
	STMIA	A1!, {V1, V2, V3, V4}
	MOV	A2, V5
	MOV	A3, V6
	MOV	A4, V7
	MOV	V1, V8
	MOV	V2, SP
	MOV	V3, LR
	STMIA	A1!, {A2, A3, A4, V1, V2, V3}
	SUB	A1, #40
	LDMIA	A1!, {V1, V2, V3, V4}
	MOV     A1,#0
	MOV	PC, LR
	.endasmfunc

;****************************************************************************
;*   longjmp
;*
;*     C syntax  : void longjmp(jmp_buf env, int val)
;*
;*     Function  : Restore the context contained in the jump buffer.
;*                 This causes an apparent "2nd return" from the
;*                 setjmp invocation which built the "env" buffer.
;*                 This return appears to return "returnvalue".
;*                 NOTE: This function may not return 0.
;****************************************************************************
	.state16

	.global	$longjmp

$longjmp: .asmfunc stack_usage(24)
	ADD	A1, #16
	LDMIA	A1!, {A3, A4, V1, V2, V3, V4}
	MOV	V5, A3
	MOV	V6, A4
	MOV	V7, V1
	MOV	V8, V2
	MOV	SP, V3
	MOV     LR, V4
	SUB	A1, #40
	LDMIA	A1!, {V1, V2, V3, V4}
	CMP	A2, #0
	BNE	_ct_
	MOV	A2, #1
_ct_:	MOV	A1, A2
	BX	LR
	.endasmfunc

	.end

setjmp32.asm/   1202506631  0     0     0       2300      `
;******************************************************************************
;* SETJMP - 32 BIT STATE -  v2.70                                             *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;*   setjmp
;*
;*     C syntax  : int setjmp(jmp_buf env)
;*
;*     Function  : Save callers current environment for a subsequent
;*                 call to longjmp.  Return 0.
;*
;*     The context save area is organized as follows:
;*
;*       env -->  .long  V1
;*                .long  V2
;*                .long  V3
;*                .long  V4
;*                .long  V5
;*                .long  V6
;*                .long  V7
;*                .long  V8
;*                .long  SP
;*                .long  LR
;*
;****************************************************************************
;*
;*  NOTE : ANSI specifies that "setjmp.h" declare "setjmp" as a macro. 
;*         In our implementation, the setjmp macro calls a function "_setjmp".
;*         However, since the user may not include "setjmp.h", we provide
;*         two entry-points to this function.
;*
;****************************************************************************
	.state32

	.global _setjmp
	.global __setjmp

_setjmp: .asmfunc stack_usage(40)
__setjmp:
	STMIA	A1!, {V1 - V8, SP, LR}
	MOV     A1,#0
	MOV	PC, LR
	.endasmfunc


;****************************************************************************
;*   longjmp
;*
;*     C syntax  : void longjmp(jmp_buf env, int val)
;*
;*     Function  : Restore the context contained in the jump buffer.
;*                 This causes an apparent "2nd return" from the
;*                 setjmp invocation which built the "env" buffer.
;*                 This return appears to return "returnvalue".
;*                 NOTE: This function may not return 0.
;****************************************************************************
	.state32

 	.global	_longjmp

_longjmp: .asmfunc stack_usage(40)
	LDMIA	A1!, {V1 - V8, SP, LR}
	CMP	A2, #0
	MOVEQ	A1, #1
	MOVNE	A1, A2
	BX	LR

	.end
	.endasmfunc
setvbuf.c/      1202506631  0     0     0       4134      `
/*****************************************************************************/
/*  SETVBUF.C  v2.70                                                         */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SETVBUF  -  Set the buffering mode for a stream                        */
/*****************************************************************************/
#include <stdio.h>
#include <stdlib.h>

extern void   _cleanup();
extern _DATA_ACCESS void (*_cleanup_ptr)(void);


/*****************************************************************************/
/* SETVBUF  -  Set the buffering mode for a stream                           */
/*                                                                           */
/*    This function sets the buffering mode for a stream, and allocates a    */
/*    buffer for it if necessary.                                            */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int setvbuf(register FILE *_fp, register char *_buf,
			 register int _type, register size_t _size)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1 || (_type != _IONBF && _size <= 0)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If a buffer already exists, free it if it was malloc'd, and reset all  */
   /* of the stream's buffer pointers.                                       */
   /*------------------------------------------------------------------------*/
   if(_fp->buf)
   {
      if(_STCHK(_fp, _BUFFALOC)) free((_fp->buf)-1);
      _UNSET(_fp, _BUFFALOC);
      _fp->buf = NULL;
      _fp->pos = NULL;
      _fp->bufend = NULL;
      _fp->buff_stop = NULL;
   }

   /*------------------------------------------------------------------------*/
   /* If NULL was used for the buffering mode, default to fully-buffered.    */
   /*------------------------------------------------------------------------*/
   if(! _type) _type = _IOFBF;

   /*------------------------------------------------------------------------*/
   /* Clear any previous buffering flags, and set the new one.               */
   /*------------------------------------------------------------------------*/
   _UNSET(_fp, (_IOLBF | _IOFBF | _IONBF));
   _SET(_fp, _type);

   /*------------------------------------------------------------------------*/
   /* If a buffer was provided, but its size is only one byte, allocate a    */
   /* different one.  Also, do not allow a buffer size greater than BUFSIZ.  */
   /* The buffer will always have one space at the beginning that is         */
   /* for UNGETC, in the event that an UNGETC is performed on an empty file, */
   /* or when the buffer is full, but unread.                                */
  /*------------------------------------------------------------------------*/
   if(_size == 1) _buf = NULL;
   if(_size > BUFSIZ-1) _size = BUFSIZ -1;
   _size++;

   if (_buf) _fp->pos = _fp->buf = (unsigned char*)_buf+1;
   else
   {
      if (! (_fp->pos = _fp->buf = (unsigned char*)malloc(_size))) return (EOF);
      _fp->pos++;
      _fp->buf++;
      _SET(_fp, _BUFFALOC);
   }

   _fp->bufend = _fp->buf + _size -1;

   /*------------------------------------------------------------------------*/
   /* SETUP _CLEANUP_PTR SO ALL BUFFERS WILL BE FLUSHED AT EXIT.             */
   /*------------------------------------------------------------------------*/
   _cleanup_ptr = _cleanup;

   return (0);
}

sin.c/          1202506631  0     0     0       2529      `
/****************************************************************************/
/*  sin    v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  SIN() - sine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 8.              */
/*									    */
/*  N = round(x / PI)							    */
/*  f = x - N * PI							    */
/*  g = f * f								    */
/*  R = polynomial expansion 						    */
/*									    */
/*  result = f + f * R							    */
/*									    */
/*  if x < 0, result = - result 					    */
/*  if N is even, result = - result					    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double sin(double x)
{
    double xn, f, g, rg, result;
    int    sign = (x < 0); 
    int    n;

    x  = fabs(x);
    n  = (int) ((x * INVSPI) + 0.5);
    xn = (double) n;

    /*************************************************************************/
    /* if n is odd, negate the sign                                          */
    /*************************************************************************/
    sign ^= n % 2; 

    /*************************************************************************/
    /* f = x - xn * PI (but mathematically more stable)                      */
    /*************************************************************************/
    f = (x - xn * C1) - xn * C2;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    g = f * f;

#if BITS<=24
    rg = (((R4 * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=25 && BITS<=32
    rg = ((((R5 * g + R4) * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=33 && BITS<=50
    rg = ((((((R7*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#else
    rg = (((((((R8*g+R7)*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#endif

    result = f + f * rg;
    return sign ? -result : result; 
}

sinh.c/         1202506631  0     0     0       4459      `
/****************************************************************************/
/*  sinh   v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  SINH() - Hyberbolic Sine						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 12.             */
/*									    */
/*  result = (exp(x) - 1 / exp(x)) / 2					    */
/*  if x < 0, result = - result 					    */
/*  if abs(x) <=1, R = polynomial expansion; result = x + x^3 * R           */
/*  if abs(x) >1, result = (exp(x) - 1/exp(x))/2                            */
/****************************************************************************/
double sinh(double x)
{
    double g, z, q, p, r, a, b, result;
    int sign = x < 0;
    int    n;

    if ((x = fabs(x)) <= 1.0)
    {
      g = x * x;

      /************************************************************************/
      /* determine polynomial expression                                      */
      /************************************************************************/
#if BITS<=24
      p = SHP1 * g + SHP0;
      q = g + SHQ0;
#elif BITS>=25 && BITS<=40
      p = (SHP2 * g + SHP1) * g + SHP0;
      q = (g + SHQ1) * g + SHQ0;
#elif BITS>=41 && BITS<=50
      p = ((SHP3 * g + SHP2) * g + SHP1) * g + SHP0;
      q = (g + SHQ1) * g + SHQ0;
#else
      p = ((SHP3 * g + SHP2) * g + SHP1) * g + SHP0;
      q = ((g + SHQ2) * g + SHQ1) * g + SHQ0;
#endif

      result = x + x * g * (p / q);
      return sign ? -result : result; 
    }

    /**************************************************************************/
    /* check to see if overflow would occur                                   */
    /**************************************************************************/
    if (x > MAXH) { errno = ERANGE; return (sign ? -HUGE_VAL : HUGE_VAL); }

    if (x < 0) n = (int) (x * INVLOGe2 - 0.5);   /* since (int) -1.5 = -1.0 */
    else       n = (int) (x * INVLOGe2 + 0.5);

    /**************************************************************************/
    /* g = x - n * ln(2) (but more mathematically stable)                     */
    /**************************************************************************/
    g = (x - n * C3) - n * C4;

    /**************************************************************************/
    /* determine polynomial expression                                        */
    /**************************************************************************/
    z = g * g;

#if BITS <=29
    p = (EXP1 * z + EXP0) * g;
    q = EXQ1 * z + EXQ0;
#elif BITS>=30 && BITS<=42
    p = (EXP1 * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#elif BITS>=43 && BITS<=56
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#else
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = ((EXQ3 * z + EXQ2) * z + EXQ1) * z + EXQ0;
#endif

    /**************************************************************************/
    /* calculate exp(g)                                                       */
    /**************************************************************************/
    r = 0.5 + p / (q - p);

    /**************************************************************************/
    /* exp(x)/2 = exp(g) * 2 ^ n                                              */
    /**************************************************************************/
    a = ldexp(r, n);

    /**************************************************************************/
    /* exp(-x)*2 = 1 / (exp(x)/2)                                             */
    /**************************************************************************/
    b = 1.0 / a;

    /**************************************************************************/
    /* sinh(x) = (exp(x)/2 - (exp(-x)*2)/4) * sign(x)                         */
    /**************************************************************************/
    result = a - b * 0.25;
    return sign ? -result : result; 
}

sinit.c/        1202506631  0     0     0       3351      `
/****************************************************************************/
/*  sinit     v2.70                                                         */
/*  Copyright (c) 1996-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>

extern void _DATA_ACCESS (*_dtors_ptr)(void);

/*************************************************************************/
/* LIST OF REQUIRED STATIC DESTRUCTIONS.  object POINTS TO THE OBJECT    */
/* TO BE DESTROYED, OR NULL IF THERE ARE SEVERAL.  dtor IS THE           */
/* DESTRUCTOR FOR THE OBJECT, AND dfun IS A FUNCTION THAT WILL CALL ALL  */
/* OF THE DESTRUCTORS IS THERE ARE SEVERAL.  ALWAYS ADD TO THE HEAD OF   */
/* THE LIST TO ENSURE THE PROPER ORDER OF DESTRUCTION.                   */
/*************************************************************************/
typedef struct dtor_list
{
   struct dtor_list *next;
   void             *object;
   union
   {
      void  (*dtor)(void *, int);
      void  (*dfun)(void);
   } fun;
} DTOR_LIST;

DTOR_LIST *dtors = NULL;
	 
/****************************************************************************/
/* CALL_DTORS() - PERFORM STATIC DESTRUCTION.                               */
/****************************************************************************/
void call_dtors(void)
{
   while (dtors)
   {
      /*-----------------------------------------------------------------*/
      /* SINCE A DESTRUCTOR MAY ADD NEW DESTRUCTORS TO THE LIST, NOTE    */
      /* AND REMOVE THE HEAD OF THE DESTRUCTOR LIST NOW.                 */
      /*-----------------------------------------------------------------*/
      DTOR_LIST *curr_dtor = dtors;
      dtors = dtors->next;

      /*-----------------------------------------------------------------*/
      /* IF A SINGLE OBJECT, CALL ITS DESTRUCTOR ON ITSELF (A FLAG VALUE */
      /* OF 2 INDICATES THAT OPERATOR DELETE SHOULD NOT BE CALLED).      */
      /* IF MULTIPLE OBJECTS, CALL THE SUPPLIED FUNCTION TO DESTROY THEM */
      /* ALL.                                                            */
      /*-----------------------------------------------------------------*/
      if (curr_dtor->object)  curr_dtor->fun.dtor(curr_dtor->object, 2);
      else                    curr_dtor->fun.dfun();
   }
}

/****************************************************************************/
/* ADD_DTOR() - ADD A DESTRUCTOR TO THE LIST OF STATIC DESTRUCTIONS.        */
/****************************************************************************/
void __add_dtor(DTOR_LIST *dtor_entry)
{
   /*-----------------------------------------------------------------------*/
   /* REGISTER call_dtors() SO exit() WILL CALL IT.  call_dtors() ISN'T     */
   /* CALLED DIRECTLY FROM exit() SO THAT IT ISN'T LINKED IN IF NOT USED.   */
   /*-----------------------------------------------------------------------*/
   _dtors_ptr = call_dtors;

   /*-----------------------------------------------------------------------*/
   /* ADD THE DESTRUCTOR TO THE LIST.                                       */
   /*-----------------------------------------------------------------------*/
   dtor_entry->next = dtors;
   dtors = dtor_entry;
}

snprintf.c/     1202506631  0     0     0       3272      `
/*****************************************************************************/
/*  SNPRINTF.C v2.70                                                         */
/*  Copyright (c) 2001-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SNPRINTF -  Copy formatted output to a string                          */
/*    _OUTC    -  Put a character in a string                                */
/*    _OUTS    -  Append a string to another string                          */
/*****************************************************************************/
#include <stdio.h>
#include <format.h>
#include <stdarg.h>
#include <string.h>

extern int _printfi(char **_format, va_list _ap, void *_op,
		    int (*_outc)(char, void *), int (*_outs)(char *, void *));

static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);

struct holder {
    char  *out_end;
    size_t n;
    size_t written;
};

/*****************************************************************************/
/* SNPRINTF  -  Copy formatted output to a string                            */
/*                                                                           */
/*    This function passes a format string and an argument list to           */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int snprintf(char *_string, size_t _n, const char *_format, ...)
{
    va_list _ap;
    int    rval;
    char  *fptr = (char *)_format;
    struct holder holder; 

    holder.out_end = _string;
    holder.n       = _n;
    holder.written = 0;

    va_start(_ap, _format);
    rval = _printfi(&fptr, _ap, (void *)&holder, _outc, _outs);
    va_end(_ap);

    if (_n) *holder.out_end = '\0';

    return rval;
}

/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
    struct holder *holder = (struct holder *)_op;
    
    if (holder->written < holder->n)
	*holder->out_end++ = c;

    holder->written++;

    return c;
}

/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
    struct holder *holder = (struct holder *)_op;
    size_t len = strlen(s);

    if (holder->written < holder->n)
    {
	size_t space = holder->n - holder->written;
	size_t use = len > space ? space : len;
	memcpy(holder->out_end, s, use);
	holder->out_end += use;
    }
    
    holder->written += len;

    return len;
}
sprintf.c/      1202506631  0     0     0       2736      `
/*****************************************************************************/
/*  SPRINTF.C v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SPRINTF  -  Copy formatted output to a string                          */
/*    _OUTC    -  Put a character in a string                                */
/*    _OUTS    -  Append a string to another string                          */
/*****************************************************************************/
#include <stdio.h>
#include <format.h>
#include <stdarg.h>
#include <string.h>

extern int _printfi(char **_format, va_list _ap, void *_op,
		    int (*_outc)(char, void *), int (*_outs)(char *, void *));

static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);

/*****************************************************************************/
/* SPRINTF  -  Copy formatted output to a string                             */
/*                                                                           */
/*    This function passes a format string and an argument list to           */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int sprintf(char *_string, const char *_format, ...)
{
    va_list _ap;
    int   rval;
    char *fptr = (char *)_format;
    char *out_end = _string;

    va_start(_ap, _format);
    rval = _printfi(&fptr, _ap, (void *)&out_end, _outc, _outs);
    va_end(_ap);

    *out_end = '\0';

    return (rval);
}

/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
    return *(*((char **)_op))++ = c;
}

/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
    size_t len = strlen(s);

    memcpy(*((char **)_op), s, len);
    *((char **)_op) += len;
    return len;
}
sqrt.c/         1202506631  0     0     0       2264      `
/****************************************************************************/
/*  sqrt   v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <errno.h>
#include "values.h"

/***************************************************************************/
/* SQRT() - Square Root                                                    */
/*   Computes square root of x using a Newton-Raphson approximation for    */
/*   sqrt(1/x).  Initial value x0 = .75 * 2 ^ -(e/2), where x = a * 2 ^ e. */
/***************************************************************************/

double sqrt(double x)
{
    double x0;          /* estimate */
    int exp;

    /************************************************************************/
    /* Check to see if the input is not in the function's domain.           */
    /************************************************************************/
    if (x <= 0.0)
    {
      if (x < 0.0) errno = EDOM;
      return (0.0);
    }

    /************************************************************************/
    /* initial estimate = .75 * 2 ^ -(exp/2)                                */
    /************************************************************************/
    exp = ( (*((unsigned long *) &x) >> 20) & 0x7FF) - 1023;
    x0  = ldexp(0.75, -exp / 2);

    /************************************************************************/
    /* Refine estimate                                                      */
    /************************************************************************/
    x0 *= (1.5 - x * 0.5 * x0 * x0);
    x0 *= (1.5 - x * 0.5 * x0 * x0);
    x0 *= (1.5 - x * 0.5 * x0 * x0);
    x0 *= (1.5 - x * 0.5 * x0 * x0);
    x0 *= (1.5 - x * 0.5 * x0 * x0);
    x0 *= (1.5 - x * 0.5 * x0 * x0);

    /************************************************************************/
    /* sqrt(x) = x * sqrt(1/x)                                              */
    /************************************************************************/
    return (x0 * x);
}
sscanf.c/       1202506631  0     0     0       4330      `
/*****************************************************************************/
/*  SSCANF.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    SSCANF      -  Read formatted input from a string                      */
/*    _INPCHAR    -  Get a character from the string                         */
/*    _UNINPCHAR  -  Put a character back onto the string                    */
/*    _CHKMBC     -  Check that the characters match the input               */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

static int _inpchar(void **inp);
static void _uninpchar(void **inp, int outchar);
static int _chkmbc(void **inp, char **_format, int *num_read);

/*****************************************************************************/
/* SSCANF   -  Read formatted input from a string                            */
/*                                                                           */
/*    This function returns the number of arguments that were assigned a     */
/*    value.                                                                 */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int sscanf(const char *_str, const char *_fmt, ...)
{
   va_list _ap;
   va_start(_ap, _fmt);

   return (_scanfi((void *)_str, _fmt, _ap, _chkmbc, _inpchar, _uninpchar));
}

/*****************************************************************************/
/* _INPCHAR -  Get a character from the string                               */
/*****************************************************************************/
static int _inpchar(void **inp)
{
   char result;
   char *buf = (char *)(*inp);

   result = *(buf++);
   *inp = (void *)buf;  

   return ((result == '\0') ? EOF : result);
}

/*****************************************************************************/
/* _UNINPCHAR  -  Put a character back into the string                       */
/*****************************************************************************/
static void _uninpchar(void **inp, int outchar)
{
   char *buf = (char *)(*inp);
   buf--;
   *inp = (void *)buf;  
   return;
}

/*****************************************************************************/
/* _CHKMBC  -  Check that the characters match the input                     */
/*                                                                           */
/*    Check that all characters in the format string that are not part of a  */
/*    conversion specification match the input, until the next '%' or the    */
/*    end of the format string is reached.  The function returns a 0 upon    */
/*    reaching the end of the format string or a mismatch, or a 1 if a '%'   */
/*    is encountered.                                                        */
/*                                                                           */
/*****************************************************************************/
static int _chkmbc(void **inp, char **_format, int *num_read)
{
   char *buf = (char *)*inp;

   /*------------------------------------------------------------------------*/
   /* If there is a white space character in the format statement, skip to   */
   /* the next non-white space character in the input.                       */
   /*------------------------------------------------------------------------*/
   while(isspace(**_format))
   {
      for(;isspace(*buf); buf++) (*num_read)++;
      (*_format)++;
   }

   for(;(**_format != '%') && (**_format != '\0');)
      if(*((*_format)++) != *(buf++)) return (0);
      else (*num_read)++;

   if(**_format == '%')
   {
      *inp = (void *)buf;
       return 1;
   }
   else return (0);
}
stdarg.h/       1202506631  0     0     0       2269      `
/*****************************************************************************/
/* stdarg.h   v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STDARG
#define _STDARG

#ifdef __cplusplus
#define _NS_PREFIX std::
namespace std {
#else
#define _NS_PREFIX
#endif /* __cplusplus */

typedef char *va_list;

#ifdef __cplusplus
} /* namespace std */
#endif

#define va_start(ap, parmN)                                                   \
   ((ap) = (!__va_argref(parmN) && sizeof(parmN) == sizeof(double)            \
	    ? (_NS_PREFIX va_list)((int)__va_parmadr(parmN) + 8)              \
            : (!__va_argref(parmN) && sizeof(parmN) <= sizeof(short))         \
            ? (_NS_PREFIX va_list)((int)__va_parmadr(parmN) + 4 & ~3)         \
            : (_NS_PREFIX va_list)((int)__va_parmadr(parmN) + 4 )))


#ifdef __big_endian__
#define va_arg(_ap, _type)                                                    \
        (__va_argref(_type)                                                   \
	 ? ((_ap += sizeof(_type*)),(**(_type**)(_ap-(sizeof(_type*)))))      \
         : ((sizeof(_type) == sizeof(double)                                  \
             ? ((_ap += 8), (*(_type *)(_ap - 8)))                            \
             : ((_ap += 4), (*(_type *)(_ap - (sizeof(_type))))))))
#else
#define va_arg(_ap, _type)                                                    \
        (__va_argref(_type) 						      \
	 ? ((_ap += sizeof(_type*)),(**(_type**)(_ap-(sizeof(_type*)))))      \
         : ((sizeof(_type) == sizeof(double)                                  \
             ? ((_ap += 8), (*(_type *)(_ap - 8)))                            \
             : ((_ap += 4), (*(_type *)(_ap - 4))))))
#endif

#define va_end(ap)

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::va_list;
#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::va_list;
#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif /* _STDARG */

stddef.h/       1202506631  0     0     0       1167      `
/*****************************************************************************/
/* stddef.h   v2.70                                                          */
/* Copyright (c) 1993-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STDDEF
#define _STDDEF

#ifdef __cplusplus
extern "C" namespace std {
#endif

#ifndef NULL
#define NULL 0
#endif

typedef int ptrdiff_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned int size_t;
#endif

#ifndef __cplusplus
#ifndef _WCHAR_T
#define _WCHAR_T

typedef unsigned short wchar_t;

#endif /* _WCHAR_T */
#endif /* ! __cplusplus */

#define offsetof(_type, _ident) ((size_t)__intaddr__(&(((_type *)0)->_ident)))

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::ptrdiff_t;
using std::size_t;
/*using std::wchar_t;*/
#endif

#endif  /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::ptrdiff_t;
using std::size_t;
/*using std::wchar_t;*/
#endif

#endif  /* __cplusplus */

#endif  /* _STDDEF */

stdexcept/      1202506631  0     0     0       376       `
/*****************************************************************************/
/* stdexcept  v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STDEXCEPT
#define _STDEXCEPT

#endif
stdint.h/       1202506631  0     0     0       4668      `
/*****************************************************************************/
/* STDINT.H v2.70                                                            */
/* Copyright (c) 2002-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _STDINT_H_
#define _STDINT_H_

/* 7.18.1.1 Exact-width integer types */

    typedef   signed char   int8_t;
    typedef unsigned char  uint8_t;
    typedef          short  int16_t;
    typedef unsigned short uint16_t;
    typedef          int    int32_t;
    typedef unsigned int   uint32_t;


    typedef          long long  int64_t;
    typedef unsigned long long uint64_t;

/* 7.18.1.2 Minimum-width integer types */

    typedef  int8_t   int_least8_t;
    typedef uint8_t  uint_least8_t;

typedef  int16_t  int_least16_t;
typedef uint16_t uint_least16_t;
typedef  int32_t  int_least32_t;
typedef uint32_t uint_least32_t;


    typedef  int64_t  int_least64_t;
    typedef uint64_t uint_least64_t;
/* sorry, int_least64_t not implemented for C2000, C54x, C55x, C6x */

/* 7.18.1.3 Fastest minimum-width integer types */

    typedef  int32_t  int_fast8_t;
    typedef uint32_t uint_fast8_t;
    typedef  int32_t  int_fast16_t;
    typedef uint32_t uint_fast16_t;

typedef  int32_t  int_fast32_t;
typedef uint32_t uint_fast32_t;


    typedef  int64_t  int_fast64_t;
    typedef uint64_t uint_fast64_t;

/* 7.18.1.4 Integer types capable of holding object pointers */
    typedef          int intptr_t;
    typedef unsigned int uintptr_t;

/* 7.18.1.5 Greatest-width integer types */
    typedef          long long intmax_t;
    typedef unsigned long long uintmax_t;

/* 
   According to footnotes in the 1999 C standard, "C++ implementations
   should define these macros only when __STDC_LIMIT_MACROS is defined
   before <stdint.h> is included." 
*/
#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)

/* 7.18.2 Limits of specified width integer types */

    #define  INT8_MAX   INT8_C(127)
    #define  INT8_MIN   (-INT8_MAX-1)
    #define UINT8_MAX   UINT8_C(255)

#define  INT16_MAX  INT16_C(32767)
#define  INT16_MIN  (-INT16_MAX-1)
#define UINT16_MAX  UINT16_C(65535)
#define  INT32_MAX  INT32_C(2147483647)
#define  INT32_MIN  (-INT32_MAX-1)
#define UINT32_MAX  UINT32_C(4294967295)


    #define  INT64_MAX  INT64_C(9223372036854775807)
    #define  INT64_MIN  (-INT64_MAX-1)
    #define UINT64_MAX  UINT64_C(18446744073709551615)

    #define  INT_LEAST8_MAX   INT8_MAX
    #define  INT_LEAST8_MIN   INT8_MIN
    #define UINT_LEAST8_MAX   UINT8_MAX

#define  INT_LEAST16_MAX  INT16_MAX
#define  INT_LEAST16_MIN  INT16_MIN
#define UINT_LEAST16_MAX  UINT16_MAX
#define  INT_LEAST32_MAX  INT32_MAX
#define  INT_LEAST32_MIN  INT32_MIN
#define UINT_LEAST32_MAX  UINT32_MAX


    #define  INT_LEAST64_MAX  INT64_MAX
    #define  INT_LEAST64_MIN  INT64_MIN
    #define UINT_LEAST64_MAX  UINT64_MAX

    #define  INT_FAST8_MAX   INT32_MAX
    #define  INT_FAST8_MIN   INT32_MIN
    #define UINT_FAST8_MAX   UINT32_MAX
    #define  INT_FAST16_MAX  INT32_MAX
    #define  INT_FAST16_MIN  INT32_MIN
    #define UINT_FAST16_MAX  UINT32_MAX

#define  INT_FAST32_MAX  INT32_MAX
#define  INT_FAST32_MIN  INT32_MIN
#define UINT_FAST32_MAX  UINT32_MAX


    #define  INT_FAST64_MAX  INT64_MAX
    #define  INT_FAST64_MIN  INT64_MIN
    #define UINT_FAST64_MAX  UINT64_MAX

#define INTPTR_MAX   INT32_MAX
#define INTPTR_MIN   INT32_MIN
#define UINTPTR_MAX  UINT32_MAX

    #define INTMAX_MIN   INT64_MIN
    #define INTMAX_MAX   INT64_MAX
    #define UINTMAX_MAX  UINT64_MAX

/* 7.18.3 Limits of other integer types */

    #define PTRDIFF_MAX INT32_MAX
    #define PTRDIFF_MIN INT32_MIN

/* sig_atomic_t not defined */

    #define SIZE_MAX INT32_MAX

    #define WCHAR_MAX UINT16_MAX
    #define WCHAR_MIN 0

/* wint_t not defined */

/* 7.18.4.1 Macros for minimum-width integer constants */

#define  INT8_C(value)  (0  + (value))
#define UINT8_C(value)  (0U + (value))
#define  INT16_C(value) (0  + (value))
#define UINT16_C(value) (0U + (value))

    #define  INT32_C(value) (0  + (value))
    #define UINT32_C(value) (0U + (value))


    #define  INT64_C(value) (0LL  + (value))
    #define UINT64_C(value) (0ULL + (value))

/* 7.18.4.2 Macros for greatest-width integer constants */

    #define  INTMAX_C(value) (0LL  + (value))
    #define UINTMAX_C(value) (0ULL + (value))

#endif /* !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) */

#endif /* _STDINT_H_ */
stdio.h/        1202506631  0     0     0       11501     `
/*****************************************************************************/
/* STDIO.H v2.70                                                             */
/* Copyright (c) 1993-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#ifndef _STDIO 
#define _STDIO

#include <linkage.h>
#include <stdarg.h>

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cstdio> IS RECOMMENDED OVER <stdio.h>.  <stdio.h> IS PROVIDED FOR
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
extern "C" namespace std {
#endif

/****************************************************************************/
/* TYPES THAT ANSI REQUIRES TO BE DEFINED                                   */
/****************************************************************************/
#ifndef _SIZE_T                                                    
#define _SIZE_T                                                    
typedef unsigned size_t; 
#endif

typedef struct {
      int fd;                    /* File descriptor */
      unsigned char* buf;        /* Pointer to start of buffer */
      unsigned char* pos;        /* Position in buffer */
      unsigned char* bufend;     /* Pointer to end of buffer */
      unsigned char* buff_stop;  /* Pointer to last read char in buffer */
      unsigned int   flags;      /* File status flags (see below) */
      int index;                 /* Location in ftable */
} FILE;

#ifndef _FPOS_T
#define _FPOS_T
typedef long fpos_t;
#endif /* _FPOS_T */

/****************************************************************************/
/* MACROS THAT DEFINE AND USE FILE STATUS FLAGS                             */
/****************************************************************************/
#define _IOFBF       0x0001
#define _IOLBF       0x0002
#define _IONBF       0x0004
#define _BUFFALOC    0x0008
#define _MODER       0x0010
#define _MODEW       0x0020
#define _MODERW      0x0040
#define _MODEA       0x0080
#define _MODEBIN     0x0100
#define _STATEOF     0x0200
#define _STATERR     0x0400
#define _UNGETC      0x0800
#define _TMPFILE     0x1000

#define _SET(_fp, _b)      (((_fp)->flags) |= (_b))
#define _UNSET(_fp, _b)    (((_fp)->flags) &= ~(_b))
#define _STCHK(_fp, _b)    (((_fp)->flags) & (_b))
#define _BUFFMODE(_fp)     (((_fp)->flags) & (_IOFBF | _IOLBF | _IONBF))
#define _ACCMODE(_fp)      (((_fp)->flags) & (_MODER | _MODEW))

/****************************************************************************/
/* MACROS THAT ANSI REQUIRES TO BE DEFINED                                  */
/****************************************************************************/
#define BUFSIZ          256 
#define FOPEN_MAX       12
#define FILENAME_MAX    256  
#define TMP_MAX         65535

#define SEEK_SET  (0x0000)
#define SEEK_CUR  (0x0001)
#define SEEK_END  (0x0002)

#ifndef NULL
#define NULL 0
#endif

#ifndef EOF
#define EOF    (-1)
#endif

#define stdin     (&_ftable[0])      
#define stdout    (&_ftable[1])
#define stderr    (&_ftable[2])

#define L_tmpnam  (sizeof(P_tmpdir) + 15)

/******** END OF ANSI MACROS ************************************************/

#define P_tmpdir        ""                   /* Path for temp files         */

/****************************************************************************/
/* DEVICE AND STREAM RELATED DATA STRUCTURES AND MACROS                     */
/****************************************************************************/
/*- If you modify these values, be sure to also modify the ftable[] to     -*/
/*- correctly initialize the entries.  This is necessary since we do not   -*/
/*- clear bss by default!                                                  -*/
/****************************************************************************/
#define _NFILE          20                   /* Max number of files open    */

extern _DATA_ACCESS FILE _ftable[_NFILE];
extern _DATA_ACCESS char _tmpnams[_NFILE][L_tmpnam];

/****************************************************************************/
/*   FUNCTION DEFINITIONS  - ANSI                                           */
/****************************************************************************/
/****************************************************************************/
/* OPERATIONS ON FILES                                                      */
/****************************************************************************/
extern _CODE_ACCESS int     remove(const char *_file);
extern _CODE_ACCESS int     rename(const char *_old, const char *_new);
extern _CODE_ACCESS FILE   *tmpfile(void);
extern _CODE_ACCESS char   *tmpnam(char *_s);

/****************************************************************************/
/* FILE ACCESS FUNCTIONS                                                    */
/****************************************************************************/
extern _CODE_ACCESS int     fclose(FILE *_fp); 
extern _CODE_ACCESS FILE   *fopen(const char *_fname, const char *_mode);
extern _CODE_ACCESS FILE   *freopen(const char *_fname, const char *_mode,
			            register FILE *_fp);
extern _CODE_ACCESS void    setbuf(register FILE *_fp, char *_buf);
extern _CODE_ACCESS int     setvbuf(register FILE *_fp, register char *_buf, 
			            register int _type, register size_t _size);
extern _CODE_ACCESS int     fflush(register FILE *_fp); 

/****************************************************************************/
/* FORMATTED INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern _CODE_ACCESS int fprintf(FILE *_fp, const char *_format, ...);
extern _CODE_ACCESS int fscanf(FILE *_fp, const char *_fmt, ...);
extern _CODE_ACCESS int printf(const char *_format, ...);
extern _CODE_ACCESS int scanf(const char *_fmt, ...);
extern _CODE_ACCESS int sprintf(char *_string, const char *_format, ...);
extern _CODE_ACCESS int snprintf(char *_string, size_t _n, 
				 const char *_format, ...);
extern _CODE_ACCESS int sscanf(const char *_str, const char *_fmt, ...);
extern _CODE_ACCESS int vfprintf(FILE *_fp, const char *_format, va_list _ap);
extern _CODE_ACCESS int vprintf(const char *_format, va_list _ap);
extern _CODE_ACCESS int vsprintf(char *_string, const char *_format,
				 va_list _ap);
extern _CODE_ACCESS int vsnprintf(char *_string, size_t _n, 
				  const char *_format, va_list _ap);

/****************************************************************************/
/* CHARACTER INPUT/OUTPUT FUNCTIONS                                         */
/****************************************************************************/
extern _CODE_ACCESS int     fgetc(register FILE *_fp);
extern _CODE_ACCESS char   *fgets(char *_ptr, register int _size,
				  register FILE *_fp);
extern _CODE_ACCESS int     fputc(int _c, register FILE *_fp);
extern _CODE_ACCESS int     fputs(const char *_ptr, register FILE *_fp);
extern _CODE_ACCESS int     getc(FILE *_p);
extern _CODE_ACCESS int     getchar(void);
extern _CODE_ACCESS char   *gets(char *_ptr); 
extern _CODE_ACCESS int     putc(int _x, FILE *_fp);
extern _CODE_ACCESS int     putchar(int _x);
extern _CODE_ACCESS int     puts(const char *_ptr); 
extern _CODE_ACCESS int     ungetc(int _c, register FILE *_fp);

/****************************************************************************/
/* DIRECT INPUT/OUTPUT FUNCTIONS                                            */
/****************************************************************************/
extern _CODE_ACCESS size_t  fread(void *_ptr, size_t _size, size_t _count,
				  FILE *_fp);
extern _CODE_ACCESS size_t  fwrite(const void *_ptr, size_t _size,
				   size_t _count, register FILE *_fp); 

/****************************************************************************/
/* FILE POSITIONING FUNCTIONS                                               */
/****************************************************************************/
extern _CODE_ACCESS int     fgetpos(FILE *_fp, fpos_t *_pos);
extern _CODE_ACCESS int     fseek(register FILE *_fp, long _offset,
				  int _ptrname);
extern _CODE_ACCESS int     fsetpos(FILE *_fp, const fpos_t *_pos);
extern _CODE_ACCESS long    ftell(FILE *_fp);
extern _CODE_ACCESS void    rewind(register FILE *_fp); 

/****************************************************************************/
/* ERROR-HANDLING FUNCTIONS                                                 */
/****************************************************************************/
extern _CODE_ACCESS void    clearerr(FILE *_fp);
extern _CODE_ACCESS int     feof(FILE *_fp);
extern _CODE_ACCESS int     ferror(FILE *_fp);
extern _CODE_ACCESS void    perror(const char *_s);

#define _getchar()      getc(stdin)
#define _putchar(_x)    putc((_x), stdout)
#define _clearerr(_fp)   ((void) ((_fp)->flags &= ~(_STATERR | _STATEOF)))

#define _ferror(_x)     ((_x)->flags & _STATERR)

#define _remove(_fl)    (unlink((_fl)))

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::size_t;
using std::FILE;
using std::fpos_t;
using std::_ftable;
using std::_tmpnams;
using std::remove;
using std::rename;
using std::tmpfile;
using std::tmpnam;
using std::fclose;
using std::fopen;
using std::freopen;
using std::setbuf;
using std::setvbuf;
using std::fflush;
using std::fprintf;
using std::fscanf;
using std::printf;
using std::scanf;
using std::sprintf;
using std::sscanf;
using std::vfprintf;
using std::vprintf;
using std::vsprintf;
using std::fgetc;
using std::fgets;
using std::fputc;
using std::fputs;
using std::getc;
using std::getchar;
using std::gets;
using std::putc;
using std::putchar;
using std::puts;
using std::ungetc;
using std::fread;
using std::fwrite;
using std::fgetpos;
using std::fseek;
using std::fsetpos;
using std::ftell;
using std::rewind;
using std::clearerr;
using std::feof;
using std::ferror;
using std::perror;
#endif  /* _CPP_STYLE_HEADER */

#endif  /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::size_t;
using std::FILE;
using std::fpos_t;
using std::_ftable;
using std::_tmpnams;
using std::remove;
using std::rename;
using std::tmpfile;
using std::tmpnam;
using std::fclose;
using std::fopen;
using std::freopen;
using std::setbuf;
using std::setvbuf;
using std::fflush;
using std::fprintf;
using std::fscanf;
using std::printf;
using std::scanf;
using std::sprintf;
using std::sscanf;
using std::vfprintf;
using std::vprintf;
using std::vsprintf;
using std::fgetc;
using std::fgets;
using std::fputc;
using std::fputs;
using std::getc;
using std::getchar;
using std::gets;
using std::putc;
using std::putchar;
using std::puts;
using std::ungetc;
using std::fread;
using std::fwrite;
using std::fgetpos;
using std::fseek;
using std::fsetpos;
using std::ftell;
using std::rewind;
using std::clearerr;
using std::feof;
using std::ferror;
using std::perror;
#endif  /* _CPP_STYLE_HEADER */

#endif  /* __cplusplus */

#endif  /* #ifndef _STDIO */


stdlib.h/       1202506631  0     0     0       5960      `
/*****************************************************************************/
/* stdlib.h   v2.70                                                          */
/* Copyright (c) 1993-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STDLIB
#define _STDLIB

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cstdlib> IS RECOMMENDED OVER <stdlib.h>.  <stdlib.h> IS PROVIDED FOR 
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
extern "C" namespace std {
#endif /* !__cplusplus */

typedef struct { int quot, rem; } div_t;

typedef struct { int quot, rem; } ldiv_t;

#define _LLONG_AVAILABLE 1
typedef struct { long long quot, rem; } lldiv_t;

#define MB_CUR_MAX    1

#ifndef NULL
#define NULL          0
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned int size_t;
#endif

#ifndef __cplusplus
#ifndef _WCHAR_T
#define _WCHAR_T

typedef unsigned short wchar_t;

#endif /* _WCHAR_T */
#endif /* ! __cplusplus */

#define EXIT_FAILURE  1
#define EXIT_SUCCESS  0

#define RAND_MAX      32767

#include <linkage.h>

/*---------------------------------------------------------------*/
/* NOTE - Normally, abs, labs, and fabs are expanded inline, so  */
/*        no formal definition is really required. However, ANSI */
/*        requires that they exist as separate functions, so     */
/*        they are supplied in the library.  The prototype is    */
/*        here mainly for documentation.                         */
/*---------------------------------------------------------------*/
    _CODE_ACCESS  int       abs(int _val); 
    _CODE_ACCESS  long      labs(long _val);
#if _LLONG_AVAILABLE
    _CODE_ACCESS  long long llabs(long long _val);
#endif
        
    _CODE_ACCESS int       atoi(const char *_st);
    _CODE_ACCESS long      atol(const char *_st);
#if _LLONG_AVAILABLE
    _CODE_ACCESS long long atoll(const char *_st);
#endif
    _CODE_ACCESS int       ltoa(long val, char *buffer);
          _IDECL double    atof(const char *_st);

    _CODE_ACCESS long      strtol(const char *_st, char **_endptr, int _base);
    _CODE_ACCESS unsigned long strtoul(const char *_st, char **_endptr,
    					  int _base);
#if _LLONG_AVAILABLE
    _CODE_ACCESS long long strtoll(const char *_st, char **_endptr, int _base);
    _CODE_ACCESS unsigned long long strtoull(const char *_st, char **_endptr,
					     int _base);
#endif
    _CODE_ACCESS double    strtod(const char *_st, char **_endptr);
    _CODE_ACCESS long double strtold(const char *_st, char **_endptr);
    
    _CODE_ACCESS int    rand(void);
    _CODE_ACCESS void   srand(unsigned _seed);
    
    _CODE_ACCESS void  *calloc(size_t _num, size_t _size);
    _CODE_ACCESS void  *malloc(size_t _size);
    _CODE_ACCESS void  *realloc(void *_ptr, size_t _size);
    _CODE_ACCESS void   free(void *_ptr);
    _CODE_ACCESS void  *memalign(size_t _aln, size_t _size);
    
    _CODE_ACCESS void   abort(void); 
    _CODE_ACCESS int    atexit(void (*_func)(void));
    _CODE_ACCESS void  *bsearch(const void *_key, const void *_base,
    				   size_t _nmemb, size_t _size, 
    			           int (*compar)(const void *,const void *));
    _CODE_ACCESS void   qsort(void *_base, size_t _nmemb, size_t _size, 
    			         int (*_compar)(const void *, const void *));
    _CODE_ACCESS void   exit(int _status);
    
    _CODE_ACCESS div_t  div(int _numer, int _denom);
    _CODE_ACCESS ldiv_t ldiv(long _numer, long _denom);
#if _LLONG_AVAILABLE
    _CODE_ACCESS lldiv_t lldiv(long long _numer, long long _denom);
#endif

    _CODE_ACCESS char  *getenv(const char *_string);
    _CODE_ACCESS int    system(const char *_name);

#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::div_t;
using std::ldiv_t;
#if _LLONG_AVAILABLE
using std::lldiv_t;
#endif
using std::size_t;
using std::abs;
using std::labs;
using std::atoi;
using std::atol;
#if _LLONG_AVAILABLE
using std::atoll;
#endif
using std::atof;
using std::strtol;
using std::strtoul;
#if _LLONG_AVAILABLE
using std::strtoll;
using std::strtoull;
#endif
using std::strtod;
using std::rand;
using std::srand;
using std::calloc;
using std::malloc;
using std::realloc;
using std::free;
using std::memalign;
using std::abort;
using std::atexit;
using std::bsearch;
using std::qsort;
using std::exit;
using std::div;
using std::ldiv;
#if _LLONG_AVAILABLE
using std::lldiv;
#endif
using std::getenv;
using std::system;
#endif /* ! _CPP_STYLE_HEADER */

#endif /* __cplusplus */


#ifdef _INLINE

#ifdef __cplusplus
namespace std {
#endif

static __inline double atof(const char *_st) 
{
  return strtod(_st, (char **)0); 
}

#ifdef __cplusplus
} /* namespace std */
#endif

#endif  /* _INLINE */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::div_t;
using std::ldiv_t;
#if _LLONG_AVAILABLE
using std::lldiv_t;
#endif
using std::size_t;
using std::abs;
using std::labs;
using std::atoi;
using std::atol;
#if _LLONG_AVAILABLE
using std::atoll;
#endif
using std::atof;
using std::strtol;
using std::strtoul;
#if _LLONG_AVAILABLE
using std::strtoll;
using std::strtoull;
#endif
using std::strtod;
using std::rand;
using std::srand;
using std::calloc;
using std::malloc;
using std::realloc;
using std::free;
using std::memalign;
using std::abort;
using std::atexit;
using std::bsearch;
using std::qsort;
using std::exit;
using std::div;
using std::ldiv;
#if _LLONG_AVAILABLE
using std::lldiv;
#endif
using std::getenv;
using std::system;
#endif /* ! _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif  /* ! _STDLIB */
stkchk16.asm/   1202506631  0     0     0       2340      `
;******************************************************************************
;* STKCHK.ASM  - STACK OVERFLOW CHECK -  v2.70                                *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************
 
;****************************************************************************
;* C$STKCHK - CHECK THE STACK FOR OVERFLOW TO MANAGE THE STACK DYNAMICALLY
;*            16 BIS
;****************************************************************************
;*
;*   o FRAME SIZE IS IN V1            
;****************************************************************************
	.state16

        .global C$STKCHK
        .global C$STKCHK_LEAF

C$STKCHK: .asmfunc stack_usage(4)
C$STKCHK_LEAF:
        PUSH      {V2}


        LDR       V2, c_stack 		; Load the top of the stack address
	ADD	  V2, V2, V1		; Add frame size to it
	ADD	  V2, #32		; Add the maximum register save size 

        CMP       V2, SP	
        BLT       L2			; Return if stack does not overflow

        LDR       V1, c_stkchkc 	; Load the stkchk called flag
        LDR       V2, [V1, #0]
        CMP       V2, #0		; If flag is set, we already detected 
        BNE       L2			; overflow, just exit

        MOV       V2, #1		; Set the stkchk called flag
        STR       V2, [V1, #0]	
        BL        $handle_stkovf 	; Call the user defined function

	
        MOV       R0, #0
        BL        $exit			; Call the exit routine

L2:
	POP	   {V2}
        BX	  LR
	.endasmfunc

;******************************************************************************
;* CONSTANT TABLE                                                             *
;******************************************************************************
           .align  4
c_stkchkc: .field          _stkchk_called,32
           .align  4
c_stack:   .field          __stack,32

;******************************************************************************
;* UNDEFINED EXTERNAL REFERENCES                                              *
;******************************************************************************
        .global $handle_stkovf
        .global $exit
        .global __stack
	.global _stkchk_called
stkchk32.asm/   1202506631  0     0     0       2327      `
;******************************************************************************
;* STKCHK.ASM  - STACK OVERFLOW CHECK -  v2.70                                *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************
 
;****************************************************************************
;* C_STKCHK - CHECK THE STACK FOR OVERFLOW TO MANAGE THE STACK DYNAMICALLY
;*            32 BIS
;****************************************************************************
;*
;*   o FRAME SIZE IS IN V1              
;****************************************************************************
        .state32
 
        .global C_STKCHK
        .global C_STKCHK_LEAF

C_STKCHK: .asmfunc
C_STKCHK_LEAF:
        LDR       V9, c_stack 		; Load the top of the stack address
	ADD	  V9, V9, V1  		; Add the frame size 
	ADD	  V9, V9, #32 		; Add max register save size
        CMP       V9, SP      		; Return if no stack overflow
        BLT       L1

        LDR       V1, c_stkchkc 	; _stkchk_called is set if we already 
        LDR       V9, [V1, #0]		; detected stack overflow 
        CMP       V9, #0	
        BNE       L1			; return if _stkchk_called is set

        MOV       V9, #1		; Now we have detected stack overflow
        STR       V9, [V1, #0]		; So call the user function to 
        BL        _handle_stkovf	;   handle the stack overflow

        MOV       R0, #0
        BL        _exit			; Call the exit routine
L1:
	BX	  LR
	.endasmfunc

;******************************************************************************
;* CONSTANT TABLE                                                             *
;******************************************************************************
            .align  4
c_stkchkc:  .field          _stkchk_called,32
            .align  4
c_stack:    .field          __stack,32

;******************************************************************************
;* UNDEFINED EXTERNAL REFERENCES                                              *
;******************************************************************************
        .global _handle_stkovf
        .global _exit
        .global __stack
	.global _stkchk_called


stkdepth.c/     1202506631  0     0     0       816       `
/****************************************************************************/
/*  STKDEPTH.C v2.70                                                        */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/*                                                                          */
/*  Stack Depth Analysis Support                                            */
/****************************************************************************/
#include <stdlib.h>
#include <stdio.h>

extern unsigned long main_func_sp  ;  /* SP of main                     */
unsigned long max_stack_required = 0; /* Largest stack seen "so far"    */

void print_max_stack(void)
{
    if (max_stack_required && main_func_sp)
        printf("Max stack used:%d\n", max_stack_required);
}
stkdepth_vars.c/1202506631  0     0     0       617       `
/******************************************************************************/
/*                                                                            */
/* Place the definition of main_func_sp here. boot.asm references this	      */
/* symbol and we should prevent unneeded modules/routines from getting	      */
/* linked in while referring main_func_sp.				      */
/*                                                                            */
/******************************************************************************/

unsigned long main_func_sp       = 0; /* SP of main              */

strcat.c/       1202506631  0     0     0       411       `
/****************************************************************************/
/*  strcat v2.70                                                            */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRCAT

#include <string.h>

strchr.c/       1202506631  0     0     0       411       `
/****************************************************************************/
/*  strchr v2.70                                                            */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRCHR

#include <string.h>

strcmp.c/       1202506631  0     0     0       411       `
/****************************************************************************/
/*  strcmp v2.70                                                            */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRCMP

#include <string.h>

strcoll.c/      1202506631  0     0     0       605       `
/****************************************************************************/
/*  strcoll v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

_CODE_ACCESS int   strcoll(const char *string1, const char *string2)
{
     register const char *r1 = string1 - 1;
     register const char *r2 = string2 - 1;
     register char cp;
 
     while ((*++r2 == (cp = *++r1)) && cp);
     return *r1 - *r2;
}

strcpy.c/       1202506631  0     0     0       411       `
/****************************************************************************/
/*  strcpy v2.70                                                            */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRCPY

#include <string.h>

strcspn.c/      1202506631  0     0     0       1042      `
/****************************************************************************/
/*  strcspn v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <string.h>

_CODE_ACCESS size_t strcspn(const char *s1, const char *s2)
{
   const char *check;
   size_t      count = 0;
 
   /*---------------------------------------------------------------------*/
   /* FOR EACH CHAR IN s1                                                 */
   /*---------------------------------------------------------------------*/
   for (; *s1; s1++, count++)
   {
      for (check = s2; *check;)
	 /*---------------------------------------------------------------*/
	 /* QUIT WHEN FIND A CHAR IN s1 THAT'S EQUAL TO A CHAR IN s2      */
	 /*---------------------------------------------------------------*/
	 if (*s1 == *check++) return count;
   }
   return count;
}
strerror.c/     1202506631  0     0     0       726       `
/****************************************************************************/
/*  strerror  v2.70                                                         */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <errno.h>
#include <string.h>

_CODE_ACCESS char *strerror(int errnum)
{
   switch(errnum)
   {
      case 0      :  return ("No error");
      case EDOM   :  return ("Domain error");
      case ERANGE :  return ("Range error");
      case ENOENT :  return ("No such file or directory");
      case EFPOS  :  return ("File positioning error");
   }

   return ("Unknown error");
}
strftime.c/     1202506631  0     0     0       3820      `
/****************************************************************************/
/*  strftime v2.70                                                          */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <time.h>
#include <string.h>

extern int  sprintf(char *_string, const char *_format, ...);

static _DATA_ACCESS const char *const fday[] =
           { "Sunday","Monday","Tuesday","Wednesday",
	     "Thursday","Friday","Saturday" };

static _DATA_ACCESS const char *const fmon[] =
	   { "January","February","March","April","May",
	     "June", "July","August","September",
	     "October","November", "December" };

_CODE_ACCESS size_t strftime(char            *out,
	                     size_t           maxsize, 
	                     const char      *format,
	                     const struct tm *time)
{
    struct tm tt = *time; 
    int       count = 0;
    char      buf[37];

    mktime(&tt);     /* MAKE SURE THIS IS A LEGITIMATE TIME */

    for (;;)
    {
	while ((count < maxsize) && *format && (*format != '%'))
	{
	    count++;
	    *out++ = *format++;
	}

	if (count >= maxsize) return 0;
	if (*format == '\0')  { *out = 0; return count; }

	switch (*++format)
	{
	    case '%' : strcpy(buf, "%");                              break;
	    case 'z' : strcpy(buf, _tz.dstname);                      break;
	    case 'Z' : strcpy(buf, _tz.tzname);                       break;

	    case 'A' : strcpy (buf, fday[tt.tm_wday]);                break;
	    case 'a' : strncpy(buf, fday[tt.tm_wday], 3); buf[3] = 0; break;
	    case 'B' : strcpy (buf, fmon[tt.tm_mon]);                 break;
	    case 'b' : strncpy(buf, fmon[tt.tm_mon], 3);  buf[3] = 0; break;
	    case 'c' : sprintf(buf, "%s %s%3d %02d:%02d:%02d %d",
			       fday[tt.tm_wday], fmon[tt.tm_mon],
			       tt.tm_mday, tt.tm_hour, tt.tm_min,
			       tt.tm_sec, tt.tm_year + 1900);         break;

	    case 'I' : sprintf(buf, "%02d", ((tt.tm_hour != 0) &&
			                     (tt.tm_hour != 12)) ? 
			                    tt.tm_hour % 12 : 12);    break;
	    case 'H' : sprintf(buf, "%02d", tt.tm_hour);              break;
	    case 'M' : sprintf(buf, "%02d", tt.tm_min);               break;
	    case 'S' : sprintf(buf, "%02d", tt.tm_sec);               break;
	    case 'j' : sprintf(buf, "%03d", tt.tm_yday + 1);          break;
	    case 'd' : sprintf(buf, "%02d", tt.tm_mday);              break;
	    case 'e' : sprintf(buf, "%2d",  tt.tm_mday);              break;
	    case 'w' : sprintf(buf, "%1d",  tt.tm_wday);              break;
	    case 'm' : sprintf(buf, "%02d", tt.tm_mon + 1);           break;
	    case 'y' : sprintf(buf, "%02d", tt.tm_year % 100);        break;
	    case 'Y' : sprintf(buf, "%4d", 1900 + tt.tm_year);        break;

	    case 'p' : strcpy(buf, tt.tm_hour >= 12 ? "PM":"AM");     break;

	    case 'W' : sprintf(buf, "%02d", tt.tm_yday / 7 +
			       (tt.tm_yday % 7 >= (tt.tm_wday + 6) % 7));
	    							      break;
	    case 'U' : sprintf(buf, "%02d", tt.tm_yday / 7 +
			       (tt.tm_yday % 7 >= tt.tm_wday));       break;

	    case 'x' : sprintf(buf, "%3s %d, %d", fmon[tt.tm_mon], 
			       tt.tm_mday, tt.tm_year + 1900);        break;
	    case 'X' : sprintf(buf, "%02d:%02d:%02d", tt.tm_hour, 
			       tt.tm_min, tt.tm_sec);                 break;
	}

	/*-------------------------------------------------------------*/
	/* IF THIS STRING WILL FIT IN BUFFER, APPEND IT.               */
	/*-------------------------------------------------------------*/
	if ((count += strlen(buf)) > maxsize) return 0;
	strcpy(out, buf);
	out += strlen(buf);
	format++;
    }
}
string.h/       1202506631  0     0     0       8649      `
/*****************************************************************************/
/* string.h   v2.70                                                          */
/* Copyright (c) 1993-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _STRING
#define _STRING

#ifdef __cplusplus
//----------------------------------------------------------------------------
// <cstring> IS RECOMMENDED OVER <string.h>.  <string.h> IS PROVIDED FOR
// COMPATIBILITY WITH C AND THIS USAGE IS DEPRECATED IN C++
//----------------------------------------------------------------------------
extern "C" namespace std
{
#endif /* __cplusplus */
 
#ifndef NULL
#define NULL 0
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif /* ! _SIZE_T */

#include <linkage.h>

#if defined(_OPTIMIZE_FOR_SPACE) && (1 || 		\
				     0)
#define _OPT_IDECL
#else
#define _OPT_IDECL	_IDECL
#endif

_OPT_IDECL size_t  strlen(const char *_string);

_OPT_IDECL char *strcpy(char *_dest, const char *_src);
_OPT_IDECL char *strncpy(char *_to, const char *_from, size_t _n);
_OPT_IDECL char *strcat(char *_string1, const char *_string2);
_OPT_IDECL char *strncat(char *_to, const char *_from, size_t _n);
_OPT_IDECL char *strchr(const char *_string, int _c);
_OPT_IDECL char *strrchr(const char *_string, int _c);

_OPT_IDECL int  strcmp(const char *_string1, const char *_string2);
_OPT_IDECL int  strncmp(const char *_string1, const char *_string2, size_t _n);

_CODE_ACCESS int     strcoll(const char *_string1, const char *_string2);
_CODE_ACCESS size_t  strxfrm(char *_to, const char *_from, size_t _n);
_CODE_ACCESS char   *strpbrk(const char *_string, const char *_chs);
_CODE_ACCESS size_t  strspn(const char *_string, const char *_chs);
_CODE_ACCESS size_t  strcspn(const char *_string, const char *_chs);
_CODE_ACCESS char   *strstr(const char *_string1, const char *_string2);
_CODE_ACCESS char   *strtok(char *_str1, const char *_str2);
_CODE_ACCESS char   *strerror(int _errno);

_CODE_ACCESS void   *memmove(void *_s1, const void *_s2, size_t _n);
_CODE_ACCESS void   *memcpy(void *_s1, const void *_s2, size_t _n);

_OPT_IDECL int     memcmp(const void *_cs, const void *_ct, size_t _n);
_OPT_IDECL void   *memchr(const void *_cs, int _c, size_t _n);

_OPT_IDECL   void   *memset(void *_mem, int _ch, size_t _n);


#ifdef __cplusplus
} /* extern "C" namespace std */

#ifndef _CPP_STYLE_HEADER
using std::size_t;
using std::strlen;
using std::strcpy;
using std::strncpy;
using std::strcat;
using std::strncat;
using std::strchr;
using std::strrchr;
using std::strcmp;
using std::strncmp;
using std::strcoll;
using std::strxfrm;
using std::strpbrk;
using std::strspn;
using std::strcspn;
using std::strstr;
using std::strtok;
using std::strerror;
using std::memmove;
using std::memcpy;
using std::memcmp;
using std::memchr;
using std::memset;


#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#if defined(_INLINE) || defined(_STRING_IMPLEMENTATION)

#if (defined(_STRING_IMPLEMENTATION) ||					\
     !(defined(_OPTIMIZE_FOR_SPACE) && (1 || 		\
					0))) 

#ifdef __cplusplus
namespace std {
#endif

#if (defined(_OPTIMIZE_FOR_SPACE) && (1 || 		\
				      0))
#define _OPT_IDEFN
#else
#define _OPT_IDEFN	_IDEFN
#endif

#if defined(_INLINE) || defined(_STRLEN)
_OPT_IDEFN size_t strlen(const char *string)
{
   size_t      n = (size_t)-1;
   const char *s = string - 1;

   do n++; while (*++s);
   return n;
}
#endif /* _INLINE || _STRLEN */

#if defined(_INLINE) || defined(_STRCPY)
_OPT_IDEFN char *strcpy(register char *dest, register const char *src)
{
     register char       *d = dest - 1;     
     register const char *s = src  - 1;     

     while (*++d = *++s);
     return dest;
}
#endif /* _INLINE || _STRCPY */

#if defined(_INLINE) || defined(_STRNCPY)
_OPT_IDEFN char *strncpy(register char *dest,
		     register const char *src,
		     register size_t n)
{
     if (n) 
     {
	 register char       *d = dest - 1;
	 register const char *s = src - 1;
	 while ((*++d = *++s) && --n);              /* COPY STRING         */
	 if (n-- > 1) do *++d = '\0'; while (--n);  /* TERMINATION PADDING */
     }
     return dest;
}
#endif /* _INLINE || _STRNCPY  */

#if defined(_INLINE) || defined(_STRCAT)
_OPT_IDEFN char *strcat(char *string1, const char *string2)
{
   char       *s1 = string1 - 1;
   const char *s2 = string2 - 1;

   while (*++s1);		     /* FIND END OF STRING   */
   s1--;  			     /* BACK UP OVER NULL    */
   while (*++s1 = *++s2);	     /* APPEND SECOND STRING */
   return string1;
}
#endif /* _INLINE || _STRCAT */

#if defined(_INLINE) || defined(_STRNCAT)
_OPT_IDEFN char *strncat(char *dest, const char *src, register size_t n)
{
    if (n)
    {
	char       *d = dest - 1;
	const char *s = src  - 1;

	while (*++d);                      /* FIND END OF STRING   */
	d--;                               /* BACK UP OVER NULL    */

	while (n--)
	  if (!(*++d = *++s)) return dest; /* APPEND SECOND STRING */
	*++d = 0;
    }
    return dest;
}
#endif /* _INLINE || _STRNCAT */

#if defined(_INLINE) || defined(_STRCHR)
_OPT_IDEFN char *strchr(const char *string, int c)
{
   char        tch, ch  = c;
   const char *s        = string - 1;

   for (;;)
   {
       if ((tch = *++s) == ch) return (char *) s;
       if (!tch)               return (char *) 0;
   }
}
#endif /* _INLINE || _STRCHR */

#if defined(_INLINE) || defined(_STRRCHR)
_OPT_IDEFN char *strrchr(const char *string, int c)
{
   char        tch, ch = c;
   char       *result  = 0;
   const char *s       = string - 1;

   for (;;)
   {
      if ((tch = *++s) == ch) result = (char *) s;
      if (!tch) break;
   }

   return result;
}
#endif /* _INLINE || _STRRCHR */

#if defined(_INLINE) || defined(_STRCMP)
_OPT_IDEFN int strcmp(register const char *string1,
		  register const char *string2)
{
   register int c1, res;

   for (;;)
   {
       c1  = (unsigned char)*string1++;
       res = c1 - (unsigned char)*string2++;

       if (c1 == 0 || res != 0) break;
   }

   return res;
}
#endif /* _INLINE || _STRCMP */

#if defined(_INLINE) || defined(_STRNCMP)
_OPT_IDEFN int strncmp(const char *string1, const char *string2, size_t n)
{
     if (n) 
     {
	 const char *s1 = string1 - 1;
	 const char *s2 = string2 - 1;
	 unsigned char cp;
	 int         result;

	 do 
	    if (result = (unsigned char)*++s1 - (cp = (unsigned char)*++s2))
                return result;
	 while (cp && --n);
     }
     return 0;
}
#endif /* _INLINE || _STRNCMP */

#if defined(_INLINE) || defined(_MEMCMP)
_OPT_IDEFN int memcmp(const void *cs, const void *ct, size_t n)
{
   if (n) 
   {
       const unsigned char *mem1 = (unsigned char *)cs - 1;
       const unsigned char *mem2 = (unsigned char *)ct - 1;
       int                 cp;

       while ((cp = *++mem1) == *++mem2 && --n);
       return cp - *mem2;
   }
   return 0;
}
#endif /* _INLINE || _MEMCMP */

#if defined(_INLINE) || defined(_MEMCHR)
_OPT_IDEFN void *memchr(const void *cs, int c, size_t n)
{
   if (n)
   {
      const unsigned char *mem = (unsigned char *)cs - 1;   
      unsigned char        ch  = c;

      do if ( *++mem == ch ) return (void *)mem;
      while (--n);
   }
   return NULL;
}
#endif /* _INLINE || _MEMCHR */

#if ((defined(_INLINE) || defined(_MEMSET)) && !0)
_OPT_IDEFN void *memset(void *mem, register int ch, register size_t length)
{
     register char *m = (char *)mem - 1;

     while (length--) *++m = ch;
     return mem;
}
#endif /* _INLINE || _MEMSET */

#ifdef __cplusplus
} /* namespace std */
#endif

#endif /* (_STRING_IMPLEMENTATION || !(_OPTIMIZE_FOR_SPACE && __TMS470__)) */

#endif /* (_INLINE || _STRING_IMPLEMENTATION) */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::size_t;
using std::strlen;
using std::strcpy;
using std::strncpy;
using std::strcat;
using std::strncat;
using std::strchr;
using std::strrchr;
using std::strcmp;
using std::strncmp;
using std::strcoll;
using std::strxfrm;
using std::strpbrk;
using std::strspn;
using std::strcspn;
using std::strstr;
using std::strtok;
using std::strerror;
using std::memmove;
using std::memcpy;
using std::memcmp;
using std::memchr;
using std::memset;


#endif /* _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif /* ! _STRING */

strlen.c/       1202506631  0     0     0       411       `
/****************************************************************************/
/*  strlen v2.70                                                            */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRLEN

#include <string.h>

strncat.c/      1202506632  0     0     0       412       `
/****************************************************************************/
/*  strncat v2.70                                                           */
/*  Copyright (c) 1993-2008 Texas Instruments Incorporated                  */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRNCAT

#include <string.h>
strncmp.c/      1202506632  0     0     0       412       `
/****************************************************************************/
/*  strncmp v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRNCMP

#include <string.h>
strncpy.c/      1202506632  0     0     0       412       `
/****************************************************************************/
/*  strncpy v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRNCPY

#include <string.h>
strpbrk.c/      1202506632  0     0     0       566       `
/****************************************************************************/
/*  strpbrk v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

_CODE_ACCESS char *strpbrk(const char *s1, const char *s2)
{
   for (; *s1; s1++)
   {
      const char *check = s2;
 
      while (*check)
         if (*check++ == *s1) return (char *)s1;
   }
   return NULL;
}
strrchr.c/      1202506632  0     0     0       412       `
/****************************************************************************/
/*  strrchr v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/

#undef  _INLINE
#define _STRING_IMPLEMENTATION
#define _STRRCHR

#include <string.h>
strspn.c/       1202506632  0     0     0       862       `
/****************************************************************************/
/*  strspn  v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

_CODE_ACCESS size_t strspn(register const char *string, const char *chs)
{
     size_t count = 0;

     for (;;)            /* FOR EACH CHARACTER IN STRING */
     {
	register char  ch    = *string++;
        register char *check = (char *)chs;
	register char  tch   = *check;                

        while (tch)      /* FOR EACH CHARACTER IN LOOKUP STRING */
        {
	   if (ch == tch) break;
           tch = *++check;
        }

        if (!ch || ch != tch) return(count);
	count++;
     }
}
strstr.c/       1202506632  0     0     0       971       `
/****************************************************************************/
/*  strstr v2.70                                                            */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

_CODE_ACCESS char *strstr(register const char *string1, const char *string2)
{
     register char cp1, cp2;
     register const char *pos = string1;

     /* According to ANSI C(7.21.5.7), If string2 points to a string with   */
     /* zero length, the function returns string1. */
     if (*string2 == '\0')
	 return ((char *)string1);

     while (*string1)         /* FOR EACH STRING IN SOURCE STRING */
     {
         register const char *cmp = string2;

         while (((cp1 = *string1++) == (cp2 = *cmp++)) && cp1);
	 if (cp2 == 0) return (char *)pos;
	 string1 = ++pos;
     }
     return (0);
}


strtod.c/       1202506632  0     0     0       3847      `
/****************************************************************************/
/*  strtod v2.70                                                            */
/*  Copyright (c) 1993-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>
#include <float.h>
#include <errno.h>
#include <math.h>
#include <linkage.h>
#include <stdio.h>
#include <limits.h>

static const _DATA_ACCESS double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 
						  1.e16, 1.e32 };
static const _DATA_ACCESS double digits[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

_CODE_ACCESS double strtod(const char *st, char **endptr)
{
    double      result = 0;
    char        cp;
    const char *fst    = st;
    int         exp    = 0;               /* EXPONENT              */
    int         count  = 0;               /* EXPONENT CALCULATION  */
    int         value  = 0;               /* SUCCESSFUL PARSE      */
    int         sign;
    int         plus_or_minus = 0;        /* READ IN EXPONENT SIGN (+/-) */

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if ((sign = ((cp = *fst) == '-')) || (cp == '+')) { ++fst; value = 1; }

    /*----------------------------------------------------------------------*/
    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */
    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */
    /*----------------------------------------------------------------------*/
    for (; _isdigit(cp = *fst); ++fst) 
    {
       result = result * 10 + digits[cp - '0']; 
       value  = 1;
    }

    if (cp == '.') {
       while (_isdigit(cp = *++fst)) 
       {
          result = result * 10 + digits[cp - '0']; 
          value  = 1;
	  --exp;
       }
    }

    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */

    /*----------------------------------------------------------------------*/
    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */
    /* IF EXPONENT IS BOGUS (i.e. "1.234empty" or "1.234e+mpty") RESTORE    */
    /* BOGUS EXPONENT BACK ONTO RETURNED STRING (endptr).                   */
    /*----------------------------------------------------------------------*/
    if (value && _toupper(*fst) == 'E')
    {
       if ((sign = ((cp = *++fst) == '-')) || (cp == '+'))
       {
          cp = *++fst;
          plus_or_minus = 1;
       }
 
       if (!_isdigit(cp))
       {
          if (plus_or_minus) *--fst;
          *--fst;
          goto skip_loop;
       }

       for (count = 0; _isdigit(cp); cp = *++fst)
       {
	  if ((INT_MAX - abs(exp) - (cp - '0')) / 10 > count)
          {
             count *= 10; 
	     count += cp - '0';
	  } else
	  {
	    count = INT_MAX - exp;
	    break;
	  }
       }

skip_loop:

       if (sign) exp -= count;
       else      exp += count;
    }

    /*----------------------------------------------------------------------*/
    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */
    /*----------------------------------------------------------------------*/
    if (result != 0.0)
    {
       if (exp > DBL_MAX_10_EXP) 
	  { errno = ERANGE; result = (result < 0) ? -HUGE_VAL : HUGE_VAL; }
       else if (exp < DBL_MIN_10_EXP) 
	  { errno = ERANGE; result = 0.0; }
       else if (exp < 0) {
	    for (count = 0, exp = -exp; exp; count++, exp >>= 1)
	        { if (exp & 1) result /= powerof10[count]; }
       }
       else {
	    for (count = 0; exp; count++, exp >>= 1)
	        { if (exp & 1) result *= powerof10[count]; }
       }
    }

    if (endptr) *endptr = (char *)(value ? fst : st);
    return result;
}

strtok.c/       1202506632  0     0     0       736       `
/****************************************************************************/
/*  strtok v2.70                                                            */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <string.h>

_CODE_ACCESS char *strtok(char *str1, const char *str2)
{
     static _DATA_ACCESS char *last_end;
     char *start; 

     if (str1) last_end = str1;

     last_end += strspn(last_end, str2);
     if (*last_end == '\0') return (NULL);

     start = last_end;
     last_end += strcspn(last_end, str2);

     if (*last_end != '\0') *last_end++ = '\0'; 

     return start;
}

strtol.c/       1202506632  0     0     0       2824      `
/****************************************************************************/
/*  strtol v2.70                                                            */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>
#include <access.h>

_CODE_ACCESS long strtol(const char *st, char **endptr, int base)
{
    register long        result = 0;
    register char        cp;
    register const char *fst    = st;
    int                  digits = 0;
    int                  sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *fst) == '-')) cp = *++fst;
    else if (cp == '+') cp = *++fst;

    if (base > 36) base = 0;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  } 
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(fst[2]))
	             cp = *(fst += 2);
     }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;       
	    return sign ? LONG_MIN : LONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.  NEGATE THE RESULT IF A      */
    /* MINUS SIGN WAS SEEN.                                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);
    if (sign)
    {
	if (result > LONG_MAX) { errno = ERANGE; return (LONG_MIN); }
        return -result;
    }
    return result;
}

strtold.c/      1202506632  0     0     0       3862      `
/****************************************************************************/
/*  strtold v2.70                                                           */
/*  Copyright (c) 2002-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>
#include <float.h>
#include <errno.h>
#include <math.h>
#include <linkage.h>
#include <stdio.h>
#include <limits.h>

static const _DATA_ACCESS double powerof10[]  = { 1.e1, 1.e2, 1.e4, 1.e8, 
						  1.e16, 1.e32 };
static const _DATA_ACCESS double digits[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

_CODE_ACCESS long double strtold(const char *st, char **endptr)
{
    long double      result = 0;
    char        cp;
    const char *fst    = st;
    int         exp    = 0;               /* EXPONENT              */
    int         count;                    /* EXPONENT CALCULATION  */
    int         value  = 0;               /* SUCCESSFUL PARSE      */
    int         sign;
    int         plus_or_minus = 0;        /* READ IN EXPONENT SIGN (+/-) */

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if ((sign = ((cp = *fst) == '-')) || (cp == '+')) { ++fst; value = 1; }

    /*----------------------------------------------------------------------*/
    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */
    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */
    /*----------------------------------------------------------------------*/
    for (; _isdigit(cp = *fst); ++fst) 
    {
       result = result * 10 + digits[cp - '0']; 
       value  = 1;
    }

    if (cp == '.') {
       while (_isdigit(cp = *++fst)) 
       {
          result = result * 10 + digits[cp - '0']; 
          value  = 1;
	  --exp;
       }
    }

    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */

    /*----------------------------------------------------------------------*/
    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */
    /* IF EXPONENT IS BOGUS (i.e. "1.234empty" or "1.234e+mpty") RESTORE    */
    /* BOGUS EXPONENT BACK ONTO RETURNED STRING (endptr).                   */
    /*----------------------------------------------------------------------*/
    if (value && _toupper(*fst) == 'E')
    {
       if ((sign = ((cp = *++fst) == '-')) || (cp == '+'))
       {
          cp = *++fst;
          plus_or_minus = 1;
       }
 
       if (!_isdigit(cp))
       {
          if (plus_or_minus) *--fst;
          *--fst;
          goto skip_loop;
       }

       for (count = 0; _isdigit(cp); cp = *++fst)
       {
	  if ((INT_MAX - abs(exp) - (cp - '0')) / 10 > count)
          {
             count *= 10; 
	     count += cp - '0';
	  } else
	  {
	    count = INT_MAX - exp;
	    break;
	  }
       }

skip_loop:

       if (sign) exp -= count;
       else      exp += count;
    }

    /*----------------------------------------------------------------------*/
    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */
    /*----------------------------------------------------------------------*/
    if (result != 0.0)
    {
       if (exp > LDBL_MAX_10_EXP) 
	  { errno = ERANGE; result = (result < 0) ? -HUGE_VALL : HUGE_VALL; }
       else if (exp < LDBL_MIN_10_EXP) 
	  { errno = ERANGE; result = 0.0; }
       else if (exp < 0) {
	    for (count = 0, exp = -exp; exp; count++, exp >>= 1)
	        { if (exp & 1) result /= powerof10[count]; }
       }
       else {
	    for (count = 0; exp; count++, exp >>= 1)
	        { if (exp & 1) result *= powerof10[count]; }
       }
    }

    if (endptr) *endptr = (char *)(value ? fst : st);
    return result;
}
strtoll.c/      1202506632  0     0     0       2833      `
/****************************************************************************/
/*  strtoll v2.70                                                           */
/*  Copyright (c) 2000-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>
#include <access.h>

_CODE_ACCESS long long strtoll(const char *st, char **endptr, int base)
{
    register long long   result = 0;
    register char        cp;
    register const char *fst    = st;
    int                  digits = 0;
    int                  sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *fst) == '-')) cp = *++fst;
    else if (cp == '+') cp = *++fst;

    if (base > 36) base = 0;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  } 
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(fst[2]))
	             cp = *(fst += 2);
     }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register long long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st; 
	    return sign ? LLONG_MIN : LLONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.  NEGATE THE RESULT IF A      */
    /* MINUS SIGN WAS SEEN.                                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);
    if (sign)
    {
	if (result > LLONG_MAX) { errno = ERANGE; return (LLONG_MIN); }
        return -result;
    }
    return result;
}


strtoul.c/      1202506632  0     0     0       2656      `
/****************************************************************************/
/*  strtoul v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

_CODE_ACCESS unsigned long strtoul(const char *st, char **endptr, int base)
{
    register unsigned long result = 0;
    register char          cp;
    register const char   *fst = st;
    int                    digits = 0;
    int                    minus = 0;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if (base > 36) base = 0;  

    if ((cp = *fst) == '+') cp = *++fst;
    else if ((cp = *fst) == '-') { cp = *++fst; minus = 1; }

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  }
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(fst[2]))
	             cp = *(fst += 2);
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register unsigned long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;        
	    return ULONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);

    return minus ? -result : result;
}

strtoull.c/     1202506632  0     0     0       2670      `
/****************************************************************************/
/*  strtoull v2.70                                                          */
/*  Copyright (c) 2000-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

_CODE_ACCESS unsigned long long strtoull(const char *st, char **endptr,int base)
{
    register unsigned long long result = 0;
    register char          cp;
    register const char   *fst = st;
    int                    digits = 0;
    int                    minus = 0;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if (base > 36) base = 0;  

    if ((cp = *fst) == '+') cp = *++fst;
    else if ((cp = *fst) == '-') { cp = *++fst; minus = 1; }

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  }
	          break;

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')) &&
		      _isxdigit(fst[2]))
	             cp = *(fst += 2);
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register unsigned long long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;        
	    return ULLONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);

    return minus ? -result : result;
}
strxfrm.c/      1202506632  0     0     0       736       `
/****************************************************************************/
/*  strxfrm v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#include <stddef.h>
#include <string.h>

_CODE_ACCESS size_t strxfrm(register char *to,
			    register const char *from,
			    register size_t n)
{
     register int count = 0;     
     while (*from++) count++;                       /* GET LENGTH OF STRING */
     from -= count;
     from--;

     if (n) while ((*to++ = *from++) && --n);       /* COPY STRING          */

     return (count);
}
tan.c/          1202506632  0     0     0       2995      `
/****************************************************************************/
/*  tan    v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  TAN() - Tangent							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 9.              */
/*									    */
/*  N = round(x * 2 / PI) 						    */
/*  f = mantissa x							    */
/*  g = f * f								    */
/*  xnum = f * p1 * g + 1						    */
/*  xden = (q2 * g + q1) * g + 1					    */
/*									    */
/*  if N is even, result = xnum / xden					    */
/*  if N is odd, result = xden / - xnum 				    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double tan(double x)
{
    double xn, f, g, xnum, xden;
    int n;

    /*************************************************************************/
    /* n = round(x * 2/PI)                                                   */
    /*************************************************************************/
    if (x < 0.0) n = (int) (x * TWOINVPI - 0.5);  /* since (int) -1.5 = -1.0 */
    else         n = (int) (x * TWOINVPI + 0.5);

    xn = (double) n;

    /*************************************************************************/
    /* f = x - xn * PI / 2 (but more mathematically stable)                  */
    /*************************************************************************/
    f = (x - xn * C5) - xn * C6;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    g = f * f;

#if BITS<=24
    xnum = TAP1 * g * f + f;
    xden = (TAQ2 * g + TAQ1) * g + 0.5 + 0.5;
#elif BITS>=25 && BITS<=32
    xnum = (TAP2 * g + TAP1) * g * f + f;
    xden = (TAQ2 * g + TAQ1) * g + 0.5 + 0.5;
#elif BITS>=33 && BITS<=52
    xnum = ((TAP3 * g + TAP2) * g + TAP1) * g * f + f;
    xden = ((TAQ3 * g + TAQ2) * g + TAQ1) * g + 0.5 + 0.5;
#else
    xnum = ((TAP3 * g + TAP2) * g + TAP1) * g * f + f;
    xden = (((TAQ4 * g + TAQ3) * g + TAQ2) * g + TAQ1) * g + 0.5 + 0.5;
#endif

    /*************************************************************************/
    /* if n is odd                                                           */
    /*************************************************************************/
    if (n % 2 == 0) return (xnum / xden);
    else            return (xden / -xnum);	
}

tanh.c/         1202506633  0     0     0       2528      `
/****************************************************************************/
/*  tanh   v2.70                                                            */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                  */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  TANH() - Hyperbolic Tangent						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 13.             */
/*  This also uses the Cody and Waite algorithm for exp in chapter 6.	    */
/*									    */
/*  f = abs(x)								    */
/*  if f < ln(3) / 2,							    */
/*	g = f * f							    */
/*	R = polynomial expansion					    */
/*	result = f + f * R						    */
/*									    */
/*  if d > XBIG, result = sign(x)                                           */
/*  if f > ln(3) / 2 & f <= XBIG, result = 1 - 2 / (exp(2f) + 1)	    */
/*  if f < ln(3) / 2, R = polynomial expansion; result = f + f * R          */
/*  if x < 0, result = - result 					    */
/****************************************************************************/
double tanh(double x)
{
    double f = x, g, p, q, r, result;
    int sign = x < 0;

    f = fabs(x);

    if      (f > XBIG)     return (sign ? -1.0 : 1.0);
    else if (f > LOGe3by2) 
	 {
	    result = 1.0 - 2.0 / (exp(2.0 * f) + 1.0);
	    return sign ? -result : result; 
	 }

    /**********************************************************************/
    /* determine polynomial expression                                    */
    /**********************************************************************/
    g = f * f;

#if BITS<=24
    p = (THP1 * g + THP0) * g;
    q = g + THQ0;
#elif BITS>=25 && BITS<=36
    p = (THP1 * g + THP0) * g;
    q = (g + THQ1) * g + THQ0;
#elif BITS>=37 && BITS<=48
    p = ((THP2 * g + THP1) * g + THP0) * g;
    q = (g + THQ1) * g + THQ0;
#else
    p = ((THP2 * g + THP1) * g + THP0) * g;
    q = ((g + THQ2) * g + THQ1) * g + THQ0;
#endif

    r = p / q;

    /*****************************************************************/
    /* tanh(x) = sign * result                                       */
    /*****************************************************************/
    result = f + f * r; 
    return sign ? -result : result; 
}
time.c/         1202506633  0     0     0       543       `
/*****************************************************************************/
/*  TIME.C v2.70                                                             */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/
#include <time.h> 

extern _CODE_ACCESS time_t HOSTtime();

_CODE_ACCESS time_t time(time_t *timer) 
{
   time_t result;

   result = (time_t)HOSTtime();
   if(timer) *timer = result;
   return(result);
}


time.h/         1202506633  0     0     0       3496      `
/*****************************************************************************/
/* time.h     v2.70                                                          */
/* Copyright (c) 1990-2008  Texas Instruments Incorporated                   */
/*****************************************************************************/

#ifndef _TIME
#define _TIME

#include <linkage.h>

#define CLOCKS_PER_SEC 1000

#ifndef NULL
#define NULL      0
#endif

#ifdef __cplusplus
extern "C" namespace std {
#endif

typedef unsigned long clock_t;
typedef unsigned long time_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif /* ! _SIZE_T */

struct tm 
{
    int tm_sec;      /* seconds after the minute   - [0,59]  */
    int tm_min;      /* minutes after the hour     - [0,59]  */
    int tm_hour;     /* hours after the midnight   - [0,23]  */
    int tm_mday;     /* day of the month           - [1,31]  */
    int tm_mon;      /* months since January       - [0,11]  */
    int tm_year;     /* years since 1900                     */
    int tm_wday;     /* days since Sunday          - [0,6]   */
    int tm_yday;     /* days since Jan 1st         - [0,365] */
    int tm_isdst;    /* Daylight Savings Time flag           */
};

/*************************************************************************/
/* TIME ZONE STRUCTURE DEFINITION                                        */
/*************************************************************************/
typedef struct 
{
    short daylight;
    long  timezone;
    char  tzname[4];
    char  dstname[4];
} TZ;

extern _DATA_ACCESS TZ _tz;

/****************************************************************************/
/* FUNCTION DECLARATIONS.  (NOTE : clock AND time ARE SYSTEM SPECIFIC)      */
/****************************************************************************/
_CODE_ACCESS clock_t    clock(void);             
_CODE_ACCESS time_t     time(time_t *_timer);   
 
_CODE_ACCESS time_t     mktime(struct tm *_tptr);
_CODE_ACCESS double     difftime(time_t _time1, time_t _time0);
      _IDECL char      *ctime(const time_t *_timer);
_CODE_ACCESS char      *asctime(const struct tm *_timeptr);
_CODE_ACCESS struct tm *gmtime(const time_t *_timer);
_CODE_ACCESS struct tm *localtime(const time_t *_timer);
_CODE_ACCESS size_t     strftime(char *_out, size_t _maxsize, 
				 const char *_format,
				 const struct tm *_timeptr);

#if defined(_INLINE) || defined(_CTIME_)

_IDEFN char *ctime(const time_t *timer)
{
   return(asctime(localtime(timer)));
}

#endif /* _INLINE || _CTIME_ */

#ifdef __cplusplus
} /* extern "C" */

#ifndef _CPP_STYLE_HEADER
using std::clock_t;
using std::time_t;
using std::size_t;
using std::tm;
using std::TZ;
using std::_tz;
using std::clock;
using std::time;
using std::mktime;
using std::difftime;
using std::ctime;
using std::asctime;
using std::gmtime;
using std::localtime;
using std::strftime;
#endif /* ! _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#else

#ifdef __cplusplus

#ifndef _CPP_STYLE_HEADER
using std::clock_t;
using std::time_t;
using std::size_t;
using std::tm;
using std::TZ;
using std::_tz;
using std::clock;
using std::time;
using std::mktime;
using std::difftime;
using std::ctime;
using std::asctime;
using std::gmtime;
using std::localtime;
using std::strftime;
#endif /* ! _CPP_STYLE_HEADER */

#endif /* __cplusplus */

#endif /* _TIME */
tmpfile.c/      1202506633  0     0     0       1371      `
/*****************************************************************************/
/*  TMPFILE.C v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    TMPFILE  -  Create a temporary file, and return a pointer to the       */
/*                stream                                                     */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>


/*****************************************************************************/
/* TMPFILE  -  Create a temporary file, and return a pointer to its FILE     */
/*             structure                                                     */
/*****************************************************************************/
_CODE_ACCESS FILE *tmpfile(void)
{
   char tfname[L_tmpnam];
   FILE *_fp = (tmpnam(tfname)) ? (fopen(tfname, "wb+")) : NULL;

   if(_fp)
   {
      _SET(_fp, _TMPFILE);
      strcpy(_tmpnams[_fp->fd], tfname);
   }

   return (_fp);
}


tmpnam.c/       1202506633  0     0     0       4110      `
/*****************************************************************************/
/*  TMPNAM.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    TMPNAM   -  Generate a unique filename                                 */
/*    _GETNAME -  Generate the character string for the filename             */
/*****************************************************************************/
#include <stdio.h>
#include "file.h"
#include <string.h>

static char *_getname(int cnt, char *result);


/*****************************************************************************/
/* TMPNAM   -  Generate a unique filename                                    */
/*                                                                           */
/*    This function generates a unique filename, and can be called up to     */
/*    TMP_MAX times.                                                         */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS char *tmpnam(char *_s)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   static _DATA_ACCESS unsigned int  counter = 0;
   static _DATA_ACCESS char tfname[L_tmpnam];
   int  fd;
 
   /*------------------------------------------------------------------------*/ 
   /* Get a filename from _GETNAME                                           */
   /*------------------------------------------------------------------------*/ 
   _getname(counter++, tfname);

   /*------------------------------------------------------------------------*/ 
   /* Check to see if the filename exists.  Keep getting filenames until     */
   /* a unique one is found, or this function has reached its limit.         */
   /*------------------------------------------------------------------------*/ 
   while(((fd=open(tfname, O_RDONLY, 0666)) >= 0) && (counter < TMP_MAX))
   {
      close(fd);
      _getname(counter++, tfname);
   }
 
   if(counter >= TMP_MAX) return (NULL);
 
   /*------------------------------------------------------------------------*/ 
   /* If _S is not NULL, store the new filename in it.                       */
   /*------------------------------------------------------------------------*/ 
   if(_s)
   {
      strcpy(_s, tfname);
      return (_s);
   }
 
   return (tfname);
}


/*****************************************************************************/
/* _GETNAME -  Generate the character string for the filename                */
/*                                                                           */
/*    This function takes a number passed to it by TMPNAM, and generates a   */
/*    filename from it.  It returns a pointer to the filename.               */
/*                                                                           */
/*****************************************************************************/
static char *_getname(int cnt, char *result)
{
   /*------------------------------------------------------------------------*/
   /* Local variables                                                        */
   /*------------------------------------------------------------------------*/
   char *end   = result + L_tmpnam -1;
   char *spos;
 
   strcpy(result, P_tmpdir);
   spos = (result + strlen(result));
 
   *(spos++) = 'T';
 
   for(;cnt; cnt /= 10) *(spos++) = ((cnt % 10)+ '0');
 
   for(;spos < end; *(spos++)='0');
   *(end--) = '\0';
 
   return (result);
}

tmzone.c/       1202506633  0     0     0       553       `
/*****************************************************************************/
/*  _tz v2.70                                                                */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                  */
/*****************************************************************************/
#include <time.h>

_DATA_ACCESS TZ _tz =
{
   0,                       /* daylight */
   21600,                   /* timezone */
   "CST",                   /* tzname   */
   "DST",                   /* dstname  */
};


toascii.c/      1202506633  0     0     0       426       `
/****************************************************************************/
/*  toascii v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int toascii(int c)
{
    return(_toascii(c));
}

tolower.c/      1202506633  0     0     0       424       `
/****************************************************************************/
/*  tolower v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int tolower(int c)
{
    return(_tolower(c));
}
toupper.c/      1202506633  0     0     0       426       `
/****************************************************************************/
/*  toupper v2.70                                                           */
/*  Copyright (c) 1993-2008  Texas Instruments Incorporated                 */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

_CODE_ACCESS int toupper(int c)
{
    return(_toupper(c));
}

trgcio.h/       1202506633  0     0     0       2771      `
/*****************************************************************************/
/*  470CIO.H v2.70                                                           */
/*  Copyright (c) 1996-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/*  This file contains OTIS-driven CIO constant definitions                  */
/*****************************************************************************/

/*---------------------------------------------------------------------------*/
/* constants for the data transfer functions for the predefined driver       */
/*---------------------------------------------------------------------------*/
#define _DTOPEN    (0xF0)
#define _DTCLOSE   (0xF1)
#define _DTREAD    (0xF2)
#define _DTWRITE   (0xF3)
#define _DTLSEEK   (0xF4)
#define _DTUNLINK  (0xF5)
#define _DTGETENV  (0xF6)
#define _DTRENAME  (0xF7)
#define _DTGETTIME (0xF8)
#define _DTGETCLK  (0xF9)
#define _DTSYNC    (0xFF)

#define CIOBUFSIZ ((BUFSIZ)+32)

/*---------------------------------------------------------------------------*/
/* THESE MACROS PACK AND UNPACK SHORTS AND LONGS INTO CHARACTER ARRAYS       */
/*                                                                           */
/* THIS IS DONE BYTE REVERSED TO MAKE THE PC'S JOB EASIER AND SINCE THE      */
/*     DEVICE COULD BE BIG OR LITTLE ENDIAN                                  */
/*---------------------------------------------------------------------------*/
#define LOADSHORT(x,y,z)  { x[(z)]   = (unsigned short) (y); \
                            x[(z)+1] = (unsigned short) (y) >> 8;  }

#define UNLOADSHORT(x,z) ((short) ( (short) x[(z)] +             \
				   ((short) x[(z)+1] << 8)))

#define LOAD32(x,y,z) { x[(z)]   = (unsigned long) (y); \
                        x[(z)+1] = (unsigned long) (y) >> 8; \
                        x[(z)+2] = (unsigned long) (y) >> 16;  \
                        x[(z)+3] = (unsigned long) (y) >> 24;   }

#define UNLOAD32(x,z) ( (long) x[(z)]           +  \
                       ((long) x[(z)+1] << 8)   +  \
                       ((long) x[(z)+2] << 16)  +  \
		       ((long) x[(z)+3] << 24))

/*---------------------------------------------------------------------------*/
/* THESE MACROS CAN BE USED TO PACK AND UNPACK CHARACTER STREAMS INTO TARGET */
/* WORDS FOR MORE EFFICIENT TRANSFER.                                        */
/*---------------------------------------------------------------------------*/
#define PACKCHAR(val, base, byte) ( (base)[(byte)] = (val) )

#define UNPACKCHAR(base, byte)    ( (base)[byte] )

trgdrv.c/       1202506633  0     0     0       7660      `
/*****************************************************************************/
/*  TRGDRV.C v2.70                                                           */
/*  Copyright (c) 1996-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/****************************************************************************/
/* Functions:                                                               */
/*    HOSTopen()    -    Sends open command with arguments to the host      */
/*    HOSTclose()   -    Sends close command with arguments to the host     */
/*    HOSTread()    -    Sends read command with arguments to the host      */
/*    HOSTwrite()   -    Sends write command with arguments to the host     */
/*    HOSTlseek()   -    Sends lseek command with arguments to the host     */
/*    HOSTunlink()  -    Sends unlink command with arguments to the host    */
/*    HOSTrename()  -    Sends rename command with arguments to the host    */
/*    GETENV()      -    Get the enviroment value for the passed variable   */
/*                        name                                              */
/*    HOSTTIME()    -    Get the time from the host                         */
/*    HOSTCLK()     -    Get the target clock value (CLK register)          */
/****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <file.h>
#include <_lock.h>

#include <trgcio.h>

extern _CODE_ACCESS int HOSTopen(const char *path, unsigned flags, int llv_fd),
                        HOSTclose(int dev_fd),
                        HOSTread(int dev_fd, char *buf, unsigned count),
                        HOSTwrite(int dev_fd, const char *buf, unsigned count),
                        HOSTunlink(const char *path),
                        HOSTrename(const char *old_name, const char *new_name);

extern _CODE_ACCESS off_t HOSTlseek(int dev_fd, off_t offset, int origin);
extern _CODE_ACCESS time_t HOSTtime(void);
extern _CODE_ACCESS clock_t HOSTclock(void);

extern _CODE_ACCESS void readmsg(register unsigned char *parm,
				 register char *data);

extern _CODE_ACCESS void writemsg(unsigned char  command,
                                  register const unsigned char *parm,
                                  register const          char *data,
                                  unsigned int   length);

static _DATA_ACCESS unsigned char parmbuf[8];

/****************************************************************************/
/* HOSTOPEN()  -  Pass the open command and its arguments to the host.      */
/****************************************************************************/
_CODE_ACCESS int HOSTopen(const char *path, unsigned flags, int llv_fd)
{
   int dev_fd;
   _lock();

   LOADSHORT(parmbuf,llv_fd,0);
   LOADSHORT(parmbuf,flags,2);
   writemsg(_DTOPEN,parmbuf,(char *)path,strlen(path)+1);
					 /* SEND NULL ACROSS ALSO */
   readmsg(parmbuf,NULL);

   dev_fd = UNLOADSHORT(parmbuf,0);
   _unlock();
   return (dev_fd < 0) ? dev_fd : llv_fd;
}

/****************************************************************************/
/* HOSTCLOSE()  -  Pass the close command and its arguments to the host.    */
/****************************************************************************/
_CODE_ACCESS int HOSTclose(int dev_fd)
{
   int result;
   _lock();

   LOADSHORT(parmbuf,dev_fd,0);

   writemsg(_DTCLOSE,parmbuf,NULL,0);
   readmsg(parmbuf,NULL);

   result = UNLOADSHORT(parmbuf,0);
   _unlock();
   return result;
}

/****************************************************************************/
/* HOSTREAD()  -  Pass the read command and its arguments to the host.      */
/****************************************************************************/
_CODE_ACCESS int HOSTread(int dev_fd, char *buf, unsigned count)
{
   int result;
   _lock();

   if (count > BUFSIZ) count = BUFSIZ;

   LOADSHORT(parmbuf,dev_fd,0);
   LOADSHORT(parmbuf,count,2);

   writemsg(_DTREAD,parmbuf,NULL,0);
   readmsg(parmbuf,buf);

   result = UNLOADSHORT(parmbuf,0);
   _unlock();
   return result;
}

/****************************************************************************/
/* HOSTWRITE()  -  Pass the write command and its arguments to the host.    */
/****************************************************************************/
_CODE_ACCESS int HOSTwrite(int dev_fd, const char *buf, unsigned count)
{
   int result;
   _lock();

   if (count > BUFSIZ) count = BUFSIZ;

   LOADSHORT(parmbuf,dev_fd,0);
   LOADSHORT(parmbuf,count,2);
   writemsg(_DTWRITE,parmbuf,(char *)buf,count);
   readmsg(parmbuf,NULL);

   result = UNLOADSHORT(parmbuf,0);
   _unlock();
   return result;
}

/****************************************************************************/
/* HOSTLSEEK()  -  Pass the lseek command and its arguments to the host.    */
/****************************************************************************/
_CODE_ACCESS off_t HOSTlseek(int dev_fd, off_t offset, int origin)
{
   off_t result;
   _lock();

   LOADSHORT(parmbuf,dev_fd,0);
   LOAD32(parmbuf,offset,2);
   LOADSHORT(parmbuf,origin,6);

   writemsg(_DTLSEEK,parmbuf,NULL,0);
   readmsg(parmbuf,NULL);

   result = UNLOAD32(parmbuf,0);
   _unlock();
   return result;
}

_CODE_ACCESS int HOSTunlink(const char *path)
{
   int result;
   _lock();

   writemsg(_DTUNLINK,parmbuf,(char *)path,strlen(path) + 1);
   readmsg(parmbuf,NULL);

   result = UNLOADSHORT(parmbuf,0);
   _unlock();
   return result;
}

_CODE_ACCESS int HOSTrename(const char *old, const char *new)
{
   char combined[100];
   int  length; 
   int  result;
   _lock();

   strcpy(combined,old);
   length = strlen(old)+1;
   strcpy(combined+length,new);
   length += strlen(new) + 1;

   writemsg(_DTRENAME,parmbuf,combined,length);
                                                 /*SEND NULL ACROSS ALSO*/
   readmsg(parmbuf,NULL);

   result = UNLOADSHORT(parmbuf,0);
   _unlock();
   return result;
}

/****************************************************************************/
/* GETENV()  -  Get the enviroment value for the passed variable name       */
/****************************************************************************/
_CODE_ACCESS char *getenv(const char *_string)
{
   static _DATA_ACCESS char result[200];
   _lock();

   writemsg(_DTGETENV,parmbuf,(char *)_string,strlen(_string) + 1);
   readmsg(parmbuf,result);

   _unlock();
   return strlen(result) ? result : 0;
}

/****************************************************************************/
/* HOSTTIME()  -  Get the time from the host                                */
/****************************************************************************/
_CODE_ACCESS time_t HOSTtime(void)
{
   time_t result;
   _lock();

   writemsg(_DTGETTIME,parmbuf,NULL,0);
   readmsg(parmbuf, NULL);

   result = (time_t)(UNLOAD32(parmbuf,0));
   _unlock();
   return result;
}

/****************************************************************************/
/* HOSTclock()  -  Get the current number of clock ticks                    */
/****************************************************************************/
_CODE_ACCESS clock_t HOSTclock(void)
{
   clock_t result;
   _lock();

   writemsg(_DTGETCLK,parmbuf,NULL,0);
   readmsg(parmbuf, NULL);

   result = (clock_t)(UNLOAD32(parmbuf,0));
   _unlock();
   return result;
}
trgmsg.c/       1202506633  0     0     0       4533      `
/*****************************************************************************/
/*  470MSG.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Bottom level data transfer routines for host communication with the       */
/* target.                                                                   */
/*                                                                           */
/* Functions:                                                                */
/*  writemsg()  -  Sends the passed data and parameters on to the host.      */
/*  readmsg()   -  Reads the data and parameters passed from the host.       */
/*****************************************************************************/
#include <stdio.h>
#include <trgcio.h>

unsigned int _CIOBUF_[CIOBUFSIZ/sizeof(unsigned int)];


/***************************************************************************/
/*                                                                         */
/*  WRITEMSG()  -  Sends the passed data and parameters on to the host.    */
/*                                                                         */
/***************************************************************************/
void writemsg(unsigned char  command,
              register const unsigned char *parm,
              register const          char *data,
              unsigned int            length)
{
   unsigned char *p = (unsigned char *)(_CIOBUF_+1);
   unsigned int i;

   /***********************************************************************/
   /* THE LENGTH IS WRITTEN AS A TARGET INT                               */
   /***********************************************************************/ 
   _CIOBUF_[0] = length;
   
   /***********************************************************************/ 
   /* THE COMMAND IS WRITTEN AS A TARGET BYTE                             */
   /***********************************************************************/ 
   *p++ = command;
   
   /***********************************************************************/ 
   /* PACK THE PARAMETERS AND DATA SO THE HOST READS IT AS BYTE STREAM    */
   /***********************************************************************/ 
   for (i = 0; i < 8; i++)      PACKCHAR(*parm++, p, i);
   for (i = 0; i < length; i++) PACKCHAR(*data++, p, i+8);
   
   /***********************************************************************/
   /* THE BREAKPOINT THAT SIGNALS THE HOST TO DO DATA TRANSFER            */
   /***********************************************************************/
#if defined(EMBED_CIO_BP)
   __asm("         .global C$$IOE$$");
#if defined(__32bis__)
   __asm("C$$IOE$$:.word 0xDEFED0FE");
#else
   __asm("	 .align  4");
#if defined(__big_endian__)
   __asm("C$$IOE$$:.half 0xDEFE");
#else
   __asm("C$$IOE$$:.half 0xD0FE");
#endif /* __big_endian__ */
#endif /* __32bis__      */

#else  /* !EMBED_CIO_BP */
   __asm("	  .global C$$IO$$");
   __asm("C$$IO$$: nop");
#endif
}



/***************************************************************************/
/*                                                                         */
/*  READMSG()   -  Reads the data and parameters passed from the host.     */
/*                                                                         */
/***************************************************************************/
void readmsg(register unsigned char *parm,
	     register char          *data)
{
   unsigned char *p = (unsigned char *)(_CIOBUF_+1);
   unsigned int   i;
   unsigned int   length;
   
   /***********************************************************************/
   /* THE LENGTH IS READ AS A TARGET INT                                  */
   /***********************************************************************/
   length = _CIOBUF_[0];
    
   /***********************************************************************/
   /* UNPACK THE PARAMETERS AND DATA                                      */
   /***********************************************************************/
   for (i = 0; i < 8; i++) *parm++ = UNPACKCHAR(p, i);
   if (data != NULL) 
      for (i = 0; i < length; i++) *data++ = UNPACKCHAR(p, i+8);
}

typeinfo/       1202506633  0     0     0       1589      `
/*****************************************************************************/
/* typeinfo  v2.70                                                           */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _TYPEINFO
#define _TYPEINFO

#ifndef __embedded_cplusplus

#include <stdexcept>

namespace std 
{
   class bad_cast   {};
   class bad_typeid {};

#pragma define_type_info
   class type_info 
   {
      public:
	 virtual ~type_info();
	 bool operator==(const type_info& rhs) const;
	 bool operator!=(const type_info& rhs) const;
	 bool before(const type_info& rhs) const;
	 const char* name() const;
      protected:
	 type_info(const type_info& rhs);
      private:
	 type_info& operator=(const type_info& rhs);
   };

//   class bad_cast : public exception 
//   {
//      public:
//	 bad_cast() throw();
//	 bad_cast(const bad_cast&) throw();
//	 bad_cast& operator=(const bad_cast&) throw();
//	 virtual ~bad_cast() throw();
//	 virtual const char* what() const throw();
//   };
//
//   class bad_typeid : public exception 
//   {
//      public:
//	 bad_typeid() throw();
//	 bad_typeid(const bad_typeid&) throw();
//	 bad_typeid& operator=(const bad_typeid&) throw();
//	 virtual ~bad_typeid() throw();
//	 virtual const char* what() const throw();
//   };

   void dump_type_info(const type_info& info); // Debug func, should be removed
}

#endif /* __embedded_cplusplus */
#endif /*_TYPEINFO */

typeinfo_.cpp/  1202506633  0     0     0       4853      `
/*****************************************************************************/
/* TYPEINFO     v2.70                                                        */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/
#if 0

/*****************************************************************************/
/* The name of this file is typeinfo_.cpp to avoid an implicit rule problem  */
/* with gmake when typeinfo.cpp has a timestamp later than typeinfo.         */
/*****************************************************************************/

#endif
#ifndef __embedded_cplusplus

#include <cstring>
#include <typeinfo>
#include "rtti.h"

/*****************************************************************************/
/* ~TYPE_INFO - Virtual destructor.  Should never be called directly.        */
/*****************************************************************************/
std::type_info::~type_info()  { }

/******************************************************************************/
/* OPERATOR== - Returns TRUE if the type represented by the given object      */
/*              represents the same type this object represents.              */
/******************************************************************************/
bool std::type_info::operator==(const type_info& rhs) const
{
   const TYPE_INFO_IMPL *class_info1 = (const TYPE_INFO_IMPL *)this;
   const TYPE_INFO_IMPL *class_info2 = (const TYPE_INFO_IMPL *)&rhs;

   return matching_type_info(class_info1, class_info2);
}

/******************************************************************************/
/* OPERATOR!= - Returns TRUE if the type represented by the given object      */
/*              represents a different type than this object represents.      */
/******************************************************************************/
bool std::type_info::operator!=(const type_info& rhs) const
{
   const TYPE_INFO_IMPL *class_info1 = (const TYPE_INFO_IMPL *)this;
   const TYPE_INFO_IMPL *class_info2 = (const TYPE_INFO_IMPL *)&rhs;

   return !matching_type_info(class_info1, class_info2);
}

/******************************************************************************/
/* BEFORE - Return TRUE if the type this object represents precedes the type  */
/*          represented by the given object, according to a collating         */
/*          sequence.                                                         */
/*                                                                            */
/*  This is implemented by separating types into those that are local types   */
/*  and external. In the first case, the addresses of the type_info structures*/
/*  are always unique.  In the latter, there may be more than 1 copy of the   */
/*  type_info structure for a single type.  Types in the first category are   */
/*  always greater than those in the second.  Within the first category, a    */
/*  collating sequence is determined by comparing the addresses of the        */
/*  type's type_info structure.  Within the second, a collating sequence is   */
/*  based upon the lexical ordering of the type's name.                       */
/******************************************************************************/
bool std::type_info::before(const type_info& rhs) const
{
   const TYPE_INFO_IMPL *class_info1 = (const TYPE_INFO_IMPL *)this;
   const TYPE_INFO_IMPL *class_info2 = (const TYPE_INFO_IMPL *)&rhs;

   if (class_info1->flags & TIF_LOCAL)
      if (class_info2->flags & TIF_LOCAL)
         return class_info1 < class_info2 ? true : false;
      else
         return false;
   else
      if (class_info2->flags & TIF_LOCAL)
         return true;
      else
         return strcmp(class_info1->name, class_info2->name) < 0 ? true : false;
}

/*****************************************************************************/
/* NAME -  Returns the source level name of the type the object represents.  */
/*****************************************************************************/
const char *std::type_info::name() const
{
   const TYPE_INFO_IMPL *class_info = (const TYPE_INFO_IMPL *)this;

   return class_info->name;
}

/*****************************************************************************/
/* MATCHING_TYPE_INFO - Determines if two type entries refer to same type.   */
/*****************************************************************************/
bool std::matching_type_info(const TYPE_INFO_IMPL *cti1, 
			     const TYPE_INFO_IMPL *cti2)
{
   return (cti1 == cti2 || 
	   (!(cti1->flags & TIF_LOCAL) &&
	    !(cti2->flags & TIF_LOCAL) &&
	    !strcmp(cti1->name, cti2->name)));
}

#endif /* __embedded_cplusplus */

u_div16.asm/    1202506633  0     0     0       2794      `
;******************************************************************************
;* U_DIV16.ASM  - 16 BIT STATE -  v2.70                                       *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

	.if $$isdefed("__small_divide__")
;****************************************************************************
;* U$DIV/U$MOD - DIVIDE TWO UNSIGNED 32 BIT NUMBERS - SMALL CODE SIZE VERSION
;*
;****************************************************************************
;*
;*   o DIVIDEND IS IN r0
;*   o DIVISOR IS IN r1
;*
;*   o QUOTIENT IS PLACED IN r1
;*   o REMAINDER IS PLACED IN r0
;*
;*   o DIVIDE BY ZERO RETURNS ZERO
;*
;****************************************************************************
	.state16

	.global U$DIV
	.global U$MOD

dvs     .set    r2              ; WORK COPY OF THE DIVISOR (SHIFTED)
quo     .set    r3              ; WORK COPY OF THE QUOTIENT
max     .set    r4              ; MAX DIVIDEND FOR DIVISOR SHIFT AMOUNT

U$DIV:	.asmfunc stack_usage(16)
U$MOD:
        PUSH    {r2-r4, lr}             ; SAVE CONTEXT
 
        MOV     dvs, r1                 ; CHECK FOR DIVISION BY ZERO
        BEQ     _div_by_zero_           ;

        MOV     quo, #0                 ; INITIALIZE THE QUOTIENT

        MOV     max, #1                 ;
        LSL     max, max, #31           ;
        CMP     r0, max                 ; SETUP THE MAX DIVIDEND WHEN
        BCS     _udvs_loop_             ; CALCULATING THE DIVISOR SHIFT
        MOV     max, r0                 ; AMOUNT

_udvs_loop_:
        CMP     max, dvs                ;
        BLS     _udiv_                  ;
        LSL     dvs, dvs, #1            ; CALCULATE THE MAXIMUM DIVISOR
        B       _udvs_loop_             ; SHIFT AMOUNT

_udiv_:
        CMP     r0, dvs                 ; IF DIVIDEND IS LARGER THAN DIVISOR,
        ADC     quo, quo                ;  SHIFT A 1 INTO THE QUOTIENT, ELSE 0
        CMP     r0, dvs                 ; IF DIVIDEND IS LARGER THAN DIVISOR,
        BCC     _cc1_                   ;  SUBTRACT THE DIVISOR,
        SUB     r0, r0, dvs             ; 
_cc1_:  CMP     r1, dvs                 ; IF THERE IS SHIFTED DIVISOR, THEN
        BCS     _cc2_                   ;
        LSR     dvs, dvs, #1            ; CONTINUE THE LOOP.
        B       _udiv_                  ; 
_cc2_:  MOV     r1, quo                 ; ELSE DONE. PLACE THE QUOTIENT
        POP     {r2-r4, pc}             ; IT ITS RIGHT PLACE.

_div_by_zero_:
        MOV     r0, #0                  ; DIVIDE BY ZERO RETURNS ZERO
        POP     {r2-r4, pc}             ;

	.endasmfunc

	.endif
        .end
u_div32.asm/    1202506633  0     0     0       3261      `
;******************************************************************************
;* U_DIV32.ASM  - 32 BIT STATE -  v2.70                                       *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* U_DIV/U_MOD - DIVIDE TWO UNSIGNED 32 BIT NUMBERS.
;* U$DIV/U$MOD - 16 BIT STATE INTERFACE TO U_DIV/U_MOD.
;*  
;****************************************************************************
;*
;*   o DIVIDEND IS IN r0
;*   o DIVISOR IS IN r1
;*
;*   o QUOTIENT IS PLACED IN r1
;*   o REMAINDER IS PLACED IN r0
;*
;*   o DIVIDE BY ZERO RETURNS ZERO
;*
;****************************************************************************
	.global U_DIV
	.global U_MOD

dvs	.set	r2		; WORK COPY OF THE DIVISOR (SHIFTED)
quo	.set	lr		; WORK COPY OF THE QUOTIENT

	.if !$$isdefed("__small_divide__")
	.global U$DIV
	.global U$MOD

	.align
	.state16
U$DIV:  .asmfunc
U$MOD:	BX	pc			; CHANGE TO 32-BIT STATE
	NOP
	.endasmfunc
	.endif
	
	.state32
U_DIV:	.asmfunc stack_usage(8)
U_MOD:	STMFD	sp!, {dvs, lr}		; SAVE CONTEXT

	MOVS	dvs, r1			; CHECK FOR DIVISION BY ZERO
	BEQ	div_by_zero		;

	MOV	quo, #0			; INITIALIZE THE QUOTIENT

	CMP	dvs, r0,  LSR #16	; CALCULATE THE MAXIMUM DIVISOR
	MOVLS	dvs, dvs, LSL #16	; SHIFT AMOUNT WITH PSEUDO BINARY
	CMP	dvs, r0,  LSR #8	; SEARCH.
	MOVLS	dvs, dvs, LSL #8	;

	CMP	dvs, r0, LSR #1		; NOW FIND EXACTLY WHERE THE SHIFTED
	BHI	mod1			; DIVISOR SHOULD BE SO THAT WE CAN
	CMP	dvs, r0, LSR #2		; JUMP INTO THE CORRECT LOCATION
	BHI	mod2			; OF THE UNROLLED DIVIDE LOOP.
	CMP	dvs, r0, LSR #3		;
	BHI	mod3			;
	CMP	dvs, r0, LSR #4		;
	BHI	mod4			;
	CMP	dvs, r0, LSR #5		;
	BHI	mod5			;
	CMP	dvs, r0, LSR #6		;
	BHI	mod6			;
	CMP	dvs, r0, LSR #7		;
	BHI	mod7			;

divl:					; DIVIDE LOOP UNROLLED 8 TIMES
	CMP	r0, dvs, LSL #7		; IF DIVIDEND IS LARGER THAN DIVISOR,
	ADC	quo, quo, quo		; SHIFT A 1 INTO THE QUOTIENT AND 
	SUBCS	r0, r0, dvs, LSL #7	; SUBTRACT THE DIVISOR, ELSE SHIFT A 0.
	CMP	r0, dvs, LSL #6		;

mod7:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #6	;
	CMP	r0, dvs, LSL #5		;

mod6:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #5	;
	CMP	r0, dvs, LSL #4		;

mod5:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #4	;
	CMP	r0, dvs, LSL #3		;

mod4:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #3	;
	CMP	r0, dvs, LSL #2		;

mod3:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #2	;
	CMP	r0, dvs, LSL #1		;

mod2:	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs, LSL #1	;

mod1:	CMP	r0, dvs			;
	ADC	quo, quo, quo		;
	SUBCS	r0, r0, dvs		;

	CMP	r1, dvs			; IF THERE IS SHIFTED DIVISOR, THEN
	MOVCC	dvs, dvs, LSR #8	; CONTINUE THE LOOP.
	BCC	divl			;

	MOV	r1, quo			; ELSE WE ARE DONE. PLACE THE QUOTIENT
					; IN ITS RIGHT PLACE.
	.if !$$isdefed("__small_divide__")
	LDMFD	sp!, {dvs, lr}
	BX	lr
	.else
	LDMFD	sp!, {dvs, pc}
	.endif
	
div_by_zero:
	MOV	r0, #0			; DIVIDE BY ZERO RETURNS ZERO
	.if !$$isdefed("__small_divide__")
	LDMFD	sp!, {dvs, lr}
	BX	lr
	.else
	LDMFD	sp!, {dvs, pc}
	.endif

	.endasmfunc
	.end

u_tofd16.asm/   1202506633  0     0     0       3060      `
;******************************************************************************
;* U_TOFD16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* U$TOFD - CONVERT AN UNSIGNED 32 BIT INTEGER INTO AN IEEE 754 FORMAT
;*          DOUBLE PRECISION FLOATING POINT                 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0:r1
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global	U$TOFD

e0	.set	r2

U$TOFD:	.asmfunc stack_usage(4)
	CMP	r0, #0			; IF ZERO, RETURN ZERO
	BNE	$1			;
	MOV	r1, #0			;
	MOV	pc, lr			;

$1:	PUSH	{r2}			; SAVE CONTEXT

	MOV	e0, #0x4		; SETUP THE EXPONENT FIELD
	LSL	e0, e0, #8		;
	ADD	e0, #0x1F		;

loop:	SUB	e0, e0, #0x1		; NORMALIZE THE MANTISSA
	LSL	r0, r0, #1		; ADJUSTING THE EXPONENT, ACCORDINGLY
	BCC	loop			;

done:	LSL	r1, r0, #20		; SETUP LOW HALF OF RESULT
	LSR	r0, r0, #12		; SETUP HIGH HALF OF RESULT
	LSL	e0, e0, #20		;
	ORR	r0, e0			;

	POP	{r2}			;
	MOV	pc, lr			;

	.endasmfunc
	.end
u_tofd32.asm/   1202506633  0     0     0       2991      `
;******************************************************************************
;* U_TOFD32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* U_TOFD - CONVERT AN UNSIGNED 32 BIT INTEGER INTO AN IEEE 754 FORMAT
;*          DOUBLE PRECISION FLOATING POINT                 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0
;*   o RESULT IS RETURNED IN r0:r1
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global U_TOFD

U_TOFD:	.asmfunc
	CMP	r0, #0			; IF ZERO, RETURN ZERO
	MOVEQ	r1, #0			;
	MOVEQ	pc, lr			;

	MOV	r1, r0			; MOVE INPUT INTO r1
	MOV	r0, #0x1F		; SETUP THE EXPONENT
	ADD	r0, r0, #0x00000400	;

loop:	MOVS	r1, r1, LSL #1		; NORMALIZE THE MANTISSA
	SUB	r0, r0, #0x1		; ADJUSTING THE EXPONENT, ACCORDINGLY
	BCC	loop			;

	MOV	r0, r0, LSL #20		; SETUP HIGH HALF OF RESULT
	ORR	r0, r0, r1, LSR #12	;
	MOV	r1, r1, LSL #20		; SETUP LOW HALF OF RESULT

	MOV	pc, lr			;

	.endasmfunc
	.end

u_tofs16.asm/   1202506633  0     0     0       2703      `
;******************************************************************************
;* U_TOFS16.ASM  - 16 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* U$TOFS - CONVERT A 32 BIT UNSIGNED INTEGER TO AN IEEE 754 FORMAT
;*	    SINGLE PRECISION FLOATING POINT NUMBER
;****************************************************************************
;*
;*   o INPUT OP IS IN R0
;*   o RESULT IS RETURNED IN R0
;*
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global U$TOFS

e0	.set	r1

U$TOFS: .asmfunc stack_usage(4)
	PUSH    {r1}		        ; SAVE CONTEXT

	MOV	e0, #0x9E		; SET THE EXPONENT FIELD

	CMP     r0, #0                  ; IF ZERO, RETURN ZERO
	BMI	cont			;
        BNE     loop			;
	POP	{r1}			;
        MOV     pc, lr                  ;
 
loop:   SUB     e0, #1                  ; NORMALIZE THE MANTISSA
        LSL     r0, r0, #1              ; ADJUSTING THE EXPONENT, ACCORDINGLY
        BPL     loop                    ;

cont:	ADD     r0, #0x80               ; ADD 1/2 TO ROUND
        BCC     $1			;
        ADD     e0, #0x1                ; AND ADJUST THE EXPONENT ACCORDINGLY
        B       $2			;
 
$1:	LSL     r0, r0, #1              ; MASK IMPLIED 1 OUT OF THE MANTISSA
 
$2:	LSR     r0, r0, #9              ; PACK THE MANTISSA
        LSL     e0, e0, #23             ;
        ORR     r0, e0                  ; PACK THE EXPONENT

        POP     {r1}	 	        ; RESTORE CONTEXT
	MOV	pc, lr			;

	.endasmfunc
	.end

u_tofs32.asm/   1202506633  0     0     0       2376      `
;******************************************************************************
;* U_TOFS32.ASM  - 32 BIT STATE -  v2.70                                      *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* U_TOFS - CONVERT A 32 BIT UNSIGNED INTEGER TO AN IEEE 754 FORMAT
;*          SINGLE PRECISION FLOATING POINT NUMBER
;****************************************************************************
;*
;*   o INPUT OP IS IN R0
;*   o RESULT IS RETURNED IN R0
;*
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global U_TOFS

e0	.set	lr

U_TOFS:	.asmfunc stack_usage(4)
	CMP	r0, #0			; 
	MOVEQ	pc, lr			; IF ZERO, RETURN ZERO

	STR	lr, [sp, #-4]!		; SAVE CONTEXT ON STACK

	MOV	e0, #0x9E		; SET THE EXPONENT FIELD

	BMI	cont			;
loop:	MOVS	r0, r0, LSL #1		; NORMALIZE THE MANTISSA
	SUB	e0, e0, #1		; ADJUSTING THE EXPONENT, ACCORDINGLY
	BPL	loop			;

cont:	ADDS	r0, r0, #0x00000080	; ADD 1/2 TO ROUND
	ADDCS	e0, e0, #0x1		; AND ADJUST THE EXPONENT ACCORDINGLY

	MOVCC	r0, r0, LSL #1		; MASK THE IMPLIED ONE IN THE MANTISSA
	MOV	r0, r0, LSR #9		; PACK THE MANTISSA
	ORR	r0, r0, e0, LSL #23	; PACK THE EXPONENT

	LDR	pc, [sp], #4		; RESTORE CONTEXT

	.endasmfunc
	.end
ull_div16.asm/  1202506633  0     0     0       1324      `
;******************************************************************************
;* ULL_DIV16.ASM  - 16 BIT STATE -  V1.16                                     *
;* Copyright (c) 1995-1997 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* ULL$DIV/ULL$MOD - DIVIDE TWO UNSIGNED 64 BIT NUMBERS.
;*
;****************************************************************************
;*
;*   o DIVIDEND IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o DIVISOR IS IN r2:r3 (r3:r2 IF LITTLE ENDIAN)
;*
;*   o QUOTIENT IS PLACED IN r2:r3  (r3:r2 IF LITTLE ENDIAN)
;*   o REMAINDER IS PLACED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*
;*   o DIVIDE BY ZERO RETURNS ZERO
;*
;****************************************************************************
	.state16

	.global ULL$DIV
	.global ULL$MOD
    .global ULL_DIV
    .global ULL_MOD

ULL$DIV: .asmfunc stack_usage(4)
ULL$MOD:
        PUSH {lr}
	NOP
	BX  pc		        ; Change to 32-bit state
	NOP
	.align
	.state32
	BL  ULL_MOD             ; and call 32-bit DIV/MOD routine.
	ADD lr, pc, #0x1
	BX  lr                  ; Change the state back to 16-bit
	.state16
	POP {pc}

	.endasmfunc
	.end
ull_div32.asm/  1202506633  0     0     0       13225     `
;******************************************************************************
;* ULL_DIV32.ASM  - 32 BIT STATE -  v2.70                                     *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* ULL_DIV/ULL_MOD - DIVIDE TWO UNSIGNED 64 BIT NUMBERS.
;*  
;****************************************************************************
;*
;*   o DIVIDEND IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o DIVISOR IS IN r2:r3  (r3:r2 IF LITTLE ENDIAN)
;*
;*   o QUOTIENT IS PLACED IN r2:r3  (r3:r2 IF LITTLE ENDIAN)
;*   o REMAINDER IS PLACED IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*
;*   o DIVIDE BY ZERO RETURNS ZERO
;*
;****************************************************************************
	.state32

	.global ULL_DIV
	.global ULL_MOD

	.if .TMS470_LITTLE

dvnd_hi .set    r1                                  ; HIGH WORD OF DIVIDEND
dvnd_lo .set    r0                                  ; LOW WORD OF DIVIDEND
idvs_hi .set    r3				    ; HIGH WORD OF DIVISOR
idvs_lo .set    r2				    ; LOW WORD OF DIVISOR
rq_hi   .set    r3			  	    ; HIGH WORD OF RESULT QUO
rq_lo   .set    r2			  	    ; LOW WORD OF RESULT QUO
rr_hi   .set    r1				    ; HIGH WORD OF RESULT REM
rr_lo   .set    r0				    ; HIGH WORD OF RESULT REM

	.else

dvnd_hi .set    r0                                  ; HIGH WORD OF DIVIDEND
dvnd_lo .set    r1                                  ; LOW WORD OF DIVIDEND
idvs_hi .set    r2				    ; HIGH WORD OF DIVISOR
idvs_lo .set    r3				    ; LOW WORD OF DIVISOR
rq_hi   .set    r2			  	    ; HIGH WORD OF RESULT QUO
rq_lo   .set    r3			  	    ; LOW WORD OF RESULT QUO
rr_hi   .set    r0				    ; HIGH WORD OF RESULT REM
rr_lo   .set    r1				    ; HIGH WORD OF RESULT REM

	.endif


q_hi    .set    LR                                  ; HIGH WORD OF QUOTIENT
q_lo    .set    r8                                  ; LOW WORD OF QUOTIENT
;dvnd_hi .set    r0                                  ; HIGH WORD OF DIVIDEND
;dvnd_lo .set    r1                                  ; LOW WORD OF DIVIDEND
dvsr_hi .set    r4                                  ; HIGH WORD OF DIVISOR COPY
dvsr_lo .set    r5                                  ; LOW WORD OF DIVISOR COPY
tmp_hi  .set    r6                                  ; HIGH WORD OF TEMP
tmp_lo  .set    r7                                  ; LOW WORD OF TEMP

ULL_DIV: .asmfunc stack_usage(24)
ULL_MOD:
        STMFD     SP!, {r4-r8, lr}                  ;
        MOV       dvsr_hi, idvs_hi                  ; MAKE A COPY OF INPUT 
        MOV       dvsr_lo, idvs_lo                  ; DIVISOR (R2:R3) INTO DVSR

        CMP       dvsr_hi, dvnd_hi                  ; IF DVND < DVSR,
        CMPEQ     dvsr_lo, dvnd_lo                  ; RETURN Q=0, R=DVND 
        MOVHI     rq_hi, #0                         ;
        MOVHI     rq_lo, #0                         ;
        LDMHIFD   SP!, {r4-r8, pc}

        CMP       dvsr_hi, #0                       ; IF DVSR IS 0,
        CMPEQ     dvsr_lo, #0                       ; RETURN Q=0, R=0 
        MOVEQ     rr_lo, #0                         ;
        MOVEQ     rr_hi, #0                         ;
        LDMEQFD   SP!, {r4-r8, pc}                  ;

        MOV       q_lo, #0                          ; INITIALIZE THE QUOTIENT
        MOV       q_hi, #0                          ; TO ZERO

        ; CALCULATE THE MAXIMUM DIVISOR SHIFT AMOUNT WITH PSEUDO BINARY SEARCH
        ; IF DVND >> 32 > DVSR THEN DVSR = DVSR << 32

        CMP       dvsr_hi, #0                       ; IF (DVSR_HI == 0 AND 
        CMPEQ     dvsr_lo, dvnd_hi                  ;          DVSRLO < DVND_HI)
        MOVLS     dvsr_hi, dvsr_lo                  ;    DVSR_HI = DVSRLO
        MOVLS     dvsr_lo, #0                       ;    DVSR_LO = 0

        ; IF DVND >> 16 > DVSR THEN DVSR = DVSR << 16
        MOV       tmp_lo, dvnd_lo, LSR #16          ; SHIFT DVND BY 16 INTO
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #16  ; TMP                   
        MOV       tmp_hi, dvnd_hi, LSR #16          ; 
        CMP       dvsr_hi, tmp_hi                   ; COMPARE DVSR WITH TMP
        CMPEQ     dvsr_lo, tmp_lo                   ;
        MOVLS     dvsr_hi, dvsr_hi, LSL #16         ; SET DVSR = DVSR << 16
        ORRLS     dvsr_hi, dvsr_hi, dvsr_lo, LSR #16;
        MOVLS     dvsr_lo, dvsr_lo, LSL #16         ;

        ; IF DVND >> 16 > DVSR THEN DVSR = DVSR << 16
        MOV       tmp_lo, dvnd_lo, LSR #8           ; SHIFT DVND BY 16 INTO
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #24  ; TMP
        MOV       tmp_hi, dvnd_hi, LSR #8           ; 
        CMP       dvsr_hi, tmp_hi                   ; COMPARE DVSR WITH TMP
        CMPEQ     dvsr_lo, tmp_lo                   ;
        MOVLS     dvsr_hi, dvsr_hi, LSL #8          ; SET DVSR = DVSR << 8
        ORRLS     dvsr_hi, dvsr_hi, dvsr_lo, LSR #24;
        MOVLS     dvsr_lo, dvsr_lo, LSL #8          ;

        ; NOW FIND EXACTLY WHERE THE SHIFTED DIVISOR SHOULD BE SO THAT WE CAN
        ; JUMP INTO THE CORRECT LOCATION OF THE UNROLLED DIVIDE LOOP.
        MOV       tmp_lo, dvnd_lo, LSR #1           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #31  ;
        MOV       tmp_hi, dvnd_hi, LSR #1           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod1                              ;

        MOV       tmp_lo, dvnd_lo, LSR #2           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #30  ;
        MOV       tmp_hi, dvnd_hi, LSR #2           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod2                              ; BRANCHING INTO DIVIDE LOOP

        MOV       tmp_lo, dvnd_lo, LSR #3           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #29  ;
        MOV       tmp_hi, dvnd_hi, LSR #3           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod3                              ;

        MOV       tmp_lo, dvnd_lo, LSR #4           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #28  ;
        MOV       tmp_hi, dvnd_hi, LSR #4           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod4                              ;

        MOV       tmp_lo, dvnd_lo, LSR #5           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #27  ;
        MOV       tmp_hi, dvnd_hi, LSR #5           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod5                              ;

        MOV       tmp_lo, dvnd_lo, LSR #6           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #26  ;
        MOV       tmp_hi, dvnd_hi, LSR #6           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod6                              ;

        MOV       tmp_lo, dvnd_lo, LSR #7           ;
        ORR       tmp_lo, tmp_lo, dvnd_hi, LSL #25  ;
        MOV       tmp_hi, dvnd_hi, LSR #7           ;
        CMP       dvsr_hi, tmp_hi                   ;
        CMPEQ     dvsr_lo, tmp_lo                   ;
        BHI       mod7                              ;

        ; THE DIVIDE LOOP IS UNROLLED 8 TIMES.
        ; IF DIVIDEND IS LARGER THAN DIVISOR, SHIFT A 1 INTO THE QUOTIENT
        ; AND SUBTRACT THE DIVISOR, ELSE SHIFT A 0 INTO THE QUOTIENT.
divll:
        MOV       tmp_hi, dvsr_hi, LSL #7           ; LEFT SHIFT DVSR BY 7 
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #25  ; INTO TMP
        MOV       tmp_lo, dvsr_lo, LSL #7           ;
        CMP       dvnd_hi, tmp_hi                   ; IF (DVND >= TMP)      
        CMPEQ     dvnd_lo, tmp_lo                   ; 
        BCC       $1                                ; 
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;    DVND = DVND - TMP
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$1:
        ADCS      q_lo, q_lo, q_lo                  ; SHIFT THE CARRY BIT DEFED
        ADC       q_hi, q_hi, q_hi                  ; BY CMP OR SBCS INTO THE 
                                                    ; QUOTIENT

mod7:
        MOV       tmp_hi, dvsr_hi, LSL #6           ; UNROLLED LOOP 
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #26  ;
        MOV       tmp_lo, dvsr_lo, LSL #6           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $2                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$2:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;
        
mod6:
        MOV       tmp_hi, dvsr_hi, LSL #5           ;
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #27  ;
        MOV       tmp_lo, dvsr_lo, LSL #5           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $3                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$3:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;
        
mod5:
        MOV       tmp_hi, dvsr_hi, LSL #4           ;
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #28  ;
        MOV       tmp_lo, dvsr_lo, LSL #4           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $4                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$4:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;
        
mod4:
        MOV       tmp_hi, dvsr_hi, LSL #3           ;
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #29  ;
        MOV       tmp_lo, dvsr_lo, LSL #3           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $5                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$5:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;
        
mod3:
        MOV       tmp_hi, dvsr_hi, LSL #2           ;
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #30  ;
        MOV       tmp_lo, dvsr_lo, LSL #2           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $6                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$6:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;
        
mod2:
        MOV       tmp_hi, dvsr_hi, LSL #1           ;
        ORR       tmp_hi, tmp_hi, dvsr_lo, LSR #31  ;
        MOV       tmp_lo, dvsr_lo, LSL #1           ;
        CMP       dvnd_hi, tmp_hi                   ;
        CMPEQ     dvnd_lo, tmp_lo                   ;

        BCC       $7                                ;
        SUBS      dvnd_lo, dvnd_lo, tmp_lo          ;
        SBCS      dvnd_hi, dvnd_hi, tmp_hi          ;
$7:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;

mod1:
        CMP       dvnd_hi, dvsr_hi                  ;
        CMPEQ     dvnd_lo, dvsr_lo                  ;
        
        BCC       $8                                ;
        SUBS      dvnd_lo, dvnd_lo, dvsr_lo         ;
        SBCS      dvnd_hi, dvnd_hi, dvsr_hi         ;
$8:
        ADCS      q_lo, q_lo, q_lo                  ;
        ADC       q_hi, q_hi, q_hi                  ;

        ; IF THERE IS SHIFTED DIVISOR, THEN UNSHIFT THE DIVISOR BY 8 AND
        ; CONTINUE THE LOOP
        CMP       idvs_hi, dvsr_hi                  ; 
        CMPEQ     idvs_lo, dvsr_lo                  ;
        MOVCC     dvsr_lo, dvsr_lo, LSR #8          ;
        ORRCC     dvsr_lo, dvsr_lo, dvsr_hi, LSL #24;
        MOVCC     dvsr_hi, dvsr_hi, LSR #8          ;
        BCC       divll                             ;

        ; ELSE WE ARE DONE. PLACE THE QUOTIENT INTO rq_hi:rq_lo. 
	; rr_hi:rr_lo ALREADY CONTAINS THE REMAINDER.
        MOV       rq_hi, q_hi                       ;
        MOV       rq_lo, q_lo                       ;

        LDMFD   SP!, {r4-r8, pc}                    ;
	.endasmfunc
        .end


ull_tofd16.asm/ 1202506633  0     0     0       3715      `
;******************************************************************************
;* ULL_TOFD16.ASM  - 16 BIT STATE -  v2.70                                    *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* ULL$TOFD - CONVERT AN UNSIGNED 64 BIT INTEGER INTO AN IEEE 754 FORMAT
;*            DOUBLE PRECISION FLOATING POINT                 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o RESULT IS RETURNED IN r0:r1
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global	ULL$TOFD

e0	.set	r2
tmp     .set    r3
tmp2    .set    r4

ULL$TOFD: .asmfunc stack_usage(16)
        CMP	r0, #0			; IF ZERO, RETURN ZERO
	BNE	$1			;
        CMP     r1, #0                  ;
        BNE     $1
	MOV	pc, lr			;

$1:	PUSH	{r2-r4, lr}		; SAVE CONTEXT

	; IN LITTLE ENDIAN MODE THE INPUT LONG LONG VALUE IS IN R1:R0. SWAP THE
	; WORDS SO THAT WE HAVE THE LONG LONG VAULUE IN R0:R1.

	.if .TMS470_LITTLE
	MOV	tmp, r0			;
	MOV	r0, r1			;
	MOV	r1, tmp			;
	.endif

	MOV	e0, #0x4		; SETUP THE EXPONENT FIELD
	LSL	e0, e0, #8		;
	ADD	e0, #0x3F		;

loop:	SUB	e0, e0, #0x1		; NORMALIZE THE MANTISSA
        MOV     tmp2, r0                ;
	LSL	r0, r0, #1		; ADJUSTING THE EXPONENT, ACCORDINGLY
        LSR     tmp, r1, #31            ;
        ORR     r0, tmp                 ;
        LSL     r1, r1, #1              ;
        CMP     tmp2, #0                ;
	BPL	loop			;

done:	
        LSR     r1, r1, #12             ;
        LSL	tmp, r0, #20		; SETUP LOW HALF OF RESULT
        ORR     r1, tmp                 ;
	LSR	r0, r0, #12		; SETUP HIGH HALF OF RESULT
	LSL	e0, e0, #20		;
	ORR	r0, e0			;

	POP	{r2-r4, pc}		;

	.endasmfunc
	.end

ull_tofd32.asm/ 1202506633  0     0     0       3528      `
;******************************************************************************
;* ULL_TOFD32.ASM  - 32 BIT STATE -  v2.70                                    *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* ULL_TOFD - CONVERT AN UNSIGNED 64 BIT INTEGER INTO AN IEEE 754 FORMAT
;*            DOUBLE PRECISION FLOATING POINT                 
;****************************************************************************
;*
;*   o INPUT OP IS IN r0:r1 (r1:r0 IF LITTLE ENDIAN)
;*   o RESULT IS RETURNED IN r0:r1
;*
;****************************************************************************
;*
;* +------------------------------------------------------------------+
;* | DOUBLE PRECISION FLOATING POINT FORMAT                           |
;* |   64-bit representation                                          |
;* |   31 30      20 19                  0                            |
;* |   +-+----------+---------------------+                           |
;* |   |S|     E    |        M1           |                           |
;* |   +-+----------+---------------------+                           |
;* |                                                                  |
;* |   31                                0                            |
;* |   +----------------------------------+                           |
;* |   |             M2                   |                           |
;* |   +----------------------------------+                           |
;* |                                                                  |
;* |   <S>  SIGN FIELD    :          0 - POSITIVE VALUE               |
;* |                                 1 - NEGATIVE VALUE               |
;* |                                                                  |
;* |   <E>  EXPONENT FIELD: 0000000000 - ZERO IFF M == 0              |
;* |            0000000001..1111111110 - EXPONENT VALUE(1023 BIAS)    |
;* |                        1111111111 - INFINITY                     |
;* |                                                                  |
;* |   <M1:M2>  MANTISSA FIELDS:  FRACTIONAL MAGNITUDE WITH IMPLIED 1 |
;* +------------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global ULL_TOFD

ULL_TOFD: .asmfunc stack_usage(4)
        CMP	r0, #0			; IF ZERO, RETURN ZERO
        CMPEQ   r1, #0                  ;
	MOVEQ	pc, lr			;

        STMFD   sp!, {lr}               ;

	; IN LITTLE ENDIAN MODE THE INPUT LONG LONG VALUE IS IN R1:R0. SWAP THE
	; WORDS SO THAT WE HAVE THE LONG LONG VAULUE IN R0:R1.

	.if .TMS470_LITTLE
	MOV	lr, r0			;
	MOV	r0, r1			;
	MOV	r1, lr			;
	.endif

	MOV	lr, #0x3F		; SETUP THE EXPONENT
	ADD	lr, lr, #0x00000400	;

loop:	MOVS	r0, r0, LSL #1		; NORMALIZE THE MANTISSA
        ORR     r0, r0, r1, LSR #31     ;
        MOV     r1, r1, LSL #1          ;
	SUB	lr, lr, #0x1		; ADJUSTING THE EXPONENT, ACCORDINGLY
	BCC	loop			;

        MOV     r1, r1, LSR #12         ; SETUP LOW HALF OF MANTISSA
        ORR     r1, r1, r0, LSL #20     ;
        MOV     r0, r0, LSR #12         ; SETUP HIGH HALF OF MANTISSA
        ORR     r0, r0, lr, LSL #20     ; SETUP THE EXPONENT AND SIGN 

	LDMFD	sp!, {pc}               ;

	.endasmfunc
	.end
ull_tofs16.asm/ 1202506633  0     0     0       3199      `
;******************************************************************************
;* ULL_TOFS16.ASM  - 16 BIT STATE -  v2.70                                    *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* ULL$TOFS - CONVERT A 64 BIT UNSIGNED INTEGER TO AN IEEE 754 FORMAT
;*	      SINGLE PRECISION FLOATING POINT NUMBER
;****************************************************************************
;*
;*   o INPUT OP IS IN R0:R1 (r1:r0 IF LITTLE ENDIAN)
;*   o RESULT IS RETURNED IN R0
;*   o THE VALUE IN R1 IS DESTROYED
;*
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state16

	.global ULL$TOFS

e0	.set	r2
tmp     .set    r3

ULL$TOFS: .asmfunc stack_usage(12)
        PUSH    {r2, r3, lr}		; SAVE CONTEXT

	; IN LITTLE ENDIAN MODE THE INPUT LONG LONG VALUE IS IN R1:R0. SWAP THE
	; WORDS SO THAT WE HAVE THE LONG LONG VAULUE IN R0:R1.

	.if .TMS470_LITTLE
	MOV	tmp, r0			;
	MOV	r0, r1			;
	MOV	r1, tmp			;
	.endif

	MOV	e0, #0xBE		; SET THE EXPONENT FIELD

	CMP     r0, #0                  ; IF ZERO, RETURN ZERO
	BMI	cont			;
        BNE     loop			;
        CMP     r1, #0                  ;
        BNE     loop                    ;
	POP	{r2, r3, pc}		;
 
loop:   SUB     e0, #1                  ; NORMALIZE THE MANTISSA
        LSL     r0, r0, #1              ; ADJUSTING THE EXPONENT, ACCORDINGLY
        LSR     tmp, r1, #31            ;
        ORR     r0, tmp                 ;
        LSL     r1, r1, #1              ;
        CMP     r0, #0                  ;
        BPL     loop                    ;

cont:	ADD     r0, #0x80               ; ADD 1/2 TO ROUND
        BCC     $1			;
        ADD     e0, #0x1                ; AND ADJUST THE EXPONENT ACCORDINGLY
        B       $2			;
 
$1:	LSL     r0, r0, #1              ; MASK IMPLIED 1 OUT OF THE MANTISSA
 
$2:	LSR     r0, r0, #9              ; PACK THE MANTISSA
        LSL     e0, e0, #23             ;
        ORR     r0, e0                  ; PACK THE EXPONENT

	POP	{r2, r3, pc}		;

	.endasmfunc
	.end

ull_tofs32.asm/ 1202506633  0     0     0       2811      `
;******************************************************************************
;* ULL_TOFS32.ASM  - 32 BIT STATE -  v2.70                                    *
;* Copyright (c) 1996-2008 Texas Instruments Incorporated                     *
;******************************************************************************

;****************************************************************************
;* ULL_TOFS - CONVERT A 64 BIT UNSIGNED INTEGER TO AN IEEE 754 FORMAT
;*            SINGLE PRECISION FLOATING POINT NUMBER
;****************************************************************************
;*
;*   o INPUT OP IS IN R0:R1 (R1:R0 IF LITTLE ENDIAN)
;*   o RESULT IS RETURNED IN R0
;*
;*   o ROUNDING MODE:  ROUND TO NEAREST
;*
;****************************************************************************
;*
;* +--------------------------------------------------------------+
;* | SINGLE PRECISION FLOATING POINT FORMAT                       |
;* |								  |
;* |   31 30    23 22                    0			  |
;* |   +-+--------+-----------------------+			  |
;* |   |S|    E   |           M           +			  |
;* |   +-+--------+-----------------------+			  |
;* |								  |
;* |   <S>  SIGN FIELD    :        0 - POSITIVE VALUE		  |
;* |			           1 - NEGATIVE VALUE		  |
;* |								  |
;* |   <E>  EXPONENT FIELD:       00 - ZERO IFF M == 0		  |
;* |			     01...FE - EXPONENT VALUE (127 BIAS)  |
;* |				  FF - INFINITY			  |
;* |								  |
;* |   <M>  MANTISSA FIELD:  FRACTIONAL MAGNITUDE WITH IMPLIED 1  |
;* +--------------------------------------------------------------+
;*
;****************************************************************************
	.state32

	.global ULL_TOFS

e0	.set	lr

ULL_TOFS: .asmfunc stack_usage(4)
        CMP	r0, #0			; 
        CMPEQ	r1, #0			; 
	MOVEQ	pc, lr			; IF ZERO, RETURN ZERO

	STR	lr, [sp, #-4]!		; SAVE CONTEXT

	; IN LITTLE ENDIAN MODE THE INPUT LONG LONG VALUE IS IN R1:R0. SWAP THE
	; WORDS SO THAT WE HAVE THE LONG LONG VAULUE IN R0:R1.

	.if .TMS470_LITTLE
	MOV	lr, r0			;
	MOV	r0, r1			;
	MOV	r1, lr			;
	.endif

	MOV	e0, #0xBE		; SET THE EXPONENT FIELD

        CMP	r0, #0			; IF MSB IS 1, THE VALUE IS ALREADY
	BMI	cont			; NORMALIZED.

loop:	MOVS	r0, r0, LSL #1		; NORMALIZE THE MANTISSA
        ORR     r0, r0, r1, LSR #31     ;
        MOV     r1, r1, LSL #1          ;
	SUB	e0, e0, #1		; ADJUSTING THE EXPONENT, ACCORDINGLY
	BPL	loop			;

cont:	ADDS	r0, r0, #0x00000080	; ADD 1/2 TO ROUND
	ADDCS	e0, e0, #0x1		; AND ADJUST THE EXPONENT ACCORDINGLY

	MOVCC	r0, r0, LSL #1		; MASK THE IMPLIED ONE IN THE MANTISSA
	MOV	r0, r0, LSR #9		; PACK THE MANTISSA
	ORR	r0, r0, e0, LSL #23	; PACK THE EXPONENT

	LDR	pc, [sp], #4		; RESTORE CONTEXT

	.endasmfunc
	.end

unaccess.h/     1202506633  0     0     0       36        `
/* unaccess.h: Empty by default */
ungetc.c/       1202506633  0     0     0       3503      `
/*****************************************************************************/
/*  UNGETC.C v2.70                                                           */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    UNGETC   -  Push a character back onto a stream                        */
/*****************************************************************************/
#include <stdio.h>


/*****************************************************************************/
/* UNGETC   -  Push a character back onto a stream                           */
/*                                                                           */
/*    This function returns the character pushed back upon success, or an    */
/*    EOF upon failure.                                                      */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int ungetc(int _c, register FILE *_fp)
{
   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the character is an EOF, or if an UNGETC has already been performed */
   /* and there is no room left in the buffer, return an EOF.                */
   /*------------------------------------------------------------------------*/
   if(_c == EOF || (_fp->pos < _fp->buf)) return (EOF);

   /*------------------------------------------------------------------------*/
   /* If the file is in update mode, and is currently writing, change it to  */
   /* read mode.                                                             */
   /*------------------------------------------------------------------------*/
   if(_STCHK(_fp, _MODERW))
   {
      _UNSET(_fp, _MODEW);
      _SET(_fp, _MODER);
   }
 
   /*------------------------------------------------------------------------*/
   /* Set up a buffer if one is needed, and none exists.                     */
   /*------------------------------------------------------------------------*/
   if(_fp->buf == NULL && !_STCHK(_fp, _IONBF))
      if(setvbuf(_fp, NULL, _BUFFMODE(_fp), BUFSIZ) == EOF) return (EOF);
 
   /*------------------------------------------------------------------------*/
   /* Put the character in the buffer, set the _UNGETC flag in the stream,   */
   /* and clear the EOF flag in the stream.                                  */
   /*------------------------------------------------------------------------*/
   *(--_fp->pos) = (unsigned char)_c;
   _SET(_fp, _UNGETC);
   _UNSET(_fp, _STATEOF);

   /*------------------------------------------------------------------------*/
   /* If this is an UNGETC on an empty file, make the end of the read buffer.*/
   /*------------------------------------------------------------------------*/
   if(!_fp->buff_stop) _fp->buff_stop = _fp->buf;

   return ((unsigned char)_c);
}


values.h/       1202506633  0     0     0       9283      `
/*****************************************************************************/
/* values.h   v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#ifndef _VALUES
#define _VALUES

#define BITS	  52                           /* Number of bits in mantissa */
#define MAXX      7.09782712893383973096e+02   /* ln(HUGE_VAL)               */
#define MAXH      7.10475860073943863426e+02   /* ln(HUGE_VAL) + ln(2)       */
#define XBIG      1.87149738751185239494e+01   /* (BITS/2 + 1) * ln(2)       */

/****************************************************************************/
/*  The following macros define constants used throughout the functions.    */
/****************************************************************************/
/* macros used in asin and acos */

#define SQRTWO	  1.4142135623730950
#if BITS<=24
#define ASP1	  0.933935835
#define ASP2	 -0.504400557
#define ASQ0	  0.560363004e1
#define ASQ1	 -0.554846723e1
#elif BITS>=25 && BITS<=36
#define ASP1	 -0.27516555290596e1
#define ASP2	  0.29058762374859e1
#define ASP3	 -0.59450144193246
#define ASQ0	 -0.16509933202424e2
#define ASQ1	  0.24864728969164e2
#define ASQ2	 -0.10333867072113e2
#elif BITS>=37 && BITS<=48
#define ASP1	  0.85372164366771950e1
#define ASP2	 -0.13428707913425312e2
#define ASP3	  0.59683157617751534e1
#define ASP4	 -0.65404068999335009
#define ASQ0	  0.51223298620109691e2
#define ASQ1	 -0.10362273186401480e3
#define ASQ2	  0.68719597653808806e2
#define ASQ3	 -0.16429557557495170e2
#else
#define ASP1	 -0.27368494524164255994e2
#define ASP2	  0.57208227877891731407e2
#define ASP3	 -0.39688862997504877339e2
#define ASP4	  0.10152522233806463645e2
#define ASP5	 -0.69674573447350646411
#define ASQ0	 -0.16421096714498560795e3
#define ASQ1	  0.41714430248260412556e3
#define ASQ2	 -0.38186303361750149284e3
#define ASQ3	  0.15095270841030604719e3
#define ASQ4	 -0.23823859153670238830e2
#endif

/* macros used in atan and atan2 */

#define TWO_SQRT3 0.26794919243112270647
#define SQRTTHREE 1.73205080756887729353
#define PI	  3.14159265358979323846
#if BITS<=24
#define ATP0	 -0.4708325141
#define ATP1	 -0.5090958253e-1
#define ATQ0	  0.1412500740e1
#elif BITS>=25 && BITS<=32
#define ATP0	 -0.144008344874e1
#define ATP1	 -0.720026848898
#define ATQ0	  0.432025038919e1
#define ATQ1	  0.475222584599e1
#elif BITS>=33 && BITS<=50
#define ATP0	 -0.427432672026241096e1
#define ATP1	 -0.427444985367930329e1
#define ATP2	 -0.794391295408336251
#define ATQ0	  0.128229801607919841e2
#define ATQ1	  0.205171376564218456e2
#define ATQ2	  0.919789364835039806e1
#else
#define ATP0	 -0.13688768894191926929e2
#define ATP1	 -0.20505855195861651981e2
#define ATP2	 -0.84946240351320683534e1
#define ATP3	 -0.83758299368150059274
#define ATQ0	  0.41066306682575781263e2
#define ATQ1	  0.86157349597130242515e2
#define ATQ2	  0.59578436142597344465e2
#define ATQ3	  0.15024001160028576121e2
#endif

/* macros used in sin and cos */

#define INVSPI	  0.31830988618379067154
#define HALFPI	  1.57079632679489661923
#if BITS<=32
#define C1	  3.140625
#define C2	  9.67653589793e-4
#else
#define C1	  3.1416015625
#define C2	 -8.908910206761537356617e-6
#endif
#if BITS<=24
#define R1	 -0.1666665668e+0
#define R2	  0.8333025139e-2
#define R3	 -0.1980741872e-3
#define R4	  0.2601903036e-5
#elif BITS>=25 && BITS<=32
#define R1	 -0.1666666660883
#define R2	  0.8333330720556e-2
#define R3	 -0.1984083282313e-3
#define R4	  0.2752397106775e-5
#define R5	 -0.2386834640601e-7
#elif BITS>=33 && BITS<=50
#define R1	 -0.166666666666659653
#define R2	  0.833333333327592139e-2
#define R3	 -0.198412698232225068e-3
#define R4	  0.275573164212926457e-5
#define R5	 -0.250518708834705760e-7
#define R6	  0.160478446323816900e-9
#define R7	 -0.737066277507114174e-12
#else
#define R1	 -0.16666666666666665052
#define R2	  0.83333333333331650314e-2
#define R3	 -0.19841269841201840457e-3
#define R4	  0.27557319210152756119e-5
#define R5	 -0.25052106798274584544e-7
#define R6	  0.16058936490371589114e-9
#define R7	 -0.76429178068910467734e-12
#define R8	  0.27204790957888846175e-14
#endif

/* macros used in exp, cosh, and sinh */

#define LOGe2	  0.6931471805599453094172321
#define LOG102    0.301029995663981198017
#define INVLOGe2  1.4426950408889634074
#if BITS<=29
#define EXP0	  0.24999999950
#define EXP1	  0.41602886268e-2
#define EXQ0	  0.5
#define EXQ1	  0.49987178778e-1
#elif BITS>=30 && BITS<=42
#define EXP0	  0.24999999999992
#define EXP1	  0.59504254977591e-2
#define EXQ0	  0.5
#define EXQ1	  0.53567517645222e-1
#define EXQ2	  0.29729363682238e-3
#elif BITS>=43 && BITS<=56
#define EXP0	  0.249999999999999993
#define EXP1	  0.694360001511792852e-2
#define EXP2	  0.165203300268279130e-4
#define EXQ0	  0.5
#define EXQ1	  0.555538666969001188e-1
#define EXQ2	  0.495862884905441294e-3
#else
#define EXP0	  0.25
#define EXP1	  7.5753180159422776666e-3
#define EXP2	  3.1555192765684646356e-5
#define EXQ0	  0.5
#define EXQ1	  5.6817302698551221787e-2
#define EXQ2	  6.3121894374398503557e-4
#define EXQ3	  7.5104028399870046114e-7
#endif
#if BITS<=24
#define SHP0	 -0.713793159e1
#define SHP1	 -0.190333399
#define SHQ0	 -0.428277109e2
#elif BITS>=25 && BITS<=40
#define SHP0	  0.10622288837151e4
#define SHP1	  0.31359756456058e2
#define SHP2	  0.34364140358506
#define SHQ0	  0.63733733021822e4
#define SHQ1	 -0.13051012509199e3
#elif BITS>=41 && BITS<=50
#define SHP0	  0.23941435923050069e4
#define SHP1	  0.85943284838549010e2
#define SHP2	  0.13286428669224229e1
#define SHP3	  0.77239398202941923e-2
#define SHQ0	  0.14364861553830292e5
#define SHQ1	 -0.20258336866427869e3
#else
#define SHP0	 -0.35181283430177117881e6
#define SHP1	 -0.11563521196851768270e5
#define SHP2	 -0.16375798202630751372e3
#define SHP3	 -0.78966127417357099479
#define SHQ0	 -0.21108770058106271242e7
#define SHQ1	  0.36162723109421836460e5
#define SHQ2	 -0.27773523119650701667e3
#endif

/* macros used in log10 and log */

#define SQRTHALF  0.70710678118654752440
#define LOG10e	  0.4342944819032518
#define C3	  0.693359375
#define C4	 -2.121944400546905827679e-4
#if BITS<=24
#define A0	 -0.5527074855
#define B0	 -0.6632718214e1
#elif BITS>=25 && BITS<=32
#define A0	 -0.4649062303464
#define A1	  0.1360095468621e-1
#define B0	 -0.5578873750242e1
#elif BITS>=33 && BITS<=48
#define A0	  0.37339168963160866e1
#define A1	 -0.63260866233859665
#define A2	  0.44445515109803323e-2
#define B0	  0.44807002755736436e2
#define B1	 -0.14312354355885324e2
#else
#define A0	 -0.64124943423745581147e2
#define A1	  0.16383943563021534222e2
#define A2	 -0.78956112887491257267
#define B0	 -0.76949932108494879777e3
#define B1	  0.31203222091924532844e3
#define B2	 -0.35667977739034646171e2
#endif

/* macros used in pow */

#define L1	  2.885390072738
#define L3	  0.961800762286
#define L5	  0.576584342056
#define L7	  0.434259751292
#define T6	  0.0002082045327
#define T5	  0.001266912225
#define T4	  0.009656843287
#define T3	  0.05549288453
#define T2	  0.2402279975
#define T1	  0.6931471019

/* macros used in tan */

#define TWOINVPI  0.63661977236758134308
#if BITS<=32
#define C5	  1.5703125
#define C6	  4.83826794897e-4
#else
#define C5	  1.57080078125
#define C6	 -4.454455103380768678308e-6
#endif
#if BITS<=24
#define TAP1	 -0.958017723e-1
#define TAQ1	 -0.429135777e+0
#define TAQ2	  0.971685835e-2
#elif BITS>=25 && BITS<=32
#define TAP1	 -0.1113614403566
#define TAP2	  0.1075154738488e-2
#define TAQ1	 -0.4446947720281
#define TAQ2	  0.1597339213300e-1
#elif BITS>=33 && BITS<=52
#define TAP1	 -0.1282834704095743847
#define TAP2	  0.2805918241169988906e-2
#define TAP3	 -0.7483634966612065149e-5
#define TAQ1	 -0.4616168037429048840
#define TAQ2	  0.2334485282206872802e-1
#define TAQ3	 -0.2084480442203870948e-3
#else
#define TAP1	 -0.13338350006421960681
#define TAP2	  0.34248878235890589960e-2
#define TAP3	 -0.17861707342254426711e-4
#define TAQ1	 -0.46671683339755294240
#define TAQ2	  0.25663832289440112864
#define TAQ3	 -0.31181531907010027307e-3
#define TAQ4	  0.49819433993786512270e-6
#endif

/* macros used in tanh */

#define LOGe3by2  0.54930614433405484570
#if BITS<=24
#define THP0	 -0.8237728127
#define THP1	 -0.3831010665e-2
#define THQ0	  0.2471319654e1
#elif BITS>=25 && BITS<=36
#define THP0	 -0.21063958000245e2
#define THP1	 -0.93363475652401
#define THQ0	  0.63191874015582e2
#define THQ1	  0.28077653470471e2
#elif BITS>=37 && BITS<=48
#define THP0	 -0.19059522426982292e2
#define THP1	 -0.92318689451426177
#define THP2	 -0.36242421934642173e-3
#define THQ0	  0.57178567280965817e2
#define THQ1	  0.25640987595178975e2
#else
#define THP0	 -0.16134119023996228053e4
#define THP1	 -0.99225929672236083313e2
#define THP2	 -0.96437492777225469787
#define THQ0	  0.48402357071988688686e4
#define THQ1	  0.22337720718962312926e4
#define THQ2	  0.11274474380534949335e3
#endif

#endif /* _VALUES */

vfprintf.c/     1202506633  0     0     0       2788      `
/*****************************************************************************/
/*  VFRINTF.C v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VFPRINTF -  Print formatted output to a stream                         */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include "format.h"
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op, 
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 
/*****************************************************************************/
/* VFPRINTF -  Print formatted output to a stream                            */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream _FP.              */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int vfprintf(FILE *_fp, const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(_fp->fd == -1) return (-1);

   return (_printfi(&fptr, _ap, (void *)_fp, _outc, _outs));
 
}
 
/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 
/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }
vprintf.c/      1202506633  0     0     0       2793      `
/*****************************************************************************/
/*  VPRINTF.C v2.70                                                          */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VPRINTF  -  Print formatted output to stdio                            */
/*    _OUTC    -  Put a character in a stream                                */
/*    _OUTS    -  Put a string in a stream                                   */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);
 

/*****************************************************************************/
/* VPRINTF  -  Print formatted output to a stdio                             */
/*                                                                           */
/*    This function passes a the format string and an argument list to       */
/*    _PRINTFI, and writes the result string to the stream stdio.            */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int vprintf(const char *_format, va_list _ap)
{
   char *fptr = (char *)_format;

   /*------------------------------------------------------------------------*/
   /* If the current stream is not associated with a file, return an error.  */
   /*------------------------------------------------------------------------*/
   if(stdout->fd == -1) return (EOF);

   return (_printfi(&fptr, _ap, (void *)stdout, _outc, _outs));
 
}
 

/*****************************************************************************/
/* _OUTC -  Put a character in a stream                                      */
/*****************************************************************************/
static int _outc(char c, void *_op) { return (fputc(c, (FILE *)_op)); }
 

/*****************************************************************************/
/* _OUTS -  Put a string in a stream                                         */
/*****************************************************************************/
static int _outs(char *s, void *_op) { return (fputs(s, (FILE *)_op)); }


vsnprintf.c/    1202506633  0     0     0       3268      `
/*****************************************************************************/
/*  VSNPRINTF.C v2.70                                                        */
/*  Copyright (c) 2001-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VSNPRINTF -  Copy formatted output to a string                         */
/*    _OUTC     -  Put a character in a string                               */
/*    _OUTS     -  Append a string to another string                         */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);

struct holder {
    char  *out_end;
    size_t n;
    size_t written;
};


/*****************************************************************************/
/* VSNPRINTF -  Copy formatted output to a string                            */
/*                                                                           */
/*    This function passes a format string and an argument list to           */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int vsnprintf(char *_string, size_t _n,
			   const char *_format, va_list _ap)
{
    int    rval;
    char  *fptr = (char *)_format;
    struct holder holder; 

    holder.out_end = _string;
    holder.n       = _n;
    holder.written = 0;

    rval = _printfi(&fptr, _ap, (void *)&holder, _outc, _outs);
    
    if (_n) *holder.out_end = '\0';
    
    return rval;
}


/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
    struct holder *holder = (struct holder *)_op;
    
    if (holder->written < holder->n)
	*holder->out_end++ = c;
    
    holder->written++;
    
    return c;
}
 

/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
    struct holder *holder = (struct holder *)_op;
    size_t len = strlen(s);

    if (holder->written < holder->n)
    {
	size_t space = holder->n - holder->written;
	size_t use = len > space ? space : len;
	memcpy(holder->out_end, s, use);
	holder->out_end += use;
    }
    
    holder->written += len;

    return len;
}
 
vsprintf.c/     1202506633  0     0     0       2711      `
/*****************************************************************************/
/*  VSPRINTF.C v2.70                                                         */
/*  Copyright (c) 1995-2008 Texas Instruments Incorporated                   */
/*****************************************************************************/

/*****************************************************************************/
/* Functions:                                                                */
/*    VSPRINTF -  Copy formatted output to a string                          */
/*    _OUTC    -  Put a character in a string                                */
/*    _OUTS    -  Append a string to another string                          */
/*****************************************************************************/
#include <stdio.h>
#include "format.h"
#include <stdarg.h>
#include <string.h>
 
extern int _printfi(char **_format, va_list _ap, void *_op,
                    int (*_outc)(char, void *), int (*_outs)(char *, void *));
 
static int _outc(char c, void *_op);
static int _outs(char *s, void *_op);


/*****************************************************************************/
/* VSPRINTF -  Copy formatted output to a string                             */
/*                                                                           */
/*    This function passes a format string and an argument list to           */
/*    _PRINTFI, and writes the result string to the string _STRING.          */
/*                                                                           */
/*****************************************************************************/
_CODE_ACCESS int vsprintf(char *_string, const char *_format, va_list _ap)
{
    int   rval;
    char *fptr = (char *)_format;
    char *out_end = _string;

    rval = _printfi(&fptr, _ap, (void *)&out_end, _outc, _outs);

    *out_end = '\0';

    return rval;
}


/*****************************************************************************/
/* _OUTC -  Put a character in a string                                      */
/*****************************************************************************/
static int _outc(char c, void *_op)
{
    return *(*((char **)_op))++ = c;
}
 

/*****************************************************************************/
/* _OUTS -  Append a string to another string                                */
/*****************************************************************************/
static int _outs(char *s, void *_op)
{
    size_t len = strlen(s);
    
    memcpy(*((char **)_op), s, len);
    *((char **)_op) += len;
    return len;
}
 

vtbl.h/         1202506633  0     0     0       1169      `
/*****************************************************************************/
/* VTBL.H     v2.70                                                          */
/* Copyright (c) 1996-2008 Texas Instruments Incorporated                    */
/*****************************************************************************/

#include <rtti.h>

namespace std
{
   /***************************************************************************/
   /* VIRTUAL FUNCTION TABLE ENTRY                                            */
   /***************************************************************************/
   typedef struct vtbl_entry_first
   {
      short                  delta;   /* OFFSET TO GET TO THE COMPLETE OBJECT */
      struct type_info_impl *class_info; /* DYNAMIC TYPE OF OBJECT            */
   } VTBL_ENTRY_FIRST;

   typedef struct vtbl_entry_rest
   {
      short   delta;      /* OFFSET TO GET TO THE COMPLETE OBJECT   */
      void  (*func)();    /* VIRTUAL FUNCTION TO BE CALLED          */
   } VTBL_ENTRY_REST;

   typedef union vtbl_entry
   {
      VTBL_ENTRY_FIRST first;
      VTBL_ENTRY_REST rest;
   } VTBL_ENTRY;
}


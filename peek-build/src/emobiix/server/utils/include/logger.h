#ifndef __LOGGINGUTILS_H__
#define __LOGGINGUTILS_H__

#include <iostream>
#include <iomanip>
#include <string>

/// Helper wrappers for the available logging levels
#define ERRORLOG(LOG) LOGGER(emobiix::LOG_ERROR,LOG)
#define INFOLOG(LOG) LOGGER(emobiix::LOG_INFO,LOG)
#define DEBUGLOG(LOG) LOGGER(emobiix::LOG_DEBUG,LOG)
#define TRACELOG(LOG) LOGGER(emobiix::LOG_VERBOSE,LOG)

#define SCOPE_STRAT(PREFIX) emobiix::logger::Scope scope(PREFIX);

/**
 * Logger wrapper for printing messages based on a pre-configured debugging 
 * level, done as a define in order to allow passing accurate file, line and
 * function information to be logged
 *
 * @param LEVEL Debug level of the message to be logged
 * @param LOG           Actual message to be printed, directed to an ostream
 */
#define LOGGER(LEVEL,LOG) do { \
        if (LEVEL <= emobiix::logger::Logger().GetLevel()) { \
                static char buffer[1024] = { 0 }; \
                static const char *function = NULL; \
                if (!function) \
                { \
                        strncpy(buffer, __PRETTY_FUNCTION__, sizeof(buffer) - 1); \
                        function = emobiix::logger::FormatFunction(buffer); \
                } \
                emobiix::logger::Logger().Log(LEVEL,__FILE__,__LINE__,function) << LOG << std::endl;       \
        }\
} while(0)

namespace emobiix
{
	enum eLogLevel
	{
		LOG_ERROR = 0,
		LOG_INFO,
		LOG_DEBUG,
		LOG_VERBOSE
	};

	/**
	 * Singleton class responsible for logging messages with a specified log level
	 * along with the file, line, and function which generated the logging message
	 * to a specified stream
	 */
	struct logger
	{
		private:

			/**
			 * Private constructor, initialized with a default logging level and stream
			 */
			logger();

		public:
			/**
			 * Retrieves an instance of the logger class
			 *
			 * @return A reference to the instance of the logger class
			 */
			static logger &Logger()
			{
				static logger logger;
				return logger;
			}

			/**
			 * Allows over-riding the stream being used by the logger
			 *
			 * @param stream        New stream to be used for logging
			 */
			void SetStream(std::ostream &stream);

			/**
			 * Allows over-riding the default logging level for the logger
			 *
			 * @param nLogLevel     New logging level
			 */
			void SetLevel(eLogLevel nLogLevel);

			/**
			 * Retrieves the current maximum logging level of the logger
			 *
			 * @return Log level beyond which messages should not be printed
			 */
			eLogLevel GetLevel() const;

			/**
			 * Writes the prefix of a log message to the stream
			 *
			 * @param       level                   Logging level of the following message
			 * @param       file                    File within which the logging message was generated
			 * @param       line                    Line at which the logging message was generated
			 * @param       function        Fully-qualified function name that generated the message
			 * @return      Reference to the stream that the log prefix was written to
			 */
			std::ostream &Log(eLogLevel level, const char *file, int line, const char *function);

			/**
			 * Removes the parameter list and return type from a "pretty" function
			 *
			 * @param szFunction "Pretty" function generated by the compiler to be cleaned
			 * @return Pointer to the beginning of the function name
			 */
			static const char* FormatFunction(char *szFunction);

			static std::string GetCurrentLocal();

		private:

			/// Maximum logging level to be logged, messages above that level will not get logged
			eLogLevel m_nLogLevel;

			/// Stream to which logging messages are written to
			std::ostream* m_stream;       
	};
};

#endif // __LOGGINGUTILS_H__
